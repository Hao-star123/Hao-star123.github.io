<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++学习笔记</title>
      <link href="/2023/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-copy/"/>
      <url>/2023/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-copy/</url>
      
        <content type="html"><![CDATA[<hr /><h2 id="theme-v-green"><a class="markdownIt-Anchor" href="#theme-v-green"></a> theme: v-green</h2><h1 id="第一章从c到c"><a class="markdownIt-Anchor" href="#第一章从c到c"></a> 第一章从C到C++</h1><h2 id="类和对象的基本概念与用法1"><a class="markdownIt-Anchor" href="#类和对象的基本概念与用法1"></a> 类和对象的基本概念与用法(1)</h2><blockquote><p>对象的内存分配：成员函数不被包括在对象的内存吗？</p></blockquote><h2 id="类和对象的基本概念2"><a class="markdownIt-Anchor" href="#类和对象的基本概念2"></a> 类和对象的基本概念(2)</h2><blockquote><p>question1</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设A是一个类的名字，下面的程序片段会调用类A的析构函数几次？ 答案：3次</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A * p = <span class="keyword">new</span> A[<span class="number">2</span>];</span><br><span class="line">A * p2 = <span class="keyword">new</span> A;</span><br><span class="line">A a;</span><br><span class="line"><span class="keyword">delete</span> [] p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不能访问私有成员变量？</p></blockquote><h2 id="2-构造函数"><a class="markdownIt-Anchor" href="#2-构造函数"></a> 2. 构造函数</h2><blockquote><p>对象所占用的存储空间是不是也是构造函数分配的？</p><p>answer：对象函数是在对象已经占用存储空间以后，在对象存储空间中做初始化的操作</p></blockquote><blockquote><p>对象一定有构造函数，如果定义类的时候没有写构造函数，则编译器生成个默认的无参数的构造函数</p><ul><li>默认构造函数无参数，不做任何操作</li></ul></blockquote><p>构造函数在数组中的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Test</span>( <span class="type">int</span> n)&#123;&#125;<span class="comment">//(1)</span></span><br><span class="line">        <span class="built_in">Test</span>( <span class="type">int</span> n, <span class="type">int</span> m) &#123;&#125;<span class="comment">//(2)</span></span><br><span class="line">        <span class="built_in">Test</span>()&#123;&#125;<span class="comment">//(3)</span></span><br><span class="line">&#125;;</span><br><span class="line">Test array1[<span class="number">3</span>]= &#123; <span class="number">1</span>, <span class="built_in">Test</span>(<span class="number">1</span>,<span class="number">2</span>)&#125;;<span class="comment">//三个元素分别用(1),(2),(3)初始化</span></span><br><span class="line">Test array2[<span class="number">3</span>]= &#123; <span class="built_in">Test</span>(<span class="number">2</span>,<span class="number">3</span>), <span class="built_in">Test</span>(<span class="number">1</span>,<span class="number">2</span>),<span class="number">1</span>&#125;;(/三个元素分别用(<span class="number">2</span>),(<span class="number">2</span>), (<span class="number">1</span>)初始化</span><br><span class="line">Test * pArray[<span class="number">3</span>]= &#123; <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">4</span>), <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">1</span>,<span class="number">2</span>)&#125;<span class="comment">//两个元素分别用(1),(2)初始化</span></span><br></pre></td></tr></table></figure><p>对于代码中的 <code>Test array1[3] = &#123;1, Test(1,2)&#125;</code>，它创建了一个名为 <code>array1</code> 的 <code>Test</code> 类型的数组，并初始化了其中的元素。</p><p><code>Test(1,2)</code> 是以参数值 <code>1</code> 和 <code>2</code> 调用 <code>Test</code> 类的构造函数 <code>(2)</code> 来创建一个临时对象。这个临时对象将被用来初始化 <code>array1</code> 中的第二个元素。</p><p>因此，<code>Test(1,2)</code> 将调用 <code>(2)</code> 构造函数，而不是其他的构造函数 <code>(1)</code> 或 <code>(3)</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习笔记</title>
      <link href="/2023/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="本笔记依据计算机网络自顶向下整理"><a class="markdownIt-Anchor" href="#本笔记依据计算机网络自顶向下整理"></a> 本笔记依据《计算机网络（自顶向下）》整理</h2>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构学习笔记</title>
      <link href="/2023/09/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本笔记依据《数据结构（c语言版）》（第二版）殷人昆和《数据结构精讲与习题详解》整理</p><hr /><h1 id="第一章绪论"><a class="markdownIt-Anchor" href="#第一章绪论"></a> 第一章绪论</h1><h2 id="11数据结构的概念及分类"><a class="markdownIt-Anchor" href="#11数据结构的概念及分类"></a> 1.1数据结构的概念及分类</h2><h3 id="112与数据结构相关的基本术语"><a class="markdownIt-Anchor" href="#112与数据结构相关的基本术语"></a> 1.1.2与数据结构相关的基本术语</h3><h4 id="7抽象数据类型adt"><a class="markdownIt-Anchor" href="#7抽象数据类型adt"></a> 7.抽象数据类型ADT</h4><blockquote><p>思考题：系统开发中数据设计三视图为数据内容，数据结构和数据流其中有关数据结构的道路主要涉及数据元素之间的关系，那么数据元素内容应在什么时候考虑？</p></blockquote><p>数据元素的内容应在系统开发的早期阶段考虑，并且通常是在数据设计的第一个视图——数据内容视图中进行定义和确定的。数据设计的三个视图包括数据内容视图、数据结构视图和数据流视图，这些视图通常是并行进行的，但它们之间存在着一定的依赖关系。</p><p>以下是关于何时考虑数据元素内容的一些重要考虑因素：</p><ol><li><strong>需求分析阶段：</strong> 在系统开发的早期，首先要进行需求分析。这一阶段涉及与项目相关的各方（包括业务用户、利益相关者等）合作，以了解他们的需求和期望。在这个过程中，要确定系统需要收集、存储和处理哪些数据。这有助于确定数据元素的内容。</li><li><strong>数据模型设计：</strong> 在需求分析之后，您可以开始设计数据模型，其中包括定义数据元素的内容。这通常涉及到创建实体-关系图（ER图）或其他数据建模工具，以明确定义数据元素之间的关系、属性和约束。</li><li><strong>数据字典：</strong> 创建数据字典是一种记录数据元素内容和定义的方式。数据字典包含了关于每个数据元素的详细信息，包括名称、数据类型、长度、格式、描述、取值范围等。这是确保整个开发团队对数据元素有清晰共识的重要工具。</li><li><strong>数据结构视图：</strong> 一旦数据元素的内容确定，您可以开始考虑数据元素之间的关系和如何组织它们以满足系统的功能需求。这会涉及到定义表、字段、键和约束等。</li></ol><p>总之，数据元素内容的考虑应该尽早进行，并与系统开发的其他阶段紧密协调。这有助于确保系统可以有效地收集、存储和处理所需的数据，同时也有助于减少后期开发中的变更和修正。在整个系统开发过程中，数据设计的三视图都需要不断协同工作，以确保数据的一致性、完整性和可用性。</p><h3 id="113数据结构的分类"><a class="markdownIt-Anchor" href="#113数据结构的分类"></a> 1.1.3数据结构的分类</h3><h4 id="2逻辑结构与存储结构"><a class="markdownIt-Anchor" href="#2逻辑结构与存储结构"></a> 2.逻辑结构与存储结构</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce16be58974646aeb04cbe94c7b87829~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3184&amp;h=440&amp;s=91746&amp;e=jpg&amp;b=fefefe" alt="映射到_使用.jpg" /></p><h4 id="3逻辑结果的分类"><a class="markdownIt-Anchor" href="#3逻辑结果的分类"></a> 3.逻辑结果的分类</h4><ul><li>（1）线性结构</li><li>（2）非线性结构</li></ul><blockquote><p>多维数组和广义表属于线性表的扩展，从宏观山看，不具有线性结构的一对一的特点，从可共享情况来看，又有多对多的特点</p></blockquote><ol><li><strong>多维数组（Multidimensional Array）：</strong> 多维数组是一种扩展的线性表，它可以看作是多个一维数组的组合。多维数组中的元素是通过多个索引（通常是多维的）来访问的。这意味着每个元素可以由多个维度的索引组合来唯一确定，因此不再具有传统线性表的一对一结构。例如，在二维数组中，元素可以通过行索引和列索引来定位，这是多对多的关系。</li><li><strong>广义表（Generalized List）：</strong> 广义表是一种更灵活的数据结构，它允许在一个表中包含多种类型的元素，包括原子元素和子表（广义表的嵌套）。这使得广义表可以表示更复杂的数据结构，如树状结构或图状结构。因为广义表可以包含多个元素，其中一些可以是子表，因此也具有多对多的特点。</li></ol><p>从宏观角度来看，多维数组和广义表都在某种程度上扩展了线性表的概念，允许更复杂的数据结构和多对多的关系。这使它们更适合表示和处理更复杂的数据组织需求。</p><p>从可共享性的角度来看，这两种数据结构也可以包含多对多的关系。在多维数组中，多个元素可以共享相同的行或列，而在广义表中，多个元素可以共享相同的子表。这种共享性使得数据的组织更加灵活，可以更有效地表示一些复杂的数据关系。</p><blockquote><p>思考题：数据的逻辑结构是否可以独立于存储结构来考虑，反制数据的特殊结构是否可以独立于逻辑结构来考虑？</p></blockquote><p>数据的逻辑结构和存储结构通常是相互关联的，但在某些情况下可以独立考虑，具体取决于数据管理和操作的需求以及系统设计的目标。让我们更详细地探讨这两种情况：</p><ol><li><p><strong>逻辑结构独立于存储结构：</strong></p><p>在某些情况下，您可以定义数据的逻辑结构，而不必关心其具体的存储方式。这通常发生在高层数据模型的设计阶段，例如在数据库设计中。您可以首先定义数据的实体、属性、关系和约束等逻辑结构，而不必考虑如何在物理存储层面实现它们。数据库管理系统会负责将逻辑结构映射到物理存储结构，以便高效地存储和检索数据。这种分离逻辑和物理结构的方法有助于数据抽象和数据独立性，使系统更易于维护和扩展。</p></li><li><p><strong>存储结构独立于逻辑结构：</strong></p><p>在另一方面，有些情况下，您可能需要关注数据的存储方式，而不考虑其逻辑结构。这可能出现在低层数据存储和处理的情况下，例如在编程中。在这种情况下，您可能需要考虑如何在内存或磁盘上组织和访问数据，以便实现特定的算法或性能优化。这可能涉及到数据结构的选择和数据布局的优化，而不必关心数据的逻辑关系。</p></li></ol><p>总的来说，逻辑结构和存储结构的关系通常是相互关联的，但可以根据需要独立考虑。在实际应用中，合理的抽象和分离可以提高系统的可维护性、可扩展性和性能。不过，在设计和开发过程中，需要确保逻辑结构和存储结构之间的一致性，以确保数据在逻辑和物理层面的正确性和有效性。这通常需要仔细的规划和协同工作，以平衡逻辑和存储需求。</p><blockquote><p>思考题：集合结构中的元素之间没有特定的联系，如图那么集合结构属于线性结构还是非线性结构？这是否意味着需要借助其他结构来表示？</p></blockquote><h3 id="114数据结构的存储结构"><a class="markdownIt-Anchor" href="#114数据结构的存储结构"></a> 1.1.4数据结构的存储结构</h3><p>数据结构根据存取方法的不同，可分为3类:</p><ul><li>(1）直接存取结构。可以按序号直接存取某一无素，如向量、多维数组、散列表等。</li><li>(2）顺序存取结构。只能从序列中第一个元素起，按逻辑顺序逐个访问元素，如各种链表结构(单链表、循环链表、双向链表、二叉或三叉链表、图的邻接表等）就属于此类。</li><li>(3）索引结构。通过关键码来识别和访问元素，如线性索引、多叉查找树等。</li></ul><p>一般地,常用的4种存储方式如下:</p><p>(1）顺序存储方式。该存储方式把逻辑上相邻的元素存放到物理位置上相邻的存储单元中，数据元素之间的逻辑关系由存储单元的邻接位置关系来体现。由此得到的存储结构称为顺序存储结构，通常，顺序存储结构可借助程序设计语言中的一维数组来描述。</p><p>(2）链接存储方式。该存储方式不要求逻辑上相邻的元素在物理位置上也相邻，元素之间的逻辑关系由附加的链接指针指示。由此得到的存储结构称为链表存储结构，通常，链表存储结构要借助程序设计语言中的指针类型来描述。</p><p>(3）索引存储方式。该存储方式在存储元素信息的同时还建立索引表。索引表中每一项称为索引项,索引项的形式是（关键码,地址)。关键码是能够标识一个元素的数据项。按照索引项是针对每个元素还是针对一组元素，可分为稠密索引和稀疏索引。此外，根据索引表是一层还是多层,可分为线性索引和多级索引。<br />(4）散列存储方式。该存储方式根据元素的关键码通过一个函数计算直接得到该元素的存储地址。</p><p>上述4种基本的存储结构既可以单独使用，也可以组合起来建立数据结构的存储结构。同一种逻辑结构可以有不同的存储结构。选择何种存储结构来表示相应的逻辑结构，要视不同的资源要求而定。对于数据结构的实现者来说，选择存储结构主要考虑的要素如下:</p><ul><li><p>(1）访问频率。对于其内容需要经常访问但修改不频繁的数据结构,宜采取存取速度快、存储利用率高的存储结构。</p></li><li><p>(2）修改频率。对于其内容经常需要修改的数据结构,宜采用修改速度快、尽可能不移动元素的存储结构。</p></li><li><p>(3）安全保密。对于安全保密要求高的数据结构，宜采用面向对象方法，用类的继承式设计存储结构，用公有(public)、私有(private）和保护(protected）来划定访问级别。要考虑运算的时间和空间要求以及算法的简单性。</p></li></ul><h3 id="115定义在数据结构上的操作"><a class="markdownIt-Anchor" href="#115定义在数据结构上的操作"></a> 1.1.5定义在数据结构上的操作</h3><p>定义在数据结构上的操作是一个操作集,它提供了操纵数据结构的各种运算。对于不同的数据结构，操作集所包含的操作也有所不同。基本的操作有以下几种:</p><ol><li>创建。构建属于数据结构的一个实例，对其所有成分赋予初值。</li><li>销毁。撤销属于数据结构的一个实例，释放实例占用的动态分配的存储空间。</li><li>查找。按照给定值搜索数据结构的一个实例内是否有满足要求的元素或结点。</li><li>插入。把新元素按照指定位置插入到数据结构的一个实例内。</li><li>删除。删去数据结构的一个实例内指定的元素或结点。</li><li>排序。把线性结构内所有元素按照指定域的值从小到大或从大到小重新排列。</li></ol><blockquote><p>思考题为何在数据结构课程中既要讨论各种在解决问题时可能遇到的典型的逻辑结构还要讨论这些逻辑结构的存储映像(存储结构)，此外还要讨论这种数据结构的相关操作(基本运算）及其实现?<br />在数据结构课程中涵盖逻辑结构、存储结构以及相关操作的原因有以下几点：</p></blockquote><ol><li><strong>理解问题和选择合适的数据结构：</strong> 数据结构是解决问题的关键。在解决现实世界的问题时，我们首先需要选择适当的数据结构，以便高效地组织和操作数据。了解不同的逻辑结构，如栈、队列、链表、树、图等，有助于学生理解何时应该使用哪种数据结构，以满足问题的需求。</li><li><strong>存储映像和内存管理：</strong> 理解存储结构有助于学生了解数据在计算机内部的物理存储方式。这对于内存管理和性能优化至关重要。不同的存储结构会对数据的访问和操作产生不同的影响，学生需要知道如何选择适当的存储结构以及如何有效地使用内存。</li><li><strong>操作和算法设计：</strong> 数据结构的基本操作（基本运算）包括插入、删除、查找、遍历等。学生需要了解这些操作的特点和复杂度分析，以便能够设计高效的算法。讨论这些操作还有助于学生理解数据结构的功能和用途。</li><li><strong>实际应用和编程：</strong> 数据结构不仅仅是理论概念，它们在实际编程中起着关键作用。学生需要知道如何实现各种数据结构，以便将它们应用到编程项目中。这包括了解如何在编程语言中表示和操作数据结构。</li></ol><p>综上所述，数据结构课程的综合性质旨在帮助学生建立解决问题的整体思维和编程能力。逻辑结构、存储结构和相关操作之间的关系密切相关，学生通过学习这些内容可以更好地理解和应用数据结构，以解决各种计算和信息处理问题。这些知识不仅对计算机科学专业的学生有价值，对于任何需要处理和组织数据的领域都具有广泛的适用性。</p><h3 id="121-c语言的数据类型"><a class="markdownIt-Anchor" href="#121-c语言的数据类型"></a> 1.2.1 C语言的数据类型</h3><h4 id="1构造性struct"><a class="markdownIt-Anchor" href="#1构造性struct"></a> 1.构造性struct</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">long</span> number;</span><br><span class="line"><span class="type">char</span> *name;</span><br><span class="line"><span class="type">float</span> score;</span><br><span class="line"><span class="type">int</span> code;</span><br><span class="line">&#125;Examinee;</span><br></pre></td></tr></table></figure><blockquote><p>思考题： 如果结构定义时没有写typedef，定义的是一个类型吗？通过Examinee s1定义的考生记录s1是否属于该类型的变量？<br />如果在结构定义时没有使用typedef，那么该结构定义并不会创建一个新的类型，而只会定义一个结构。这意味着Examinee只是一个结构的标签或标识符，而不是一个独立的数据类型。</p></blockquote><p>当您使用Examinee s1来定义考生记录s1时，s1不会被认为是该类型的变量，因为在没有使用typedef的情况下，Examinee只是一个结构的标签，而不是数据类型。要使s1成为该类型的变量，您需要使用typedef来为结构定义创建一个新的数据类型。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> number;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">    <span class="type">int</span> code;</span><br><span class="line">&#125; Examinee;</span><br><span class="line"></span><br><span class="line">Examinee s1; <span class="comment">// 现在s1是Examinee类型的变量</span></span><br></pre></td></tr></table></figure><p>通过这种方式，您定义了一个Examinee类型的变量s1，它可以存储一个考生记录的数据。如果没有使用typedef，s1将无法识别Examinee作为类型，因此会导致编译错误。使用typedef有助于提高代码的可读性和可维护性，因为它允许您为结构定义创建更具有意义的数据类型名称。</p>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言入门</title>
      <link href="/2023/08/13/GO%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
      <url>/2023/08/13/GO%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>笔记根据GO圣经</p></blockquote><hr /><h2 id="程序结构"><a class="markdownIt-Anchor" href="#程序结构"></a> 程序结构</h2><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><h4 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h4><ol><li><a href="https://books.studygolang.com/gopl-zh/ch2/ch2-03.html">2.3.2. 指针</a>  指针是实现标准库中flag包的关键技术，它使用命令行参数来设置对应变量的值，而这些对应命令行标志参数的变量可能会零散分布在整个程序中。为了说明这一点，在早些的echo版本中，就包含了两个可选的命令行参数：<code>-n</code>用于忽略行尾的换行符，<code>-s sep</code>用于指定分隔字符（默认是空格）。</li></ol><h4 id="new"><a class="markdownIt-Anchor" href="#new"></a> new</h4><ol><li>new另一个创建变量的方法是调用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为<code>*T</code>。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="type">int</span>)   <span class="comment">// p, *int 类型, 指向匿名的 int 变量</span></span><br><span class="line">fmt.Println(p)  <span class="comment">// &quot;0xc00001e218&quot;</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// &quot;0&quot;</span></span><br><span class="line">*p = <span class="number">2</span>          <span class="comment">// 设置 int 匿名变量的值为 2</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// &quot;2&quot;</span></span><br></pre></td></tr></table></figure><p>用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用new(T)。换言之，new函数类似是一种语法糖，而不是一个新的基础概念。</p><blockquote><p>语法糖：在编程中，“语法糖”（Syntactic Sugar）是一种语法上的便利特性，它不会引入新的基础概念，但是能够使代码更加简洁、易读或者方便。</p><p> 对于Go语言中的<code>new(T)</code>函数来说，确实可以被称为一种语法糖。虽然它看起来像一个函数调用，但它实际上并不创建新的基础概念。它的功能非常简单，只是为指定类型<code>T</code>分配了足够的内存，并返回指向该内存的指针。</p><p> 与使用普通的变量声明语句来创建变量相比，<code>new(T)</code>的确省去了为临时变量取名的步骤，但实际上并没有引入任何新的概念。使用<code>new(T)</code>只是一种更为简洁的方式来动态分配内存，返回一个指针，使得代码更加清晰和便于使用。</p><p> 这里的&quot;语法糖&quot;一词是用来比喻编程语言中的某种特性，这种特性并不是必需的，也不会引入新的语言规则或语义，而只是为了提高代码的可读性、简洁性或使用便捷性。类似于人们在喝咖啡时可以添加糖来提升口感，但糖本身并非必需的咖啡成分。语法糖是一种让代码更甜的编程技巧。</p></blockquote><ol start="2"><li>在Go语言中，<code>new</code>是一个预定义的函数，而不是关键字。因此，你可以使用<code>new</code>作为变量名来重新定义它，并将其赋予不同的类型。</li></ol><p>在你提供的例子中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delta</span><span class="params">(old, <span class="built_in">new</span> <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span> - old</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你在函数<code>delta</code>的参数列表中使用了<code>int</code>类型的变量名<code>new</code>，这会导致在函数体内部无法直接使用预定义的<code>new</code>函数。由于函数参数优先级高于预定义函数，函数参数名会覆盖预定义的<code>new</code>函数。</p><p>在这种情况下，如果你需要使用预定义的<code>new</code>函数，你可以通过使用包名进行限定来调用它，例如<code>fmt.Println(new(...))</code>。这样做可以明确告诉编译器你想要调用预定义的<code>new</code>函数。</p><p>需要注意的是，虽然在Go语言中可以重新定义<code>new</code>作为变量名，但这样的命名并不推荐，因为这样会导致代码可读性下降，并可能造成混淆。通常，我们应该遵循良好的命名规范，避免使用与预定义函数或关键字相同的名称来定义变量或函数名。这有助于保持代码的清晰和易读性。</p><h4 id="变量的生命周期"><a class="markdownIt-Anchor" href="#变量的生命周期"></a> 变量的生命周期</h4><p>变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。<br />那么Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。</p><p>因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。</p><p>编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var global *int</span><br><span class="line"></span><br><span class="line">func f() &#123;</span><br><span class="line">    var x int</span><br><span class="line">    x = 1</span><br><span class="line">    global = &amp;x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func g() &#123;</span><br><span class="line">    y := new(int)</span><br><span class="line">    *y = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量<code>*y</code>将是不可达的，也就是说可以马上被回收的。因此，<code>*y</code>并没有从函数g中逃逸，编译器可以选择在栈上分配<code>*y</code>的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。</p><p>Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。</p><h3 id="赋值"><a class="markdownIt-Anchor" href="#赋值"></a> 赋值</h3><h4 id="元组赋值"><a class="markdownIt-Anchor" href="#元组赋值"></a> 元组赋值</h4><p>通常，这类函数会用额外的返回值来表达某种错误类型，例如os.Open是用额外的返回值返回一个error类型的错误，还有一些是用来返回布尔值，通常被称为ok。在稍后我们将看到的三个操作都是类似的用法。如果map查找（§4.3）、类型断言（§7.10）或通道接收（§8.4.2）出现在赋值语句的右边，它们都可能会产生两个结果，有一个额外的布尔结果表示操作是否成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v, ok = m[key]             // map lookup</span><br><span class="line">v, ok = x.(T)              // type assertion</span><br><span class="line">v, ok = &lt;-ch               // channel receive</span><br></pre></td></tr></table></figure><p>译注：map查找（§4.3）、类型断言（§7.10）或通道接收（§8.4.2）出现在赋值语句的右边时，并不一定是产生两个结果，也可能只产生一个结果。对于只产生一个结果的情形，map查找失败时会返回零值，类型断言失败时会发生运行时panic异常，通道接收失败时会返回零值（阻塞不算是失败）。例如下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v = m[key]                // map查找，失败时返回零值</span><br><span class="line">v = x.(T)                 // type断言，失败时panic异常</span><br><span class="line">v = &lt;-ch                  // 管道接收，失败时返回零值（阻塞不算是失败）</span><br><span class="line"></span><br><span class="line">_, ok = m[key]            // map返回2个值</span><br><span class="line">_, ok = mm[&quot;&quot;], false     // map返回1个值</span><br><span class="line">_ = mm[&quot;&quot;]                // map返回1个值</span><br></pre></td></tr></table></figure><p>和变量声明一样，我们可以用下划线空白标识符<code>_</code>来丢弃不需要的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_, err = io.Copy(dst, src) // 丢弃字节数</span><br><span class="line">_, ok = x.(T)              // 只检测类型，忽略具体值</span><br></pre></td></tr></table></figure><h3 id="类型"><a class="markdownIt-Anchor" href="#类型"></a> 类型</h3><p>为了说明类型声明，我们将不同温度单位分别定义为不同的类型：</p><p><em><a href="http://gopl.io/ch2/tempconv0">gopl.io/ch2/tempconv0</a></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Package tempconv performs Celsius and Fahrenheit temperature computations.</span><br><span class="line">package tempconv</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Celsius float64    // 摄氏温度</span><br><span class="line">type Fahrenheit float64 // 华氏温度</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    AbsoluteZeroC Celsius = -273.15 // 绝对零度</span><br><span class="line">    FreezingC     Celsius = 0       // 结冰点温度</span><br><span class="line">    BoilingC      Celsius = 100     // 沸水温度</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func CToF(c Celsius) Fahrenheit &#123; return Fahrenheit(c*9/5 + 32) &#125;</span><br><span class="line"></span><br><span class="line">func FToC(f Fahrenheit) Celsius &#123; return Celsius((f - 32) * 5 / 9) &#125;</span><br></pre></td></tr></table></figure><p>我们在这个包声明了两种类型：Celsius和Fahrenheit分别对应不同的温度单位。它们虽然有着相同的底层类型float64，但是它们是不同的数据类型，因此它们不可以被相互比较或混在一个表达式运算。刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致的错误；因此需要一个类似Celsius(t)或Fahrenheit(t)形式的显式转型操作才能将float64转为对应的类型。Celsius(t)和Fahrenheit(t)是类型转换操作，它们并不是函数调用。类型转换不会改变值本身，但是会使它们的语义发生变化。另一方面，CToF和FToC两个函数则是对不同温度单位下的温度进行换算，它们会返回不同的值。</p><p>对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型（译注：如果T是指针类型，可能会需要用小括弧包装T，比如<code>(*int)(0)</code>）。只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。如果x是可以赋值给T类型的值，那么x必然也可以被转为T类型，但是一般没有这个必要。</p><blockquote><p>例子1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">package</span> main</span><br><span class="line">&gt;<span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">&gt;)</span><br><span class="line">&gt;<span class="keyword">type</span> Celsius <span class="type">float64</span>    <span class="comment">// 摄氏温度</span></span><br><span class="line">&gt;<span class="keyword">type</span> Fahrenheit <span class="type">float64</span> <span class="comment">// 华氏温度</span></span><br><span class="line">&gt;<span class="keyword">const</span> (</span><br><span class="line">   AbsoluteZeroC Celsius = <span class="number">-273.15</span> <span class="comment">// 绝对零度</span></span><br><span class="line">  FreezingC     Celsius = <span class="number">0</span>       <span class="comment">// 结冰点温度</span></span><br><span class="line">   BoilingC      Celsius = <span class="number">100</span>     <span class="comment">// 沸水温度</span></span><br><span class="line">&gt;)</span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   c := Celsius(<span class="number">100</span>)</span><br><span class="line">   f := Fahrenheit(<span class="number">15</span>)</span><br><span class="line">   fmt.Println(c+f)</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>报错： invalid operation: c + f (mismatched types Celsius and Fahrenheit)</p></blockquote><p>在Go语言中，不能直接将不同类型的自定义类型进行相加，即使它们的底层类型是相同的。虽然 <code>Celsius</code> 和 <code>Fahrenheit</code> 都是基于 <code>float64</code> 类型的自定义类型，但它们被视为完全不同的类型。</p><p>这是因为在Go语言中，类型的名称包括了类型本身和其所属的包。在这种情况下，<code>Celsius</code> 和 <code>Fahrenheit</code> 都是包级别的类型，即使它们的底层类型都是 <code>float64</code>，Go语言也不会自动进行类型转换。因此，编译器会报错，提示类型不匹配。</p><p>要实现相加操作，我们需要显式地将它们转换为相同的类型。在之前的修正代码中，我们使用了类型转换将 <code>Celsius</code> 和 <code>Fahrenheit</code> 分别转换为 <code>float64</code> 类型，然后再进行相加。最后，我们再将相加后的结果转换为 <code>Celsius</code> 类型。这样做是因为Go语言强制执行类型安全，不会自动进行不同类型的隐式转换。</p><p>所以，为了在Go语言中相加不同类型的值，我们需要显式地进行类型转换。这样可以确保类型安全，避免意外的类型错误。</p><blockquote><p>例2：该代码能过编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">double</span> Celsius;</span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">double</span> Fahrenheit;</span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   Celsius c = <span class="number">100</span>;</span><br><span class="line">   Fahrenheit f = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, c+f);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li>请注意，C语言并不执行类型检查，所以编译器不会报错，即使相加的类型不同。这可能导致潜在的运行时错误或意外的结果。因此，在C语言中，程序员需要特别小心，并确保进行适当的类型转换以避免错误。</li></ul><blockquote><p>因此正确的形式应为</p></blockquote><p>在C语言中，不同类型的自定义类型不能直接相加，就像Go语言中一样。C语言也要求显式地进行类型转换，以确保类型安全。</p><p>在C语言中，我们可以通过显式类型转换将不同类型的值进行相加。例如，假设我们有两个自定义类型 <code>Celsius</code> 和 <code>Fahrenheit</code>，它们都是基于 <code>double</code> 类型的自定义类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cCopy code</span><br><span class="line">typedef double Celsius;</span><br><span class="line">typedef double Fahrenheit;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Celsius c = 100;</span><br><span class="line">    Fahrenheit f = 15;</span><br><span class="line"></span><br><span class="line">    // 需要显式类型转换</span><br><span class="line">    double sum = (double)c + (double)f;</span><br><span class="line">    printf(&quot;%lf\n&quot;, sum);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个C语言代码中，我们将 <code>Celsius</code> 和 <code>Fahrenheit</code> 都定义为 <code>double</code> 的类型别名。然后，在 <code>main</code> 函数中，我们声明一个 <code>Celsius</code> 类型的变量 <code>c</code> 和一个 <code>Fahrenheit</code> 类型的变量 <code>f</code>。由于它们都是 <code>double</code> 的别名，我们需要在相加前进行显式类型转换。</p><h3 id="包和文件"><a class="markdownIt-Anchor" href="#包和文件"></a> 包和文件</h3><h4 id="包的初始化"><a class="markdownIt-Anchor" href="#包的初始化"></a> 包的初始化</h4><blockquote><p>这个算法？</p></blockquote><p>下面的代码定义了一个PopCount函数，用于返回一个数字中含二进制1bit的个数。它使用init初始化函数来生成辅助表格pc，pc表格用于处理每个8bit宽度的数字含二进制的1bit的bit个数，这样的话在处理64bit宽度的数字时就没有必要循环64次，只需要8次查表就可以了。（这并不是最快的统计1bit数目的算法，但是它可以方便演示init函数的用法，并且演示了如何预生成辅助表格，这是编程中常用的技术）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> popcount</span><br><span class="line"></span><br><span class="line"><span class="comment">// pc[i] is the population count of i.</span></span><br><span class="line"><span class="keyword">var</span> pc [<span class="number">256</span>]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> pc &#123;</span><br><span class="line">        pc[i] = pc[i/<span class="number">2</span>] + <span class="type">byte</span>(i&amp;<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PopCount returns the population count (number of set bits) of x.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PopCount</span><span class="params">(x <span class="type">uint64</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int</span>(pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">0</span>*<span class="number">8</span>))] +</span><br><span class="line">        pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">1</span>*<span class="number">8</span>))] +</span><br><span class="line">        pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">2</span>*<span class="number">8</span>))] +</span><br><span class="line">        pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">3</span>*<span class="number">8</span>))] +</span><br><span class="line">        pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">4</span>*<span class="number">8</span>))] +</span><br><span class="line">        pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">5</span>*<span class="number">8</span>))] +</span><br><span class="line">        pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">6</span>*<span class="number">8</span>))] +</span><br><span class="line">        pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">7</span>*<span class="number">8</span>))])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>译注：对于pc这类需要复杂处理的初始化，可以通过将初始化逻辑包装为一个匿名函数处理，像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pc[i] is the population count of i.</span></span><br><span class="line"><span class="keyword">var</span> pc [<span class="number">256</span>]<span class="type">byte</span> = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (pc [<span class="number">256</span>]<span class="type">byte</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> pc &#123;</span><br><span class="line">        pc[i] = pc[i/<span class="number">2</span>] + <span class="type">byte</span>(i&amp;<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>要注意的是在init函数中，range循环只使用了索引，省略了没有用到的值部分。循环也可以这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> pc &#123;</span><br></pre></td></tr></table></figure><h3 id="作用域"><a class="markdownIt-Anchor" href="#作用域"></a> 作用域</h3><p>作用域：声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。<br />生命周期：一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。</p><blockquote><p>注意：任何在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。</p></blockquote><h3 id="slice"><a class="markdownIt-Anchor" href="#slice"></a> slice</h3><ol><li>如果切片操作超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展了slice，因为新slice的长度会变大：另外，字符串的切片操作和[]byte字节类型切片的切片操作是类似的。都写作x[m:n]，并且都是返回一个原始字节序列的子序列，底层都是共享之前的底层数组，因此这种操作都是常量时间复杂度。x[m:n]切片操作对于字符串则生成一个新字符串，如果x是[]byte的话则生成一个新的[]byte。</li></ol><p>因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名（§2.3.2）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">months := [...]<span class="type">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;January&quot;</span>, <span class="comment">/* ... */</span>, <span class="number">12</span>: <span class="string">&quot;December&quot;</span>&#125;</span><br><span class="line">summer := months[<span class="number">6</span>:<span class="number">9</span>]</span><br><span class="line">fmt.Println(summer) <span class="comment">// [&quot;June&quot; &quot;July&quot; &quot;August&quot;]</span></span><br><span class="line">fmt.Println(summer[:<span class="number">20</span>]) <span class="comment">// panic: out of range</span></span><br><span class="line"></span><br><span class="line">endlessSummer := summer[:<span class="number">5</span>] <span class="comment">// extend a slice (within capacity)</span></span><br><span class="line">fmt.Println(endlessSummer)  <span class="comment">// &quot;[June July August September October]&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>From：ChatGPT：在Go语言中，对切片进行操作时，有两个相关的属性：<code>len()</code>和<code>cap()</code>。</p><ul><li><code>len(s)</code>：返回切片<code>s</code>的当前长度，表示切片中实际存储的元素个数。</li><li><code>cap(s)</code>：返回切片<code>s</code>的容量，表示切片底层数组的大小。</li></ul><ol><li><code>fmt.Println(summer[:20])</code>：在这里，尝试获取<code>summer</code>切片中索引0到19的元素。如果<code>summer</code>切片的长度（<code>len(summer)</code>）小于20，那么这个操作将超出切片的长度范围，会导致运行时错误，触发<code>panic</code>异常。这是因为Go语言在切片操作时会检查索引是否在合法范围内，不允许访问超出切片长度的索引。</li><li><code>endlessSummer := summer[:5]</code>：这里创建了一个新的切片<code>endlessSummer</code>，它是从<code>summer</code>切片的索引0开始，一直到索引4（包括索引4）的一个子切片。这个操作并没有超出<code>summer</code>切片的容量（<code>cap(summer)</code>），因为切片容量表示底层数组的大小，而<code>endlessSummer</code>的长度（<code>len(endlessSummer)</code>）为5，在<code>summer</code>的容量范围内。因此，这个操作是合法的。</li></ol><p>总结：对于切片操作，当索引超出切片的长度（<code>len()</code>）时，会导致<code>panic</code>异常。但是，如果切片操作在切片的容量范围内（<code>cap()</code>），可以有效地扩展切片。这种扩展产生一个新的切片，新切片的长度可以大于原始切片的长度。要注意的是，在扩展切片时，不能超出切片的容量，否则也会触发<code>panic</code>异常。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python切片完全指南(语法篇)</title>
      <link href="/2023/06/20/Python-%E5%88%87%E7%89%87%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97-%E8%AF%AD%E6%B3%95%E7%AF%87/"/>
      <url>/2023/06/20/Python-%E5%88%87%E7%89%87%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97-%E8%AF%AD%E6%B3%95%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载原文链接<a href="https://zhuanlan.zhihu.com/p/79541418#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C">胡小涂</a></p></blockquote><h2 id="什么是切片操作"><a class="markdownIt-Anchor" href="#什么是切片操作"></a> 什么是切片操作</h2><p>在Python中,<strong>切片(slice)</strong> 是对序列型对象(如list, string, tuple)的一种高级索引方法。普通索引只取出序列中 <strong>一个下标</strong>对应的元素，而切片取出序列中<strong>一个范围</strong>对应的元素，这里的范围不是狭义上的连续片段。下面的代码初步展示了切片索引的力量。</p><pre class="highlight"><code class="python"> &gt;&gt;&gt; a = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>)) &gt;&gt;&gt; a [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] &gt;&gt;&gt; a[:<span class="number">5</span>] [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] &gt;&gt;&gt; a[<span class="number">5</span>:] [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] &gt;&gt;&gt; a[<span class="number">2</span>:<span class="number">8</span>] [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] &gt;&gt;&gt; a[::<span class="number">2</span>] [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>] &gt;&gt;&gt; a[::-<span class="number">1</span>] [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex快速入门</title>
      <link href="/2023/04/22/Latex%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2023/04/22/Latex%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="latex-文档类documentclass"><a class="markdownIt-Anchor" href="#latex-文档类documentclass"></a> LaTeX 文档类（\documentclass)</h2><p><a href="https://blog.csdn.net/qq_37556330/article/details/106179833">相关链接</a></p><blockquote><p>\part</p><blockquote><p>\chapter</p><blockquote><p>\section<br />\subsection</p><blockquote><p>\subsubsection</p></blockquote></blockquote></blockquote></blockquote><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\part</span>&#123;排版&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">\chapter</span>&#123;第一章 LATEX chapters and sections&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">\section</span>&#123;这是第一个章节&#125;</span><br><span class="line">可以添加章节内容。  </span><br><span class="line"></span><br><span class="line"><span class="keyword">\subsection</span>&#123;这是一个子章节&#125;</span><br><span class="line">子章节内容  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">\section</span>&#123;这是第二个章节&#125;</span><br><span class="line">第二个章节的内容。</span><br><span class="line"><span class="keyword">\subsubsection</span>&#123;这是一个三级章节&#125;</span><br><span class="line">第三个章节的内容。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构前备知识</title>
      <link href="/2023/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%89%8D%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%89%8D%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h1><h2 id="c指针与地址基础认知"><a class="markdownIt-Anchor" href="#c指针与地址基础认知"></a> C指针与地址(基础认知)</h2><blockquote><p>在C语言的学习过程中，常理不清指针（即一个变量的地址）和指针变量（专门用来存放另一变量的地址(指针)的变量）的关系，因此通过程序打印地址运行结果，来分析加强理解。老师在教授过程当中常将两个概念混在一起说，很多人听不明白，某个小学生多要理解几遍这段话。</p></blockquote><h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><h4 id="一-代码示例"><a class="markdownIt-Anchor" href="#一-代码示例"></a> 一、代码示例</h4><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">88</span>,b=<span class="number">60</span> ;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p=&amp;a;<span class="comment">//指向a的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#p&quot;</span>,p);<span class="comment">//以十六进制的形式输出</span></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot; %p &quot;</span>,*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %p\n&quot;</span>,&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot; %d &quot;</span>,*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %d\n&quot;</span>,&amp;p);</span><br><span class="line">    p--;<span class="comment">//指针移动指向b的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#p&quot;</span>,p);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot; %p &quot;</span>,*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %p\n&quot;</span>,&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot; %d &quot;</span>,*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %d\n&quot;</span>,&amp;p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2运行结果"><a class="markdownIt-Anchor" href="#2运行结果"></a> 2.运行结果</h4><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000000000061F</span>E1C</span><br><span class="line"><span class="number">0X000000000061FE1C</span> <span class="number">0000000000000058</span>  <span class="number">000000000061F</span>E10</span><br><span class="line"><span class="number">6422044</span> <span class="number">88</span>  <span class="number">6422032</span></span><br><span class="line"><span class="number">000000000061F</span>E18</span><br><span class="line"><span class="number">0X000000000061FE18</span> <span class="number">000000000000003</span>C  <span class="number">000000000061F</span>E10</span><br><span class="line"><span class="number">6422040</span> <span class="number">60</span>  <span class="number">6422032</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>在指针*p=&amp;a初始化后，p等同于&amp;a即a的地址，在运行过程中可以代换。%#p是输出位0X开开头的16进制数。因此printf(“%p\n”,&amp;a);    printf(“%#p”,p);本质是一样的。*p则是通过指针变量p存储的a的地址，间接获取a的值。*p=a,对数值%p等同于对数值以十六进制位输出。%d对p,*p,&amp;p则是以十进制形式分别输出地址，值，地址。</p><p>p–，由于p是整型指针，p–减去int的4个字节刚好移动到b。</p><blockquote><p>【注】1.这里发现后定义的变量b的地址要小于a的地址，这是因为c语言中，先定义的数据先入栈，在栈的底部（不分配内存），声明结束后，b在栈顶，所以b先出栈，先为b分配内存。因此b的地址小于a的地址。<br />   2.数据的地址位数和数据能存储的位数无关。学习阶段曾存在疑问（输出的地址是16位，int是4字节，即16进制的4位代表一个字节（实际应该是一个字节等于2位16进制），一个字节等于八位二进制，但八位二进制不等于四位16进制？）通过交流请教得知有关计算机组成原理，地址位数只取决于系统，所有类型的指针所占长度相同。</p></blockquote><h2 id="指针知识框架详解"><a class="markdownIt-Anchor" href="#指针知识框架详解"></a> 指针知识框架（详解）</h2><p><a href="https://www.dreamchasing.top/2023/01/29/%E6%8C%87%E9%92%88%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%EF%BC%88%E8%AF%A6%E8%A7%A3%EF%BC%89/">具体内容请单击此链接，某个小学生可以待会再看，上面看完直接看结构体</a></p><h1 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h1><h2 id="如何声明一个结构体类型"><a class="markdownIt-Anchor" href="#如何声明一个结构体类型"></a> 如何声明一个结构体类型？</h2><p>例子：形如下列代码的形式为结构体模板（struct template），仅是构造一个数据类型，如同构造int类型代表了什么样的数据类型，但未定义结构体变量，编译器不会为此分配内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> ID;</span><br><span class="line">    <span class="type">char</span> Name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>  score[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何定义一个结构体变量"><a class="markdownIt-Anchor" href="#如何定义一个结构体变量"></a> 如何定义一个结构体变量？</h2><h3 id="1先定义结构体类型再定义结构体变量名"><a class="markdownIt-Anchor" href="#1先定义结构体类型再定义结构体变量名"></a> 1.先定义结构体类型再定义结构体变量名</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> ID;</span><br><span class="line">    <span class="type">char</span> Name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>  score[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu1</span>;</span> <span class="comment">//合法的√</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu1</span>;</span> <span class="comment">//非法的×</span></span><br><span class="line">student stu1; <span class="comment">//非法的×</span></span><br></pre></td></tr></table></figure><h3 id="2在定义结构体类型的同时定义变量"><a class="markdownIt-Anchor" href="#2在定义结构体类型的同时定义变量"></a> 2.在定义结构体类型的同时定义变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> ID;</span><br><span class="line">    <span class="type">char</span> Name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>  score[<span class="number">4</span>];</span><br><span class="line">&#125;stu1;</span><br></pre></td></tr></table></figure><h3 id="3直接定义结构体变量不指定结构体标签"><a class="markdownIt-Anchor" href="#3直接定义结构体变量不指定结构体标签"></a> 3.直接定义结构体变量（不指定结构体标签）</h3><p>不写struct （结构体标签）的标签，相当于没有给该结构体类型起名字，不推荐使用，会导致不一致和重复的问题，不能用于声明函数的形参。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> ID;</span><br><span class="line">    <span class="type">char</span> Name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>  score[<span class="number">4</span>];</span><br><span class="line">&#125;stu1;</span><br></pre></td></tr></table></figure><h2 id="为结构体类型定义名字"><a class="markdownIt-Anchor" href="#为结构体类型定义名字"></a> 为结构体类型定义名字</h2><h3 id="1用结构体标签来标识结构体类型"><a class="markdownIt-Anchor" href="#1用结构体标签来标识结构体类型"></a> 1.用结构体标签来标识结构体类型</h3><p>struct （结构体标签）</p><h3 id="2用typedef给数据类型定义一个别名"><a class="markdownIt-Anchor" href="#2用typedef给数据类型定义一个别名"></a> 2.用typedef给数据类型定义一个别名</h3><p>typedef即使某个词何某个词为同义词<br />如下面示例中<code>STUDENT</code> 与 <code>struct student</code>是同义词</p><h4 id="类型1"><a class="markdownIt-Anchor" href="#类型1"></a> 类型1</h4><p>使用typedef为已存在的类型定义一个别名，并未声明新的类型。这种定义方法结构体标签不可以省略。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> ID;</span><br><span class="line">    <span class="type">char</span> Name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>  score[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">STUDENT</span>;</span></span><br></pre></td></tr></table></figure><p>使用typedef成为同义词后，可以直接用<code>STUDENT stu1</code>定义结构体变量</p><h4 id="类型2"><a class="markdownIt-Anchor" href="#类型2"></a> 类型2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> ID;</span><br><span class="line">    <span class="type">char</span> Name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>  score[<span class="number">4</span>];</span><br><span class="line">&#125;STUDENT; </span><br></pre></td></tr></table></figure><h4 id="类型3"><a class="markdownIt-Anchor" href="#类型3"></a> 类型3</h4><p>结构体标签可以省略</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> ID;</span><br><span class="line">    <span class="type">char</span> Name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>  score[<span class="number">4</span>];</span><br><span class="line">&#125;STUDENT; </span><br></pre></td></tr></table></figure><hr /><p>分割线</p><hr /><h2 id="typedef与链表的联系"><a class="markdownIt-Anchor" href="#typedef与链表的联系"></a> typedef与链表的联系</h2><p>typedef的作用是为已有的数据类型定义一个新名字，其主要目的是为了我们在使用时能用这个更加清晰简单的新名字，还有一个目的就是为了简化变量的声明。</p><h3 id="样式1"><a class="markdownIt-Anchor" href="#样式1"></a> 样式1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> data;  <span class="comment">// 节点的数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span>  <span class="comment">// 节点的指针域 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">n</span>;</span>  <span class="comment">// 定义一个单个节点</span></span><br></pre></td></tr></table></figure><h3 id="样式2"><a class="markdownIt-Anchor" href="#样式2"></a> 样式2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> data;  <span class="comment">// 节点的数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span>  <span class="comment">// 节点的指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">NODE</span>;</span>  <span class="comment">// 把struct node型的结构体用别名NODE表示</span></span><br><span class="line">NODE n;  <span class="comment">// 定义一个单个节点</span></span><br></pre></td></tr></table></figure><h3 id="样式3"><a class="markdownIt-Anchor" href="#样式3"></a> 样式3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> data;  <span class="comment">// 节点的数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span>  <span class="comment">// 节点的指针域</span></span><br><span class="line">&#125;NODE;</span><br><span class="line">NODE n;  <span class="comment">// 定义一个单个节点</span></span><br></pre></td></tr></table></figure><hr /><p>分割线</p><hr /><h2 id="单链表的实际运用"><a class="markdownIt-Anchor" href="#单链表的实际运用"></a> 单链表的实际运用</h2><h3 id="单链表结构定义"><a class="markdownIt-Anchor" href="#单链表结构定义"></a> 单链表结构定义</h3><p>参考文章编写<a href="https://blog.csdn.net/weixin_44162361/article/details/115665501">结构体中的LNode与*LinkList</a>编写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> DateType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="comment">//链表节点的结构定义</span></span><br><span class="line">    DateType date;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StuNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">&#125;LinkNode,*LinkList;<span class="comment">//单链表的结构定义</span></span><br></pre></td></tr></table></figure><p>初学时往往不理解LinkNode,<em>LinkList的意义。<br />对于这个结构体来说，LinkNode和</em>LinkList其实都是结构体struct node的别名，只不过类型不同。</p><ul><li>LinkNode是一个普通的结构体名，相当于将结构体类型<code>struct node</code> 重命名为<code>LinkNode</code>;</li><li>*LinkList是一个指针类型，相当于将<code>struct node * </code>重命名为<code>LinkList</code>。</li></ul><p>本质上<code>LinkNode</code>和<code>LinkList</code>都只是为了简化代码省略<code>struct node</code>部分，它们仍然是用来表示数据类型的别名。<br />实际使用中运用这些别名来定义变量，如<code>LinkList L</code>; 等价于<code>struct node *L</code>;</p><h3 id="linklist-l-与linklist-llnode-l-lnode-l"><a class="markdownIt-Anchor" href="#linklist-l-与linklist-llnode-l-lnode-l"></a> LinkList L 与LinkList &amp;L（LNode* L ， LNode* &amp;L）</h3><p>参考<a href="https://www.zhihu.com/question/66781500/answer/2230081680">陆加壹</a>编写</p><h4 id="linklist-l"><a class="markdownIt-Anchor" href="#linklist-l"></a> LinkList L</h4><p>1.当函数参数为LinkList L时，意味着只改变或操作List的内容，而不需要改变L这个指针<br />如查找操作<code>Status GetElem(LinkList L,int i,ElemType)</code></p><h4 id="linklist-l-2"><a class="markdownIt-Anchor" href="#linklist-l-2"></a> LinkList &amp;L</h4><p>2.当参数为LinkList &amp;L时，意味着需要改变或操作L这个指针本身<br />如初始化操作(初始化单链表，需要给L分配内存空间，即需要改变L)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">    L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&amp;其实是C++的知识，其在此处的作用是使函数运行后可以改变实参。<br />&amp;详解请见<a href="https://www.runoob.com/cplusplus/cpp-references.html">c++引用|菜鸟教程</a></p><h4 id="linklist-l-3"><a class="markdownIt-Anchor" href="#linklist-l-3"></a> LinkList *L</h4><p>当参数为LinkList <em>L时，意味着需要改变或操作L这个指针指向的LinkList类型的指针(此处的L可以理解为指向前两点中的L的指针)<br />此时给头结点分配储存空间时要这样写<code>(*L)=(LinkList)malloc(sizeof(struct LNode));</code><br />L前面要加</em>,表示L所指向的那个指针<br />该情况属于二级指针即指向指针的指针<br />参考<a href="https://zhuanlan.zhihu.com/p/410715721">星辰</a>编写</p><h1 id="mark某个小学生能不能看到这知识点看完找个实际例子对照着理解下mark"><a class="markdownIt-Anchor" href="#mark某个小学生能不能看到这知识点看完找个实际例子对照着理解下mark"></a> <mark>某个小学生能不能看到这？知识点看完，找个实际例子对照着理解下</mark></h1>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 结构体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷深入浅出基础篇整理</title>
      <link href="/2023/03/12/%E6%B4%9B%E8%B0%B7%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/2023/03/12/%E6%B4%9B%E8%B0%B7%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>原题链接 <a href="https://www.luogu.com.cn/problem/P1957">P1957 口算练习题</a></p><h2 id="6字符串与文件操作"><a class="markdownIt-Anchor" href="#6字符串与文件操作"></a> 6.字符串与文件操作</h2><h3 id="字符数组"><a class="markdownIt-Anchor" href="#字符数组"></a> 字符数组</h3><h4 id="例6-4口算练习题"><a class="markdownIt-Anchor" href="#例6-4口算练习题"></a> 例6-4：口算练习题</h4><blockquote><p>题目描述<br />王老师正在教简单算术运算。细心的王老师收集了i道学生经常做错的口算题，并且想整理编写成一份练习。 编排这些题目是一件繁琐的事情，为此他想用计算机程序来提高工作效率。王老师希望尽量减少输入的工作量，比如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">5+8</mtext></mrow><annotation encoding="application/x-tex">\texttt{5+8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61111em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">5+8</span></span></span></span></span> 的算式最好只要输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">5</mtext></mrow><annotation encoding="application/x-tex">\texttt 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61111em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">5</span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">8</mtext></mrow><annotation encoding="application/x-tex">\texttt 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61111em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">8</span></span></span></span></span>，输出的结果要尽量详细以方便后期排版的使用，比如对于上述输入进行处理后输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">5+8=13</mtext></mrow><annotation encoding="application/x-tex">\texttt{5+8=13}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61111em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">5+8=13</span></span></span></span></span> 以及该算式的总长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>。王老师把这个光荣的任务交给你，请你帮他编程实现以上功能。<br />输入格式<br />第一行为数值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span><br />接着的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 行为需要输入的算式，每行可能有三个数据或两个数据。<br />若该行为三个数据则第一个数据表示运算类型，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">a</mtext></mrow><annotation encoding="application/x-tex">\texttt a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">a</span></span></span></span></span> 表示加法运算，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">b</mtext></mrow><annotation encoding="application/x-tex">\texttt b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61111em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">b</span></span></span></span></span> 表示减法运算，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">c</mtext></mrow><annotation encoding="application/x-tex">\texttt c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">c</span></span></span></span></span> 表示乘法运算，接着的两个数据表示参加运算的运算数。<br />若该行为两个数据，则表示本题的运算类型与上一题的运算类型相同，而这两个数据为运算数。<br />输出格式<br />输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">2\times i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 行。对于每个输入的算式，输出完整的运算式及结果，第二行输出该运算式的总长度<br />样例 #1<br />样例输入 #1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">a 64 46</span><br><span class="line">275 125</span><br><span class="line">c 11 99</span><br><span class="line">b 46 64</span><br></pre></td></tr></table></figure><p>样例输出 #1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">64+46=110</span><br><span class="line">9</span><br><span class="line">275+125=400</span><br><span class="line">11</span><br><span class="line">11*99=1089</span><br><span class="line">10</span><br><span class="line">46-64=-18</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p>提示<br />数据规模与约定<br />对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>50</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">50\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，输入的算式都有三个数据，第一个算式一定有三个数据。<br />对于所有数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>i</mi><mo>≤</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">0&lt;i\leq 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span>，运算数为非负整数且小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10000</mn></mrow><annotation encoding="application/x-tex">10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。</p><h5 id="官方题解有误"><a class="markdownIt-Anchor" href="#官方题解有误"></a> 官方题解：(有误)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n, a, b, c;</span><br><span class="line">  <span class="type">char</span> last, s[<span class="number">20</span>], ans[<span class="number">20</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">while</span> (n--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fgets</span>(s, <span class="built_in">sizeof</span>(s), stdin); <span class="comment">// 读入一行</span></span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;a&#x27;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;b&#x27;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">      last = s[<span class="number">0</span>];</span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&#x27; &#x27;</span>;                 <span class="comment">// 获取计算符号，并替换为空格</span></span><br><span class="line">    <span class="built_in">sscanf</span>(s, <span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b); <span class="comment">// 从这个字符串里面读出两个数a和b</span></span><br><span class="line">    <span class="keyword">switch</span> (last)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">      c = a + b;</span><br><span class="line">      <span class="built_in">sprintf</span>(ans,<span class="string">&quot;%d+%d=%d&quot;</span>, a, b, c);</span><br><span class="line">      <span class="keyword">break</span>; <span class="comment">//+</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">      c = a - b;</span><br><span class="line">      <span class="built_in">sprintf</span>(ans,<span class="string">&quot;%d-%d=%d&quot;</span>, a, b, c);</span><br><span class="line">      <span class="keyword">break</span>; <span class="comment">//-</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">      c = a * b;</span><br><span class="line">      <span class="built_in">sprintf</span>(ans,<span class="string">&quot;%d*%d=%d&quot;</span>, a, b, c);</span><br><span class="line">      <span class="keyword">break</span>; <span class="comment">//+</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n%d\n&quot;</span>, ans, <span class="built_in">strlen</span>(ans)); <span class="comment">// 输出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通过代码"><a class="markdownIt-Anchor" href="#通过代码"></a> 通过代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;data.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">char</span> a[<span class="number">10</span>], ans[<span class="number">100</span>];</span><br><span class="line">  <span class="type">char</span> temp;</span><br><span class="line">  <span class="type">int</span> n, x, y;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">while</span> (n--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; a[<span class="number">0</span>] &lt;= <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      temp = a[<span class="number">0</span>];</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      x = <span class="built_in">atoi</span>(a);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="built_in">sizeof</span>(ans));<span class="comment">//清空原有的字符串，防止长度判断错误</span></span><br><span class="line">    <span class="keyword">switch</span> (temp)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">      <span class="built_in">sprintf</span>(ans, <span class="string">&quot;%d+%d=%d&quot;</span>, x, y, x + y);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">      <span class="built_in">sprintf</span>(ans, <span class="string">&quot;%d-%d=%d&quot;</span>, x, y, x - y);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">      <span class="built_in">sprintf</span>(ans, <span class="string">&quot;%d*%d=%d&quot;</span>, x, y, x * y);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n%d\n&quot;</span>, ans, <span class="built_in">strlen</span>(ans));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新知识"><a class="markdownIt-Anchor" href="#新知识"></a> 新知识</h4><ul><li>scanf遇到空格换行停止读入</li><li>sscanf(s,“%d”,&amp;a);就可以从字符串s中读入一个整数a。</li><li>sprintf将数据输入到字符串，sprintf(ans, “%d*%d=%d”, x, y, x * y);就是以%d*%d=%d的格式输入到字符串ans中ans存储x*y=xy。</li><li>atoi ((表示 ascii to integer)是把字符串转换成整型数的一个函数)头文件为#include&lt;stdlib.h&gt;</li></ul><h3 id="string类型字符串stl"><a class="markdownIt-Anchor" href="#string类型字符串stl"></a> string类型字符串(STL)</h3><h4 id="例6文字处理软件"><a class="markdownIt-Anchor" href="#例6文字处理软件"></a> [例6]文字处理软件</h4><blockquote><p>题目描述<br />你需要开发一款文字处理软件。最开始时输入一个字符串作为初始文档。可以认为文档开头是第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 个字符。需要支持以下操作：</p></blockquote><ul><li><code>1 str</code>：后接插入，在文档后面插入字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">str</mtext></mrow><annotation encoding="application/x-tex">\texttt{str}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55358em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">str</span></span></span></span></span>，并输出文档的字符串。</li><li><code>2 a b</code>：截取文档部分，只保留文档中从第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 个字符起 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> 个字符，并输出文档的字符串。</li><li><code>3 a str</code>：插入片段，在文档中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 个字符前面插入字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">str</mtext></mrow><annotation encoding="application/x-tex">\texttt{str}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55358em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">str</span></span></span></span></span>，并输出文档的字符串。</li><li><code>4 str</code>：查找子串，查找字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">str</mtext></mrow><annotation encoding="application/x-tex">\texttt{str}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55358em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">str</span></span></span></span></span> 在文档中最先的位置并输出；如果找不到输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。<br />为了简化问题，规定初始的文档和每次操作中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">str</mtext></mrow><annotation encoding="application/x-tex">\texttt{str}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55358em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">str</span></span></span></span></span> 都不含有空格或换行。最多会有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 次操作。<br />输入格式<br />第一行输入一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>，表示操作次数。<br />第二行输入一个字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">str</mtext></mrow><annotation encoding="application/x-tex">\texttt{str}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55358em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">str</span></span></span></span></span>，表示最开始的字符串。<br />第三行开始，往下 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 行，每行表示一个操作，操作如题目描述所。<br />输出格式<br />一共输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 行。<br />对于每个操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">1,2,3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span></span></span></span>，根据操作的要求输出一个字符串。<br />对于操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>，根据操作的要求输出一个整数。<br />样例 #1<br />样例输入 #1</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">ILove</span><br><span class="line">1 Luogu</span><br><span class="line">2 5 5</span><br><span class="line">3 3 guGugu</span><br><span class="line">4 gu</span><br></pre></td></tr></table></figure><p>样例输出 #1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ILoveLuogu</span><br><span class="line">Luogu</span><br><span class="line">LuoguGugugu</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>提示<br />数据保证，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>q</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">1 \leq q\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，开始的字符串长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\leq 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。</p><h5 id="ac代码官方"><a class="markdownIt-Anchor" href="#ac代码官方"></a> AC代码（官方）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  string s, a;</span><br><span class="line">  <span class="type">int</span> opt, q, begin, end;</span><br><span class="line">  cin &gt;&gt; q;</span><br><span class="line">  cin &gt;&gt; s;</span><br><span class="line">  <span class="keyword">while</span> (q--)</span><br><span class="line">  &#123;</span><br><span class="line">    cin &gt;&gt; opt;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      cin &gt;&gt; a;</span><br><span class="line">      s.<span class="built_in">append</span>(a);</span><br><span class="line">      cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      cin &gt;&gt; begin &gt;&gt; end;</span><br><span class="line">      s = s.<span class="built_in">substr</span>(begin, end);</span><br><span class="line">      cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      cin &gt;&gt; begin &gt;&gt; a;</span><br><span class="line">      s = s.<span class="built_in">insert</span>(begin, a);</span><br><span class="line">      cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      cin &gt;&gt; a;</span><br><span class="line">      cout &lt;&lt; (<span class="type">int</span>)s.<span class="built_in">find</span>(a) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="string类型"><a class="markdownIt-Anchor" href="#string类型"></a> string类型</h5><p>1.引入头文件 <code>#include &lt;string&gt;</code><br />2.初始化<code>string s</code><br />注：string与字符数组相类似，从存储从0,1,2,3…开始。<br />区别string可以直接复制常量也可以相互赋值，字符数组不能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string a,b;</span><br><span class="line">a=<span class="string">&quot;LUOGU&quot;</span></span><br><span class="line">b=a;</span><br><span class="line"><span class="comment">//但是如果是字符数组</span></span><br><span class="line"><span class="type">char</span> a=<span class="string">&quot;abc&quot;</span>是错误的。因为字符数组名a，本质上是一个地址，不可以用来直接复制和相互赋值。</span><br></pre></td></tr></table></figure><p>3.常用操作</p><ul><li>s+=str或s.append(str):在字符串s后拼接字符串str。</li><li>s &lt; str：比较字符串s的字典序是否在字符串str之前</li><li>s.size()或s.length()：得到字符串s的长度</li><li>s.substr(pos,len)以字符串数组来理解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string a=<span class="string">&quot;acwing&quot;</span></span><br><span class="line">cout &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">3</span>) &lt;&lt; endl; <span class="comment">//acw,当第一个数是0 则后一位数:输出从头开始的长度为3的子串</span></span><br><span class="line">cout &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl; <span class="comment">//cwi,当第一个数是1 则输出下标为1 到下标为3的子串  </span></span><br><span class="line">cout &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">9</span>) &lt;&lt; endl;<span class="comment">//acwing如果超出长度范围 则输出原子串</span></span><br><span class="line">cout &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">1</span>) &lt;&lt; endl; <span class="comment">//cwing,从下标为1开始输出</span></span><br><span class="line">cout &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">0</span>) &lt;&lt; endl; <span class="comment">//acwing原子串</span></span><br></pre></td></tr></table></figure><ul><li>s.insert</li></ul><blockquote><p>str1（被插入字符串）.insert(pos(插入位置),str2（被插入字符串），n ，m)<br />ps：n，m分别是插入字符串要截取的（真正要插入的部分）即在str2.n位置数m个，不写这个的话就是将str2整个全部插入。<br />如题中代码s.insert(1,a)省略n,m将字符串a全部插入<br />【注】在输入的位置之前插入，如0，在开头插入，1插在第二个位置，<mark>下方代码有存疑还未解决</mark></p></blockquote> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">string a;<span class="comment">//区别：string a=&quot; &quot;;char a=&#x27;&#x27;;</span></span><br><span class="line"><span class="comment">// 尾插一个字符</span></span><br><span class="line">  a.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  cout&lt;&lt;a&lt;&lt;endl;<span class="comment">//输出a；</span></span><br><span class="line"><span class="comment">// insert(pos,char):在制定的位置pos前插入字符char</span></span><br><span class="line">  a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(),<span class="string">&#x27;1&#x27;</span>); <span class="comment">//输出 1a</span></span><br><span class="line"><span class="comment">/*【注】此处存疑a.insert(a.begin(),&#x27;1&#x27;);可以后面只能是一个字节的char类型，字符串和string类型；前面也不能把a.begin()改成数字0等表示插入位置。*/</span></span><br><span class="line"><span class="comment">//插入字符串</span></span><br><span class="line">  string str2=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  string s2=<span class="string">&quot;weakhaha&quot;</span>;</span><br><span class="line">  str2.<span class="built_in">insert</span>(<span class="number">0</span>,s2,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">   cout&lt;&lt;str2&lt;&lt;endl;<span class="comment">//eakhello,将字符串s2从下标为1的e开始数3个字符，分别是eak，插入原串的下标为0的字符h前   </span></span><br><span class="line"><span class="comment">/*-------------------------------------*/</span>    </span><br><span class="line">string str2=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  string s2=<span class="string">&quot;weakhaha&quot;</span>;</span><br><span class="line">  str2.<span class="built_in">insert</span>(<span class="number">1</span>,s2,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">   cout&lt;&lt;str2&lt;&lt;endl;<span class="comment">//heakello将字符串s2从下标为1的e开始数3个字符，分别是eak，插入原串的下标为1的字符e前   </span></span><br></pre></td></tr></table></figure><ul><li>s.find(str,[pos]):在字符串第pos个字符开始寻找str，并返回位置，如果找不到返回-1.pos可以省略，默认值是0。<br />【注】使用find函数查找子串但是找不到时，它会返回一个常数string::npos，但是由于它不一定是一个int类型的常量，所以需要将其强制转换为int才能直接输出-1<mark>（读者可以试一下直接使用cout输出，这个数字会是什么）</mark></li></ul><p>此处内容参考<br /><a href="https://blog.csdn.net/weixin_49486457/article/details/123439229?spm=1001.2014.3001.5502">【C++】算法竞赛常用STL万字总结</a><br /><a href="https://blog.csdn.net/weixin_63003502/article/details/122562640?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=c++insert&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-122562640.142%5Ev73%5Einsert_down2,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;spm=1018.2226.3001.4187">指定位置插入字符串（c++insert函数、find函数使用）</a><br /><a href="https://blog.csdn.net/qq_51271013/article/details/116170964?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167860392816800186584851%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167860392816800186584851&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-116170964-null-null.142%5Ev73%5Einsert_down2,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=c%2B%2Bfind&amp;spm=1018.2226.3001.4187">C++中的find函数用法</a></p><h2 id="第9章排序"><a class="markdownIt-Anchor" href="#第9章排序"></a> 第9章排序</h2><h3 id="经典排序方法"><a class="markdownIt-Anchor" href="#经典排序方法"></a> 经典排序方法</h3><h4 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h4><h4 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h4><p>P1923 【深基9.例4】求第 k 小的数 ,<mark>快排优化还没想明白</mark></p><h4 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h4><h4 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h4><h4 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h4><h4 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h4><h4 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h4><h4 id="基数排序"><a class="markdownIt-Anchor" href="#基数排序"></a> 基数排序</h4><h4 id="桶排序"><a class="markdownIt-Anchor" href="#桶排序"></a> 桶排序</h4><h3 id="stl"><a class="markdownIt-Anchor" href="#stl"></a> STL</h3><h4 id="sort函数"><a class="markdownIt-Anchor" href="#sort函数"></a> sort函数</h4><h5 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h5><blockquote><p>需要引入头文件#include&lt; algorithm &gt;</p></blockquote><p>sort()函数是类似于快速排序的方法，时间复杂度为n*log2(n)，执行效率较高。并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。所以说sort()是一个比较灵活的函数，它也会根据我们数据的需要进行排序，所以我们就不用担心以上的问题了。对于大部分的排序需求，sort()都是可以满足的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(begin, end, cmp);</span><br></pre></td></tr></table></figure><p>其中begin为指向待sort()的数组的第一个元素的指针，end为指向待sort()的数组的最后一个元素的下一个位置的指针，cmp参数为排序准则，cmp参数可以不写，如果不写的话，默认从小到大进行排序。<br />如果我们想从大到小排序可以将cmp参数写为  <code>greater&lt;int&gt;()</code>  就是对int数组进行排序，例如  <code>sort(a,a+n,greater&lt;int&gt;());</code></p><p>当然&lt;&gt;中我们也可以写<mark>double、long、float</mark>等等。</p><h5 id="自定义排序标准"><a class="markdownIt-Anchor" href="#自定义排序标准"></a> 自定义排序标准</h5><p>也可以以自定义排序准则的形式来写cmp函数如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><blockquote><p>可能你有点懵，不知道这是什么原理，为什么要这么写。<br />我认为cmp函数的一个特性就是，a是前面的元素， b是后面的元素，如果return 0, 那么sort就会将他们互换位置, return 1就会保持原来位置不变。<br />所以这函数可以解读为：<br />如果前面的元素比后面的元素大，就保持不变<br />如果前面的元素比后面的元素小，就交换他们的位置<br />简单来说就是把大的元素放在前面<br />我直接把这个cmp背下来不好吗？<br />cmp在结构体排序里也要用到，你背下来写那种二级排序的题也不会<br />在return里面  a放前面，b放前面，大于号，小于号，有好几种情况<br />理解起来有点绕怎么办？<br />我教你一种好理解的方法。<br />你永远把a放在前面，b放在后面。想把大的放在前面，就写大于号，想把小的放在前面，就写小于号（大口朝前大在前，小口朝前小在前）<br />这样就省去了分析的时间，还不容易出错。—— <a href="https://blog.csdn.net/suanrongye/article/details/121271088">c++应用sort函数时的cmp函数怎么写</a></p></blockquote><p>如果我们需要按照其他的排序准则，那么就需要我们自己定义一个bool类型的函数来传入。比如说我们按照每个数的个位进行从大到小排序，我们就可以根据自己的需求来写一个函数作为排序的准则传入到sort()中。<br />我们可以将这个函数定义为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x % <span class="number">10</span> &gt; y % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们将这个cmp函数作为参数传入sort()中即可实现了上述排序需求。<br />完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x % <span class="number">10</span> &gt; y % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>] = &#123;<span class="number">65</span>,<span class="number">59</span>,<span class="number">96</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">80</span>,<span class="number">72</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">99</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(num,num+<span class="number">10</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">cout&lt;&lt;num[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;<span class="comment">//输出结果：59 99 96 65 44 13 33 72 21 80</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对结构体进行排序"><a class="markdownIt-Anchor" href="#对结构体进行排序"></a> 对结构体进行排序</h5><p><a href="https://blog.csdn.net/qq_41575507/article/details/105936466?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167930091016800217273553%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167930091016800217273553&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105936466-null-null.142%5Ev74%5Einsert_down2,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=sort&amp;spm=1018.2226.3001.4187">C++ sort()排序详解</a><br />例题9-6</p><blockquote><p>[NOIP2007 普及组] 奖学金<br />题目描述<br />某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 名学生发奖学金。期末，每个学生都有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 门课的成绩:语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学 排在前面，这样，每个学生的排序是唯一确定的。<br />任务：先根据输入的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名名学生的学号和总分。注意，在前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据(每行输出两个数:学号、总分) 是:<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>279</mn></mrow><annotation encoding="application/x-tex">279</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mord">9</span></span></span></span><br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>279</mn></mrow><annotation encoding="application/x-tex">279</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mord">9</span></span></span></span><br />这两行数据的含义是:总分最高的两个同学的学号依次是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span> 号、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 号。这两名同学的总分都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>279</mn></mrow><annotation encoding="application/x-tex">279</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mord">9</span></span></span></span> (总分等于输入的语文、数学、英语三科成绩之和) ，但学号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span> 的学生语文成绩更高一些。如果你的前两名的输出数据是:<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>279</mn></mrow><annotation encoding="application/x-tex">279</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mord">9</span></span></span></span><br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>279</mn></mrow><annotation encoding="application/x-tex">279</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mord">9</span></span></span></span><br />则按输出错误处理，不能得分。<br />输入格式<br />共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>行。<br />第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 行为一个正整数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>300</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n ( \le 300)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，表示该校参加评选的学生人数。<br />第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 行，每行有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 个用空格隔开的数字，每个数字都在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 之间。第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 行的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 个数字依次表示学号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1\sim n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>（恰好是输入数据的行号减 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>）。<br />所给的数据都是正确的，不必检验。<br />输出格式<br />共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 行，每行是两个用空格隔开的正整数，依次表示前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 名学生的学号和总分。<br />样例 #1<br />样例输入 #1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">80 89 89</span><br><span class="line">88 98 78</span><br><span class="line">90 67 80</span><br><span class="line">87 66 91</span><br><span class="line">78 89 91</span><br><span class="line">88 99 77</span><br><span class="line">67 89 64</span><br><span class="line">78 89 98</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">样例输出 #2  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>8 265<br />2 264<br />6 264<br />1 258<br />5 258</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct student</span><br><span class="line">&#123;</span><br><span class="line">  int id;</span><br><span class="line">  int score[3];</span><br><span class="line">  int total;</span><br><span class="line">&#125; STUDENT;</span><br><span class="line">STUDENT a[310];</span><br><span class="line">bool cmp(student x, student y)</span><br><span class="line">&#123;</span><br><span class="line">  if (x.total != y.total)</span><br><span class="line">    return x.total &gt; y.total;</span><br><span class="line">  if (x.score[0] != y.score[0])</span><br><span class="line">    return x.score[0] &gt; y.score[0];</span><br><span class="line">  return x.id &lt; y.id;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  for (int i = 1; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    a[i].id = i;</span><br><span class="line">    cin &gt;&gt; a[i].score[0] &gt;&gt; a[i].score[1] &gt;&gt; a[i].score[2];</span><br><span class="line">    a[i].total = a[i].score[0] + a[i].score[1] + a[i].score[2];</span><br><span class="line">  &#125;</span><br><span class="line">  sort(a + 1, a + n + 1, cmp);</span><br><span class="line">  for (int i = 1; i &lt;= 5; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; a[i].id &lt;&lt; &quot; &quot; &lt;&lt; a[i].total &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">##### 利用字符串进行排序</span><br><span class="line">&gt;P1781宇宙总统</span><br><span class="line">题目描述</span><br><span class="line">地球历公元 6036 年，全宇宙准备竞选一个最贤能的人当总统，共有 $n$ 个非凡拔尖的人竞选总统，现在票数已经统计完毕，请你算出谁能够当上总统。</span><br><span class="line">输入格式</span><br><span class="line">第一行为一个整数 $n$，代表竞选总统的人数。</span><br><span class="line">接下来有 $n$ 行，分别为第一个候选人到第 $n$ 个候选人的票数。</span><br><span class="line">输出格式</span><br><span class="line">共两行，第一行是一个整数 $m$，为当上总统的人的号数。</span><br><span class="line">第二行是当上总统的人的选票。</span><br><span class="line">样例 #1</span><br><span class="line">样例输入 #1</span><br></pre></td></tr></table></figure><p>5<br />98765<br />12365<br />87954<br />1022356<br />985678</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">样例输出 #1  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4<br />1022356</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">提示</span><br><span class="line">票数可能会很大，可能会到 $100$ 位数字。</span><br><span class="line">$1 \leq n \leq 20$  </span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node</span><br><span class="line">&#123; </span><br><span class="line">  int id;//编号</span><br><span class="line">  string num;//票数</span><br><span class="line">&#125; a[25];</span><br><span class="line">bool cmp(node x, node y)</span><br><span class="line">&#123;</span><br><span class="line">  if(x.num.length()!=y.num.length())return x.num.length()&gt;y.num.length();//a比b位数多时a在前面</span><br><span class="line">  return x.num&gt;y.num;//位数相同，但a字典序排列比b大</span><br><span class="line">  //字符串的比较是比较字典序（第一位小的在前面，如果相同比较第二位，以此类推）例如10000小于1200小于200；</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  for (int i = 1; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    a[i].id = i;</span><br><span class="line">    cin &gt;&gt; a[i].num;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(a + 1, a + n + 1, cmp);</span><br><span class="line">    cout &lt;&lt; a[1].id &lt;&lt; endl &lt;&lt; a[1].num ;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="unique函数"><a class="markdownIt-Anchor" href="#unique函数"></a> unique函数</h4><p><a href="https://blog.csdn.net/weixin_44162158/article/details/115575549">unique() 去重函数</a></p><blockquote><p>需要引入头文件#include&lt; algorithm &gt;</p></blockquote><p>unique()函数是一个去重函数，STL中unique的函数 unique的功能是去除相邻的重复元素(只保留一个)<br />它并不真正把重复的元素删除,而是该函数把重复的元素移到后面去了，然后依然保存到了原数组中，然后返回去重后容器中不重复序列的最后一个元素的下一个元素。<br />因为unique去除的是相邻的重复元素，所以一般用之前都会要排一下序。</p><h5 id="例9-5"><a class="markdownIt-Anchor" href="#例9-5"></a> 例9-5</h5><blockquote><p>[NOIP2006 普及组] 明明的随机数<br />题目描述<br />明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1000</mn></mrow><annotation encoding="application/x-tex">1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 之间的随机整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>N</mi><mo>≤</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(N\leq100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。<br />输入格式<br />输入有两行，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 行为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个正整数，表示所生成的随机数的个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>。<br />第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 行有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个用空格隔开的正整数，为所产生的随机数。<br />输出格式<br />输出也是两行，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 行为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，表示不相同的随机数的个数。<br />第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 行为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 个用空格隔开的正整数，为从小到大排好序的不相同的随机数。<br />样例 #1<br />样例输入 #1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">20 40 32 67 40 20 89 300 400 15</span><br></pre></td></tr></table></figure><p>样例输出 #1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">15 20 32 40 67 89 300 400</span><br></pre></td></tr></table></figure><p>AC(运用)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n,cnt;</span><br><span class="line">  cin&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    cin&gt;&gt;a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(a,a+n);</span><br><span class="line">  cnt=<span class="built_in">unique</span>(a,a+n)-a;<span class="comment">//去重后最后一个元素对应的指针减去首地址的差就是去重后的元素个数</span></span><br><span class="line">  cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">    <span class="comment">/*样例输入条件下，如果输出到n，结果为15 20 32 40 67 89 300 400 300 400 可以发现后面为重复的数字仍在数组当中*/</span></span><br><span class="line">    cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">## 第<span class="number">15</span>章线性表</span><br><span class="line">### 数组</span><br><span class="line">#### 例<span class="number">15.1</span></span><br><span class="line">&gt;深基<span class="number">15.</span>例<span class="number">1</span>】询问学号</span><br><span class="line">题目描述</span><br><span class="line">有 $<span class="built_in">n</span>(n \le <span class="number">2</span> \times <span class="number">10</span>^<span class="number">6</span>)$ 名同学陆陆续续进入教室。我们知道每名同学的学号（在 $<span class="number">1</span>$ 到 $<span class="number">10</span>^<span class="number">9</span>$ 之间），按进教室的顺序给出。上课了，老师想知道第 $i$ 个进入教室的同学的学号是什么（最先进入教室的同学 $i=<span class="number">1</span>$），询问次数不超过 $<span class="number">10</span>^<span class="number">5</span>$ 次。</span><br><span class="line">输入格式</span><br><span class="line">第一行 $<span class="number">2</span>$ 个整数 $n$ 和 $m$，表示学生个数和询问次数。</span><br><span class="line">第二行 $n$ 个整数，表示按顺序进入教室的学号。</span><br><span class="line">第三行 $m$ 个整数，表示询问第几个进入教室的同学。</span><br><span class="line">输出格式</span><br><span class="line">输出 $m$ 个整数表示答案，用换行隔开。</span><br><span class="line">样例 #<span class="number">1</span></span><br><span class="line">样例输入 #<span class="number">1</span></span><br></pre></td></tr></table></figure><p>10 3<br />1 9 2 60 8 17 11 4 5 14<br />1 5 9</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">样例输出 #1</span><br></pre></td></tr></table></figure><p>1<br />8<br />5</p><pre class="highlight"><code class="">##### AC代码  ```c++#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123;  vector&lt;int&gt; stu;  int n, m, temp;  cin &gt;&gt; n &gt;&gt; m;  for (int i = 0; i &lt; n; i++)  &#123;    cin &gt;&gt; temp;    stu.push_back(temp);    //cin &gt;&gt; stu[i];这种输入不行  &#125;  for (int i = 0; i &lt; m; i++)  &#123;    cin &gt;&gt; temp;    cout &lt;&lt; stu[temp - 1] &lt;&lt; endl;  &#125;  return 0;&#125;</code></pre><h3 id="vector数组"><a class="markdownIt-Anchor" href="#vector数组"></a> vector数组</h3>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 总结整理 </tag>
            
            <tag> 算法入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>for循环的理解问题</title>
      <link href="/2023/03/05/for%E5%BE%AA%E7%8E%AF%E7%90%86%E8%A7%A3%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/05/for%E5%BE%AA%E7%8E%AF%E7%90%86%E8%A7%A3%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ul><li>笔者在做下题时发现了对于for循环的重大理解错误</li></ul><blockquote><p>[NOIP2013 普及组] 计数问题<br />题目描述<br />试计算在区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 的所有整数中，数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>x</mi><mo>≤</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">0\le x\le9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span>）共出现了多少次？例如，在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>11</mn></mrow><annotation encoding="application/x-tex">11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span></span></span></span> 中，即在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>11</mn></mrow><annotation encoding="application/x-tex">1,2,3,4,5,6,7,8,9,10,11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span></span></span></span> 中，数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 出现了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 次。<br />输入格式<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">n,x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span></span></span></span>，之间用一个空格隔开。<br />输出格式<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个整数，表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 出现的次数。<br />样例输入 #1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 1</span><br></pre></td></tr></table></figure><p>样例输出 #1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>提示<br />对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">1\le n\le 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>x</mi><mo>≤</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">0\le x \le 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span>。</p><h2 id="练习代码为"><a class="markdownIt-Anchor" href="#练习代码为"></a> 练习代码为</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> n,x,sum=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span> (i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(i%<span class="number">10</span>==x)</span><br><span class="line">        sum++;</span><br><span class="line">      i/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;sum;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>程序运行时发现为死循环 ，调试过程中发现通过while循环i=0退出后，i重新被赋值为1，重现上一次循环。通过调试我发现自己在for循环理解出现问题。之前认为for(int i=1;i&lt;=n;i++)固定的是，第一层为i=1,执行循环体后i就是2,现在才发现理解出现了很大的差错。关键在于i++，本题练习过程中i为循环变量，通过while循环改变i为0后，循环体结束下一步i++，i变为1，而不是理想中的2。<br />因此本题应该添加临时变量让替代循环变量。</p><p>##ACcode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> n,x,temp,sum=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    temp=i;</span><br><span class="line">    <span class="keyword">while</span> (temp)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(temp%<span class="number">10</span>==x)</span><br><span class="line">        sum++;</span><br><span class="line">      temp/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;sum;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
            <tag> 反思 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题目反思</title>
      <link href="/2023/03/05/%E9%A2%98%E7%9B%AE%E5%8F%8D%E6%80%9D/"/>
      <url>/2023/03/05/%E9%A2%98%E7%9B%AE%E5%8F%8D%E6%80%9D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[NOIP2015 普及组] 金币<br />题目背景<br />NOIP2015 普及组 T1<br />题目描述<br />国王将金币作为工资，发放给忠诚的骑士。第一天，骑士收到一枚金币；之后两天（第二天和第三天），每天收到两枚金币；之后三天（第四、五、六天），每天收到三枚金币；之后四天（第七、八、九、十天），每天收到四枚金币……；这种工资发放模式会一直这样延续下去：当连续 n 天每天收到 n 枚金币后，骑士会在之后的连续 n+1 天里，每天收到 n+1 枚金币。<br />请计算在前 k 天里，骑士一共获得了多少金币。<br />输入格式<br />一个正整数 k，表示发放金币的天数。<br />输出格式<br />一个正整数，即骑士收到的金币数。<br />样例输入 #1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p>样例输出 #1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure><p>样例输入 #2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000</span><br></pre></td></tr></table></figure><p>样例输出 #2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">29820</span><br></pre></td></tr></table></figure><p>提示<br />【样例 1 说明】<br />骑士第一天收到一枚金币；第二天和第三天，每天收到两枚金币；第四、五、六天，每天收到三枚金币。因此一共收到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>3</mn><mo>=</mo><mn>14</mn></mrow><annotation encoding="application/x-tex">1+2+2+3+3+3=14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">4</span></span></span></span> 枚金币。<br />对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">1\le k\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>。</p><h3 id="ac代码个人"><a class="markdownIt-Anchor" href="#ac代码个人"></a> AC代码(个人)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> k,sum=<span class="number">0</span>;</span><br><span class="line">  cin &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;k&gt;<span class="number">0</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i;k&gt;<span class="number">0</span>&amp;&amp;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">      k=k<span class="number">-1</span>;</span><br><span class="line">      sum=sum+i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ac官方"><a class="markdownIt-Anchor" href="#ac官方"></a> AC（官方）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> k, coin = <span class="number">0</span>, day = <span class="number">0</span>;</span><br><span class="line">  cin &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      coin += i;</span><br><span class="line">      day++;</span><br><span class="line">      <span class="keyword">if</span> (day == k)</span><br><span class="line">      &#123;</span><br><span class="line">        cout &lt;&lt; coin &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
            <tag> 反思 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>acm(测试方法)</title>
      <link href="/2023/02/24/acm%EF%BC%88%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%EF%BC%89/"/>
      <url>/2023/02/24/acm%EF%BC%88%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>注：本文根据《算法入门经典第（2）版》撰写</p><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><blockquote><p>由于程序需要测试大量用例，手动输入较为麻烦。因此可以使用文件操作。一个好的方法是用文件——把输入数据保存在文件中，输出数据也保存在文件中。这样，只要事先把输入数据保存在文件中，就不必每次重新输入了；数据输出在文件中也避免了“输出太多，一卷屏前面的就看不见了”这样的尴尬，运行结束后，慢慢浏览输出文件即可。如果有标准答案文件，还可以进行文件比较，而无须编程人员逐个检查输出是否正确。事实上，几乎所有算法竞赛的输入数据和标准答案都是保存在文件中的。</p></blockquote><p>示例中采用创建date.in文件存储输入，date.out存储输出。</p><h2 id="一-文件重定向"><a class="markdownIt-Anchor" href="#一-文件重定向"></a> 一、文件重定向</h2><p>使用文件最简单的方法是使用输入输出重定向，只需在 main 函数的入口处加入以下两条语句：</p><ul><li>freopen(“input.txt”, “r”, stdin);</li><li>freopen(“output.txt”, “w”, stdout);</li></ul><p>上述语句将使得 scanf 从文件 input.txt 读入，printf 写入文件 output.txt。事实上，不只是 scanf 和 printf，所有读键盘输入、写屏幕输出的函数都将改用文件。尽管这样做很方便，并不是所有算法竞赛都允许用程序读写文件。甚至有的竞赛允许访问文件，但不允许用freopen 这样的重定向方式读写文件。参赛之前请仔细阅读文件读写的相关规定。</p><p>利用文件是一种很好的自我测试方法，但如果比赛要求采用标准输入输出，就必须在自我测试完毕之后删除重定向语句。<br />但是还有一种操作就是条件编译。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOCAL </span></span><br><span class="line">······</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL </span></span><br><span class="line"> <span class="built_in">freopen</span>(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); </span><br><span class="line"> <span class="built_in">freopen</span>(<span class="string">&quot;data.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout); </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">······</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该操作通过定义宏来规避影响，因为许多oj评测，编译时会定义ONLINE_JUDGE宏。如果有检测到这个宏，就不会运行重定向操作，这样就可以在本地使用文件输入输出。</p><h3 id="示例代码"><a class="markdownIt-Anchor" href="#示例代码"></a> 示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOCAL </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000000 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL </span></span><br><span class="line"> freopen(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>); </span><br><span class="line"> freopen(<span class="string">&quot;data.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>); </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> <span class="type">int</span> x, n = <span class="number">0</span>, min = INF, max = -INF, s = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x) == <span class="number">1</span>) </span><br><span class="line"> &#123; </span><br><span class="line"> s += x; </span><br><span class="line"> <span class="keyword">if</span>(x &lt; min) min = x; </span><br><span class="line"> <span class="keyword">if</span>(x &gt; max) max = x; </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> printf(&quot;x = %d, min = %d, max = %d\n&quot;, x, min, max); </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"> n++; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d %d %.3f\n&quot;</span>, min, max, (<span class="type">double</span>)s/n); </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这是一份典型的比赛代码，包含了几个特殊之处：</p><ul><li>重定向的部分被写在了#ifdef 和#endif 中。其含义是：只有定义了符号 LOCAL，才编译两条 freopen 语句。</li><li>输出中间结果的 printf 语句写在了注释中——它在最后版本的程序中不应该出现，但是又舍不得删除它（万一发现了新的 bug，需要再次用它输出中间信息）。将其注释的好处是：一旦需要时，把注释符去掉即可。</li></ul><p>上面的代码在程序首部就定义了符号 LOCAL，因此在本机测试时使用重定向方式读写文件。如果比赛要求读写标准输入输出，只需在提交之前删除#define LOCAL 即可。一个更好的方法是在编译选项而不是程序里定义这个 LOCAL 符号（不知道如何在编译选项里定义符号的读者请参考附录 A），这样，提交之前不需要修改程序，进一步降低了出错的可能。<br />提示 ：在算法竞赛中，有经验的选手往往会使用条件编译指令并且将重要的测试语句注释掉而非删除。</p><h2 id="fopen版"><a class="markdownIt-Anchor" href="#fopen版"></a> fopen版</h2><p>如果比赛要求用文件输入输出，但禁止用重定向的方式，又当如何呢？程序如下：<br />数据统计（fopen 版）</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; FILE *fin, *fout; </span><br><span class="line"> fin = fopen(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;rb&quot;</span>); </span><br><span class="line"> fout = fopen(<span class="string">&quot;data.out&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">  <span class="type">int</span> n, u, d, i, time = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">fscanf</span>(fin,<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;u, &amp;d) !=EOF &amp;&amp; (n!=<span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= u)</span><br><span class="line">      time = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;  <span class="keyword">for</span> (i = <span class="number">1</span>;; i++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= ((u - d) * i + u))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      time = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(fout,<span class="string">&quot;%d\n&quot;</span>, time);</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(fin); </span><br><span class="line">  fclose(fout);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>虽然新内容不少，但也很直观：先声明变量 fin 和 fout（暂且不用考虑 FILE *），把 scanf改成 fscanf，第一个参数为 fin；把 printf 改成 fprintf，第一个参数为 fout，最后执行 fclose，<br />关闭两个文件。<br />提示 ：在算法竞赛中，如果不允许使用重定向方式读写数据，应使用 fopen 和 fscanf/fprintf 进行输入输出。<br />重定向和 fopen 两种方法各有优劣。重定向的方法写起来简单、自然，但是不能同时读写文件和标准输入输出；fopen 的写法稍显繁琐，但是灵活性比较大（例如，可以反复打开并读写文件）。顺便说一句，如果想把 fopen 版的程序改成读写标准输入输出，只需赋值“fin =stdin; fout = stdout;”即可，不要调用 fopen 和 fclose。</p>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验 </tag>
            
            <tag> ACM训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>memcpy函数（详解）</title>
      <link href="/2023/02/24/memcpy/"/>
      <url>/2023/02/24/memcpy/</url>
      
        <content type="html"><![CDATA[<h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3><p>memcpy函数是C/C<ins>语言中的一个用于内存复制的函数，声明在 string.h 中（C</ins>是 cstring）。其原型是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *destin, <span class="type">void</span> *source, <span class="type">unsigned</span> n)</span>;</span><br></pre></td></tr></table></figure><p>作用是：以source指向的地址为起点，将连续的n个字节数据，复制到以destin指向的地址为起点的内存中。<br />函数有三个参数，第一个是目标地址，第二个是源地址，第三个是数据长度。</p><p>使用memcpy函数时，需要注意：</p><ul><li>数据长度（第三个参数）的单位是字节（1byte = 8bit）。</li><li>注意该函数有一个返回值，类型是void*，是一个指向destin的指针。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dst, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *psrc;</span><br><span class="line">    <span class="type">char</span> *pdst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == dst || <span class="literal">NULL</span> == src)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((src &lt; dst) &amp;&amp; (<span class="type">char</span> *)src + size &gt; (<span class="type">char</span> *)dst) <span class="comment">// 出现地址重叠的情况，自后向前拷贝</span></span><br><span class="line">    &#123;</span><br><span class="line">        psrc = (<span class="type">char</span> *)src + size - <span class="number">1</span>;</span><br><span class="line">        pdst = (<span class="type">char</span> *)dst + size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (size--)</span><br><span class="line">        &#123;</span><br><span class="line">            *pdst-- = *psrc--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        psrc = (<span class="type">char</span> *)src;</span><br><span class="line">        pdst = (<span class="type">char</span> *)dst;</span><br><span class="line">        <span class="keyword">while</span> (size--)</span><br><span class="line">        &#123;</span><br><span class="line">            *pdst++ = *psrc++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="memcpy函数复制的数据长度"><a class="markdownIt-Anchor" href="#memcpy函数复制的数据长度"></a> memcpy函数复制的数据长度</h3><p>使用memcpy函数时，特别要注意数据长度。如果复制的数据类型是char，那么数据长度就等于元素的个数。而如果数据类型是其他（如int, double, 自定义结构体等），就要特别注意数据长度的值。<br />好的习惯是，<mark>无论拷贝何种数据类型，都用 n * sizeof(type_name)的写法。</mark></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">10</span>] = <span class="string">&quot;abcdefgh&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> n = <span class="number">2</span>;</span><br><span class="line"><span class="type">void</span> * p = <span class="built_in">memcpy</span>(a+<span class="number">3</span>, a, n);</span><br></pre></td></tr></table></figure><p>以上代码将从a开始的两个字节的数据（即’a’和’b’），复制到从a+3开始的内存（'d’所在的地址）。这样，'d’和’e’被替换。<br />执行结束之后，字符数组（字符串）a的内容变为&quot;abcabfgh&quot;，返回值p即为a的地址（p == a）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="type">void</span> * p = <span class="built_in">memcpy</span>(a+<span class="number">3</span>, a, n);</span><br></pre></td></tr></table></figure><p>int类型的长度是4个字节。以上代码将从a开始的5个字节的数据复制。5个字节的数据是什么呢？前四个字节组成了一个完整的int（即第一个元素0）。第五个字节，只能取到第二个元素的第1个字节。这里又会涉及到big-endian和little-endian的问题。假设是小端方式储存（更常见），那么读到的是元素1的低8位，写成十六进制即0x1。<br />目标地址是a+3。由于指针加减常数，单位是与类型保持一致的，也就是在a的基础上，增加3倍int长度，对应的是元素3的地址。元素3被替换为0。元素4写成十六进制是0x0004，低8位被替换为0x1，变为0x0001。<br />所以执行结束之后，数组a的内容变为 { 0， 1， 2， 0， 1， 5， 6， 7， 8， 9 }，返回值p即为a的地址（p == a）。<br />根据上面的解释，如果把程序里的n改为6、7、8，那么结果都是一样的。因为数字1和4的二进制表示除了低8位不同，高位都是0。</p><p>倘若高位不相同，那么结果就没那么简单了。还是以int数组为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(a+<span class="number">3</span>, a, n);</span><br></pre></td></tr></table></figure><p>复制5个字节的数据，前4个字节组成了一个int，即第一个元素0。那么元素3被替换为0。第5个字节从-1中取。-1的十六进制表示为0xFFFF，第5个字节的数据是0xF。元素4变为0x000F，即15。数组a变为 { 0， -1， 2， 0， 15， 5， 6， 7， 8， 9 }。<br />如果 n = 6，那么4变为0x00FF，即255。数组a变为 { 0， -1， 2， 0， 255， 5， 6， 7， 8， 9 }。</p><p>可以看出，如果你想用memcpy复制元素，那么一定要写对数据长度。如果要完整地复制 n 个 int 类型元素，那么写法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> n = <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(a+<span class="number">3</span>, a, n);</span><br></pre></td></tr></table></figure><p>数组a变为 { 0， -1， 2， 0， -1， 2， 0， -1， 8， 9 }。<br />如果是其他类型，用法也是一样的。</p>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数详解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础知识</title>
      <link href="/2023/02/05/Git%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/02/05/Git%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="git基础知识"><a class="markdownIt-Anchor" href="#git基础知识"></a> Git基础知识</h1><h2 id="一-git的基本操作命令行"><a class="markdownIt-Anchor" href="#一-git的基本操作命令行"></a> 一、git的基本操作（命令行）</h2><h3 id="1建立仓库"><a class="markdownIt-Anchor" href="#1建立仓库"></a> 1.建立仓库</h3><p>在根目录输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">```   </span><br><span class="line">在mac、linux中隐藏了.git的文件夹，即本地git仓库。所有提交的内容都会储存在里面。  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 2.添加文件（告诉git需要添加的文件有哪些）</span></span></span><br><span class="line">``` shell</span><br><span class="line">git add 文件名  //单一文件</span><br><span class="line">git add -A //多文件，即将所有新增修改的文件全部上传</span><br><span class="line">```   </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 3.提交到本地仓库</span></span>  </span><br><span class="line">``` shell</span><br><span class="line">git commit -m &quot;初次提交/更新图片&quot; //&quot;&quot;内内容自定义，用来标识操作</span><br></pre></td></tr></table></figure><h3 id="4建立本地仓库与github的联系"><a class="markdownIt-Anchor" href="#4建立本地仓库与github的联系"></a> 4.建立本地仓库与github的联系</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/用户名/仓库名.git //github生成htttps链接</span><br><span class="line">```   </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 5.上传到仓库</span></span></span><br><span class="line">``` shell</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>git push 到远程仓库的master（主分支）上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">info: please complete authentication in your browser...</span><br><span class="line">Enumerating objects: 3, done.</span><br><span class="line">Counting objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (3/3), 222 bytes | 222.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">To https://github.com/Hao-star123/git_learn.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">branch &#x27;master&#x27; set up to track &#x27;origin/master&#x27;.  </span><br></pre></td></tr></table></figure><p>第一次使用github会弹出登录界面</p><h2 id="二"><a class="markdownIt-Anchor" href="#二"></a> 二、</h2><h3 id="1下载仓库代码pull"><a class="markdownIt-Anchor" href="#1下载仓库代码pull"></a> 1.下载仓库代码（pull)</h3><p>当线上版本更新，下载时可以使用拉取命令,将文件下载到本地进行更新。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h3 id="2下载仓库代码git-clone"><a class="markdownIt-Anchor" href="#2下载仓库代码git-clone"></a> 2.下载仓库代码(git clone)</h3><pre class="highlight"><code class="shell">git clone https://github.com/用户名/仓库名.git</code></pre><h3 id="3ssh秘钥"><a class="markdownIt-Anchor" href="#3ssh秘钥"></a> 3.ssh秘钥</h3><p>秘钥分为私钥（存放在本地，类似于门禁卡）和公钥（github,类似于装门禁的门）</p><h4 id="1生成秘钥"><a class="markdownIt-Anchor" href="#1生成秘钥"></a> 1.生成秘钥</h4><pre class="highlight"><code class="shell">ssh-keygen</code></pre><p>秘钥位置：</p><ol><li>mocOS<ul><li>~/.ssh</li></ul></li><li>Windows<ul><li>C:/用户/（你的）用户名/.ssh</li></ul></li></ol><blockquote><p>生成文件id_rsa是私钥<br />id_rsa.pub是公钥</p></blockquote><p>用记事本打开公钥，复制公钥</p><h4 id="2配置ssh到github"><a class="markdownIt-Anchor" href="#2配置ssh到github"></a> 2.配置ssh到github</h4><p>进入github，点击右上角头像 选择settings，进入设置页后选择 SSH and GPG keys，名字随便起，公钥填到Key那一栏。<br />配置成功后，可使用ssh方式连接github</p><pre class="highlight"><code class="shell">git clone git@github.com:用户名/仓库名.git</code></pre><h4 id="2注"><a class="markdownIt-Anchor" href="#2注"></a> 2.注</h4><p>仓库setting内的Deploy keys，是添加部署秘钥的。填写服务器生成的秘钥，不是本地开发电脑生成的秘钥。在项目上线时，在服务器上执行git clone命令时会使用的秘钥。在服务器用来运行完善代码，而非开发，因此无需要勾选 Allow write access 的写权限，主要知识在linux服务器中。</p><h2 id="htttps和ssh"><a class="markdownIt-Anchor" href="#htttps和ssh"></a> htttps和ssh</h2><p>ssh添加成功后git操作将不需要登录验证，更加方便。</p><h3 id="4添加合作用户"><a class="markdownIt-Anchor" href="#4添加合作用户"></a> 4.添加合作用户</h3><p>在仓库settings左侧的Collaborators，单击Manage access中的add people按钮，输入github的用户名或者邮箱，他会收到github的邀请邮件，确认后拥有该仓库的操作权限<br /> <br /></p><h1 id="二-git的基本操作客户端"><a class="markdownIt-Anchor" href="#二-git的基本操作客户端"></a> 二、git的基本操作（客户端）</h1><p>更新操作会显示</p>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C指针与地址</title>
      <link href="/2023/01/29/C%E6%8C%87%E9%92%88%E4%B8%8E%E5%9C%B0%E5%9D%80/"/>
      <url>/2023/01/29/C%E6%8C%87%E9%92%88%E4%B8%8E%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="c指针与地址"><a class="markdownIt-Anchor" href="#c指针与地址"></a> C指针与地址</h1><blockquote><p>在C语言的学习过程中，常理不清指针（即一个变量的地址）和指针变量（专门用来存放另一变量的地址(指针)的变量）的关系，因此通过程序打印地址运行结果，来分析加强理解。以此记录学习过程中的心得，希望能帮到大家，感谢指正。</p></blockquote><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><h3 id="一-代码示例"><a class="markdownIt-Anchor" href="#一-代码示例"></a> 一、代码示例</h3><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">88</span>,b=<span class="number">60</span> ;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p=&amp;a;<span class="comment">//指向a的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#p&quot;</span>,p);<span class="comment">//以十六进制的形式输出</span></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot; %p &quot;</span>,*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %p\n&quot;</span>,&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot; %d &quot;</span>,*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %d\n&quot;</span>,&amp;p);</span><br><span class="line">    p--;<span class="comment">//指针移动指向b的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#p&quot;</span>,p);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot; %p &quot;</span>,*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %p\n&quot;</span>,&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot; %d &quot;</span>,*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %d\n&quot;</span>,&amp;p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2运行结果"><a class="markdownIt-Anchor" href="#2运行结果"></a> 2.运行结果</h3><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000000000061F</span>E1C</span><br><span class="line"><span class="number">0X000000000061FE1C</span> <span class="number">0000000000000058</span>  <span class="number">000000000061F</span>E10</span><br><span class="line"><span class="number">6422044</span> <span class="number">88</span>  <span class="number">6422032</span></span><br><span class="line"><span class="number">000000000061F</span>E18</span><br><span class="line"><span class="number">0X000000000061FE18</span> <span class="number">000000000000003</span>C  <span class="number">000000000061F</span>E10</span><br><span class="line"><span class="number">6422040</span> <span class="number">60</span>  <span class="number">6422032</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>在指针*p=&amp;a初始化后，p等同于&amp;a即a的地址，在运行过程中可以代换。%#p是输出位0X开开头的16进制数。因此printf(“%p\n”,&amp;a);    printf(“%#p”,p);本质是一样的。*p则是通过指针变量p存储的a的地址，间接获取a的值。*p=a,对数值%p等同于对数值以十六进制位输出。%d对p,*p,&amp;p则是以十进制形式分别输出地址，值，地址。</p><p>p–，由于p是整型指针，p–减去int的4个字节刚好移动到b。</p><blockquote><p>【注】1.这里发现后定义的变量b的地址要小于a的地址，这是因为c语言中，先定义的数据先入栈，在栈的底部（不分配内存），声明结束后，b在栈顶，所以b先出栈，先为b分配内存。因此b的地址小于a的地址。<br />   2.数据的地址位数和数据能存储的位数无关。学习阶段曾存在疑问（输出的地址是16位，int是4字节，即16进制的4位代表一个字节（实际应该是一个字节等于2位16进制），一个字节等于八位二进制，但八位二进制不等于四位16进制？）通过交流请教得知有关计算机组成原理，地址位数只取决于系统，所有类型的指针所占长度相同。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针知识框架（详解）</title>
      <link href="/2023/01/29/%E6%8C%87%E9%92%88%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%EF%BC%88%E8%AF%A6%E8%A7%A3%EF%BC%89/"/>
      <url>/2023/01/29/%E6%8C%87%E9%92%88%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%EF%BC%88%E8%AF%A6%E8%A7%A3%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="指针知识框架详解"><a class="markdownIt-Anchor" href="#指针知识框架详解"></a> 指针知识框架（详解）</h1><blockquote><p>本文为C语言学习过程中关于指针的笔记。根据书籍和程序题并参考网络上的博客回答，撰写的感悟和收获。<br />文章参考：<br />C语言解惑指针、数组、函数和多文件编程（作者刘振安刘燕君，机械工业出版社）</p></blockquote><h2 id="一-对指针使用const限定符"><a class="markdownIt-Anchor" href="#一-对指针使用const限定符"></a> 一、对指针使用const限定符</h2><h3 id="1指向常量的指针"><a class="markdownIt-Anchor" href="#1指向常量的指针"></a> 1.指向常量的指针</h3><blockquote><p>const int  y=66;<br />const int <em>p=&amp;y; //此时y和</em>p都不能做为左值，但可以作为右值。</p></blockquote><p>使指针指向一个不可修改的常量，即<em>p是常量。但是可以通过修改p指向的地址，改变</em>p的值。<br />例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">const</span> <span class="type">int</span> y=<span class="number">66</span>;</span><br><span class="line"> <span class="type">int</span> x=<span class="number">50</span>;</span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> * p =&amp;y;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%p\n&quot;</span>,y,*p,p);</span><br><span class="line"> p=&amp;x;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%p\n&quot;</span>,x,*p,p);</span><br><span class="line"><span class="comment">/*输出结果为：</span></span><br><span class="line"><span class="comment">  66,66,000000000062FE14</span></span><br><span class="line"><span class="comment">  50,50,000000000062FE10*/</span></span><br></pre></td></tr></table></figure><p>由指向y改为指向x,*p被覆盖。</p><h3 id="2指向常量的指针指向非常量"><a class="markdownIt-Anchor" href="#2指向常量的指针指向非常量"></a> 2.指向常量的指针指向非常量</h3><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">55</span> ;<span class="comment">//变量x能作为左值和右值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y=<span class="number">88</span>;<span class="comment">//常量y不能作为左值，但可以作为右值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *p;<span class="comment">//声明指向常量的指针</span></span><br><span class="line">    <span class="type">int</span> *p1 ;<span class="comment">//声明指针</span></span><br><span class="line">    p=&amp;y ;<span class="comment">//用常量初始化指向常量的指针，*p不能作为左值</span></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>,*p) ;</span><br><span class="line">    p=&amp;x;<span class="comment">//p作为左值，使常量指针改为指向变量x,*p不能作为左值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*p) ;</span><br><span class="line">    x=<span class="number">128</span> ;<span class="comment">//用x作为左值间接改变*p的值，使*p=x=128</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *p) ;</span><br><span class="line">    p1=(<span class="type">int</span>*)&amp;y;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p1) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中指向常量的指针p指向变量x,仅限制直接使用<em>p作为左值，但可以通过直接修改x的值改变</em>p的值。同时也与使用非常量指针一样，也可以直接使用“&amp;”改变常量指针的指向，显然也改变了*p的值。</p><blockquote><p>【注】常量只能由指向常量的指针（即const void<em>p）指向，否则必须进行强制转换，将常量强制转换为相应的指针类型。如示例：p1=(int</em>)&amp;y;</p></blockquote><h3 id="3常量指针"><a class="markdownIt-Anchor" href="#3常量指针"></a> 3.常量指针</h3><p>限定符const放在*号右边，是指针本身成为一个const指针。声明常量时必须进行初始化，即指针变量p存储的为常量地址。</p><blockquote><p>例如:int x=45;<br />int * const p=&amp;x//p始终指向x的地址。但可以修改x地址内存的值，x=123和*p=123；但p指向的地址不能改变</p></blockquote><h3 id="4指向常量的常量指针"><a class="markdownIt-Anchor" href="#4指向常量的常量指针"></a> 4.指向常量的常量指针</h3><p>即指针和指向的对象都不能改动的“指向常量的常量指针”。<em>p和p都是常量。限制了“&amp;”和“</em>”运算符，很少使用。</p><h3 id="5void指针"><a class="markdownIt-Anchor" href="#5void指针"></a> 5.void指针</h3><p>void类型不能声明变量，但可以声明void类型的指针，而void型指针可以指向任何类型的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">256</span>, y=<span class="number">386</span>,*p=&amp;x;</span><br><span class="line">    <span class="type">void</span>*vp=&amp;x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,vp,p,x);</span><br><span class="line">    vp=&amp;y;</span><br><span class="line">    p=(<span class="type">int</span>*)vp;<span class="comment">//虽然void指针指向整型变量对象x，但不能使用*vp应用整型对象的值。要引用这个值，必须强制将void指针赋值给与值相对应的指针类型。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,vp,p,*p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【注】但奇怪的是，测试时发现p=(int*)vp不加（int*）也可以正常运行。</p></blockquote><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><p>const放在<em>的右边（void * const p）,修饰的是指针（即指针变量p指向的地址）不可改变。<br />const放在前端（const void * p）,修饰的是指向的对象（指针变量p存储的地址的值）,即</em>p是常量</p><h2 id="二-指针与数组"><a class="markdownIt-Anchor" href="#二-指针与数组"></a> 二、指针与数组</h2><h3 id="1数组与指针的关系"><a class="markdownIt-Anchor" href="#1数组与指针的关系"></a> 1.数组与指针的关系</h3><p>指向数组的指针实际上指的是能够指向数组众人一个元素的指针。</p><blockquote><p>int a[5];<br />int *pa=&amp;a[0];//等同于int *pa;<br />            pa=a;</p></blockquote><p>数组名和指针的区别：指针是变量：pa=a或pa<ins>是有意义的；<br />      数组名是指针常量：a=pa、a</ins>、pa=&amp;a（a本身就是地址，无法对地址取地址）是非法操作。<br />假设指针现在指向a[0],则数组的第i个（下标为i）元素可表示为a[i]或*（pa+i）,还可使用带下标的指针pa,即pa[i]和*（pa+i）的含义一样。若将a[i]的值修改，下列语句等价。</p><blockquote><p>a[i]=123; *(a+4)=123; *(pa+4)=123; pa[4]=123;</p></blockquote><p><em><center>指针与数组元素的关系</center></em></p><table><thead><tr><th>下标</th><th>数组名</th><th>指针</th><th>指针下标</th><th>四者的逻辑关系</th></tr></thead><tbody><tr><td>a[0]</td><td>a</td><td>pa</td><td>pa[0]</td><td>a[0]<mark>*a</mark>*pa==pa[0]</td></tr><tr><td>a[1]</td><td>a+1</td><td>pa+1</td><td>pa[1]</td><td>a[1]<mark>*(a+1)</mark>*(pa+1)==pa[1]</td></tr><tr><td>a[2]</td><td>a+2</td><td>pa+2</td><td>pa[2]</td><td>a[2]<mark>*(a+2)</mark>*(pa+2)==pa[2]</td></tr></tbody></table><h2 id="2指针数组和数组指针"><a class="markdownIt-Anchor" href="#2指针数组和数组指针"></a> 2.指针数组和数组指针</h2><blockquote><p>数组的指针：是一个指针，什么样的指针呢？指向数组的指针。<br />指针的数组：是一个数组，什么样的数组呢？装着指针的数组。<br />本质是的后面是类型。<br />然后，需要明确一个优先级顺序：()&gt;[]&gt;*，所以：<br />(*p)[n]：根据优先级，先看括号内，则p是一个指针，这个指针指向一个一维数组，数组长度为n，这是“数组的指针”，即数组指针；<br /><em>p[n]：根据优先级，先看[]，则p是一个数组，再结合</em>，这个数组的元素是指针类型，共n个元素，这是“指针的数组”，即指针数组。<br />根据上面两个分析，可以看出，p是什么，则词组的中心词就是什么，即数组“指针”和指针“数组”。  <br>————数组指针和指针数组_mick_hu的博客-CSDN博客_数组指针和指针数组<a href="https://blog.csdn.net/mick_hu/article/details/100931034?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166954491916782428658613%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166954491916782428658613&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-100931034-null-null.142%5Ev66%5Econtrol,201%5Ev3%5Econtrol_2,213%5Ev2%5Et3_esquery_v2&amp;utm_term=%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88&amp;spm=1018.2226.3001.4187">原文地址</a></p></blockquote><h2 id="3-c语言优先级"><a class="markdownIt-Anchor" href="#3-c语言优先级"></a> 3. c语言优先级</h2><blockquote><p>C语言运算符优先级（超详细）_embed_huang的博客-CSDN博客_c语言运算符优先级构成一系列表达式（六个左右），然后分析并打印输出他的结果<a href="https://blog.csdn.net/huangblog/article/details/8271791?spm=1001.2014.3001.5506">原文地址</a></p></blockquote><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法入门</title>
      <link href="/2023/01/29/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"/>
      <url>/2023/01/29/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">实验A1：表达式<span class="number">11111</span>*<span class="number">11111</span>的值是多少？把<span class="number">5</span>个<span class="number">1</span>改成<span class="number">6</span>个<span class="number">1</span>呢？<span class="number">9</span>个<span class="number">1</span>呢？</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">11111</span>*<span class="number">11111</span>);  <span class="comment">//正常数字123454321</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">111111</span>*<span class="number">111111</span>); <span class="comment">//数据太大溢出，为负值-539247567</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">111111111</span>*<span class="number">111111111</span>); <span class="comment">//结果是整数，但是数值错误1653732529</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">实验A2：把实验A1中的所有数换成浮点数，结果如何  </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,<span class="number">11111.0</span>*<span class="number">11111.0</span>);<span class="comment">//123454321.000000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,<span class="number">111111.0</span>*<span class="number">111111.0</span>);<span class="comment">//12345654321.000000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,<span class="number">111111111.0</span>*<span class="number">111111111.0</span>);<span class="comment">//12345678987654320.000000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*又改成%d</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    printf(&quot;%d\n&quot;,11111.0*11111.0);//123454321.000000</span></span><br><span class="line"><span class="comment">    printf(&quot;%d\n&quot;,111111.0*111111.0);//12345654321.000000</span></span><br><span class="line"><span class="comment">    printf(&quot;%d\n&quot;,111111111.0*111111111.0);//12345678987654320.000000</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/zhaojunwuiris/article/details/83654072">#INF00：出现此报错说明是数值溢出，或者说是除数为0</a></p></blockquote><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>#IND</td><td>这个的情况更复杂，一般来说，它们来自于任何未定义结果（非法）的浮点数运算。&quot;IND&quot;是 indeterminate（不确定） 的缩写，而&quot;nan&quot;是 not a number 的缩写。IND表示NAN, 比如 0/0  log( -1 ) 等等。IND是Windows上的说法，NaN是Linux上的说法，含义是一样的。产生这个值的常见例子有：对负数开平方，对负数取对数，0.0/0.0，0.0*∞, ∞/∞ 等。也可能由于一些操作使得程序中产生了无效数字或者没有给成员变量赋值，使用类似于pow, exp等等函数时常会产生一个无效数字1.#IND00（-1.#IND00 对应符号位 1 , 阶码全1 , 尾数非0 ）。</td></tr><tr><td>#INF</td><td>这个值表示“无穷大inf (infinity 的缩写)”，即超出了计算机可以表示的浮点数的最大范围（或者说超过了 double 类型的最大值）。一般来说是除数为0得出的结果，例如，当一个整数除以0时便会得到一个1.#INF / inf值；相应的，如果一个负整数除以0会得到 -1.#INF / -inf 值。</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">实验A3：表达式<span class="built_in">sqrt</span>(<span class="number">-10</span>)的值是多少？尝试用各种方式输出。在计算过程中系统会报错吗？  </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,<span class="built_in">sqrt</span>(<span class="number">-10</span>));<span class="comment">//-1.#IND00</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sqrt</span>(<span class="number">-10</span>));<span class="comment">//0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>,<span class="built_in">sqrt</span>(<span class="number">-10</span>));<span class="comment">//-1.#IND000000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">实验A4：表达式<span class="number">1.0</span>/<span class="number">0.0</span>,<span class="number">0.0</span>/<span class="number">0.0</span>的值是多少？尝试用各种方式输出。在计算过程中会报错吗？  </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,<span class="number">1.0</span>/<span class="number">0.0</span>);<span class="comment">//1.#INF00</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>,<span class="number">1.0</span>/<span class="number">0.0</span>);<span class="comment">//1.#J</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>,<span class="number">1.0</span>/<span class="number">0.0</span>);<span class="comment">//1.#INF000000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,<span class="number">0.0</span>/<span class="number">0.0</span>);<span class="comment">//-1.#IND00</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>,<span class="number">0.0</span>/<span class="number">0.0</span>);<span class="comment">//-1.#J</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">用程序实验测试<span class="type">int</span>整数的最小值和最大值（精确值）</span><br><span class="line"><span class="comment">//决定int最大值的主要原因:根据编译器类型不同而变化。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;    </span><br><span class="line"> <span class="comment">/*int n = 0, i = 0;</span></span><br><span class="line"><span class="comment"> while (n &gt;= i)</span></span><br><span class="line"><span class="comment"> &#123;</span></span><br><span class="line"><span class="comment">   n = i;</span></span><br><span class="line"><span class="comment">   i--;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> printf(&quot;%d&quot;, n);*/</span>   <span class="comment">//-2147483648(最小值)</span></span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> n = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (n &lt;= i) &#123;</span><br><span class="line">   n = i;</span><br><span class="line">   i++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n);     <span class="comment">//2147483647（最大值）</span></span><br><span class="line"> system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//7744 问题（1）函数 floor(x)返回不超过 x 的最大整数。floor(小数不能是整数)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">1</span>; a &lt;= <span class="number">9</span>; a++) </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">9</span>; b++) </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="type">int</span> n = a*<span class="number">1100</span> + b*<span class="number">11</span>; <span class="comment">//这里才开始使用 n，因此在这里定义 n</span></span><br><span class="line"> <span class="type">int</span> m = <span class="built_in">floor</span>(<span class="built_in">sqrt</span>(n) + <span class="number">0.5</span>); </span><br><span class="line"> <span class="keyword">if</span>(m*m == n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*读者可能会问：可不可以这样写？if(sqrt(n) == floor(sqrt(n))) printf(&quot;%d\n&quot;, n)，即直接判</span></span><br><span class="line"><span class="comment">断 sqrt(n)是否为整数。理论上当然没问题，但这样写不保险，因为浮点数的运算（和函数）</span></span><br><span class="line"><span class="comment">有可能存在误差。</span></span><br><span class="line"><span class="comment">假设在经过大量计算后，由于误差的影响，整数 1 变成了 0.9999999999，floor 的结果</span></span><br><span class="line"><span class="comment">会是 0 而不是 1。为了减小误差的影响，一般改成四舍五入，即 floor(x+0.5)①。如果难以理</span></span><br><span class="line"><span class="comment">解，可以想象成在数轴上把一个单位区间往左移动 0.5 个单位的距离。floor(x)等于 1 的区间</span></span><br><span class="line"><span class="comment">为[1,2)，而 floor(x+0.5)等于 1 的区间为[0.5, 1.5)。</span></span><br><span class="line"><span class="comment">提示 2-7：浮点运算可能存在误差。在进行浮点数比较时，应考虑到浮点误差。*/</span></span><br></pre></td></tr></table></figure><blockquote><p>数学定理：要计算只包含加法、减法和乘法的整数表达式除以正整数 n 的余数，可以在每步计算之后对 n 取余，结果不变</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*p31 程序 2-11 数据统计（fopen 版），如果想把 fopen 版的程序改成读写标准输入输出，只需赋值“fin =stdin; fout =stdout;”即可，不要调用 fopen 和 fclose①。*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000000 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line"> FILE *fin, *fout; </span><br><span class="line"> fin = fopen(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;rb&quot;</span>); </span><br><span class="line"> fout = fopen(<span class="string">&quot;data.out&quot;</span>, <span class="string">&quot;wb&quot;</span>); </span><br><span class="line"> <span class="type">int</span> x, n = <span class="number">0</span>, min = INF, max = -INF, s = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">while</span>(<span class="built_in">fscanf</span>(fin, <span class="string">&quot;%d&quot;</span>, &amp;x) == <span class="number">1</span>) </span><br><span class="line"> &#123; </span><br><span class="line"> s += x; </span><br><span class="line"> <span class="keyword">if</span>(x &lt; min) min = x; </span><br><span class="line"> <span class="keyword">if</span>(x &gt; max) max = x; </span><br><span class="line"> n++; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">fprintf</span>(fout, <span class="string">&quot;%d %d %.3f\n&quot;</span>, min, max, (<span class="type">double</span>)s/n); </span><br><span class="line"> fclose(fin); </span><br><span class="line"> fclose(fout); </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Time used = %.2f\n&quot;</span>, (<span class="type">double</span>)clock() / CLOCKS_PER_SEC);</span><br></pre></td></tr></table></figure><blockquote><p>由于函数内会被系统动态分配内存比较小，所以只有数组定义放在main函数外面时，数组 a 才可以开得很大；放在 main 函数内时，数组稍大就会异常退出。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结整理 </tag>
            
            <tag> 算法入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/12/13/hello-world/"/>
      <url>/2022/12/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客相关 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
