<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CTF竞赛模式与训练平台</title>
      <link href="/2023/10/07/CTF%E7%AB%9E%E8%B5%9B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%AD%E7%BB%83%E5%B9%B3%E5%8F%B0/"/>
      <url>/2023/10/07/CTF%E7%AB%9E%E8%B5%9B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%AD%E7%BB%83%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="海岛blog"><a class="markdownIt-Anchor" href="#海岛blog"></a> <a href="https://blog.csdn.net/tigerisland45/category_9866812.html">海岛Blog</a></h2><p>CTF竞赛主要有夺旗赛和攻防对抗赛。</p><h2 id="夺旗赛"><a class="markdownIt-Anchor" href="#夺旗赛"></a> 夺旗赛</h2><p>一般线上初选采用传统的夺旗赛模式，题目中设置一些标识，解题的目的是找到标识并提交。通常包含的题目类型包括MISC、CRYPTO、PWN、REVERSE、WEB、STEGA等。</p><p>MISC(Miscellaneous)类型，即安全杂项，涉及流量分析、电子取证、人肉搜索、数据分析等等。</p><p>CRYPTO(Cryptography)类型，即密码学，考察各种加解密技术，包括古典加密技术、现代加密技术甚至出题者自创加密技术。</p><p>PWN类型，PWN在黑客俚语中代表着攻破、取得权限，多为溢出类题目。</p><p>REVERSE类型，即逆向工程，涉及软件逆向、破解技术等。</p><p>STEGA(Steganography)类型，即隐写术，Flag会隐藏到图片、音频、视频等各类数据载体中供参赛者获取。</p><p>WEB类型，涉及到常见的Web漏洞，诸如注入、XSS、文件包含、代码执行等漏洞。</p><h2 id="ctf训练平台"><a class="markdownIt-Anchor" href="#ctf训练平台"></a> CTF训练平台</h2><p><a href="http://www.ichunqiu.com/">i春秋</a><br /><a href="http://www.hetianlab.com/">合天智汇</a><br /><a href="http://www.shiyanbar.com/">实验吧</a><br /><a href="http://www.shiyanbar.com/">胖哈勃</a><br /><a href="http://bobao.360.cn/ctf/index">安全客CTF训练营</a><br /><a href="http://oj.xctf.org.cn/">XCTF实训平台</a></p><h2 id="相关链接"><a class="markdownIt-Anchor" href="#相关链接"></a> 相关链接</h2><p><a href="http://www.ciscn.cn/">全国大学生信息安全竞赛官方网站</a><br /><a href="https://ctf-wiki.org/">简介 - CTF Wiki</a><br /><a href="https://www.ichunqiu.com/competition/teams">明星战队 - CTF大本营 - 网络安全竞赛平台-i春秋</a><br /><a href="https://www.xctf.org.cn/">XCTF社区 | XCTF联赛对外发布及交流平台</a><br /><a href="https://www.cnblogs.com/zhaijiahui/p/13072893.html">在线CTF练习平台</a></p><h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2><p>全国大学生信息安全竞赛创新实践能力赛</p>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM2</title>
      <link href="/2023/10/07/ACM2/"/>
      <url>/2023/10/07/ACM2/</url>
      
        <content type="html"><![CDATA[<h1 id="2-1"><a class="markdownIt-Anchor" href="#2-1"></a> 2-1</h1><h2 id="a-输出200-299之间的所有素数"><a class="markdownIt-Anchor" href="#a-输出200-299之间的所有素数"></a> A 输出200-299之间的所有素数</h2><h3 id="description"><a class="markdownIt-Anchor" href="#description"></a> Description</h3><blockquote><p>一个整数如果不能被1和自身以外的所有整数所整除，那么这个数是素数。编写程序找出200~299之间的所有素数。</p></blockquote><h3 id="input"><a class="markdownIt-Anchor" href="#input"></a> Input</h3><p>无输入。</p><h3 id="output"><a class="markdownIt-Anchor" href="#output"></a> Output</h3><p>200~299之间的所有素数，每8个数就换行。注意：每一行第一个数字（如211 257）前无空格，每一行最后一个数字（如251 293）后面无空格。</p><h3 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//素数判断函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num = <span class="number">200</span>; num &lt;= <span class="number">299</span>; ++num) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPrime</span>(num)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">8</span>) &#123;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; num;</span><br><span class="line">            <span class="keyword">if</span> (num != <span class="number">299</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="b-深入浅出学算法002-n个1"><a class="markdownIt-Anchor" href="#b-深入浅出学算法002-n个1"></a> B 深入浅出学算法002-n个1</h2><p><a href="https://www.cnblogs.com/chenlong991223/p/10153779.html">深入浅出学算法002-n个1 </a></p><h3 id="description-2"><a class="markdownIt-Anchor" href="#description-2"></a> Description</h3><blockquote><p>由n个1组成的整数能被K（K&lt;10000)整除，n至少为多少？</p></blockquote><h3 id="input-2"><a class="markdownIt-Anchor" href="#input-2"></a> Input</h3><p>多组测试数据，第一行输入整数T,表示组数 然后是T行，每行输入1个整数代表K</p><h3 id="output-2"><a class="markdownIt-Anchor" href="#output-2"></a> Output</h3><p>对于每组测试数据输出1行，值为n</p><h3 id="sample-input"><a class="markdownIt-Anchor" href="#sample-input"></a> Sample Input</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">11</span><br></pre></td></tr></table></figure><h3 id="sample-output"><a class="markdownIt-Anchor" href="#sample-output"></a> Sample Output</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="解答-2"><a class="markdownIt-Anchor" href="#解答-2"></a> 解答</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> K;</span><br><span class="line">        cin &gt;&gt; K;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> remainder = <span class="number">1</span> % K;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (remainder != <span class="number">0</span>) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            remainder = (remainder * <span class="number">10</span> + <span class="number">1</span>) % K;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-深入浅出学算法005-数7"><a class="markdownIt-Anchor" href="#c-深入浅出学算法005-数7"></a> C 深入浅出学算法005-数7</h2><h3 id="description-3"><a class="markdownIt-Anchor" href="#description-3"></a> Description</h3><blockquote><p>逢年过节，三五好友，相约小聚，酒过三旬，围桌数七。 “数七”是一个酒桌上玩的小游戏。就是按照顺序，某人报一个10以下的数字，然后后面的人依次在原来的数字上加1，并喊出来，当然如果要喊的数包含7或者是7的倍数，那么不能直接喊，可以敲一下筷子，否则就算输，要罚酒一杯。</p></blockquote><h3 id="input-3"><a class="markdownIt-Anchor" href="#input-3"></a> Input</h3><p>多组测试数据，先输入整数T表示组数， 每组测试数据输入一个10以下的正整数，</p><h3 id="output-3"><a class="markdownIt-Anchor" href="#output-3"></a> Output</h3><p>对于每组测试数据，输出在一行，要求从小到大输出所报数（含）到100之间所有不能喊的数字</p><h3 id="sample-input-2"><a class="markdownIt-Anchor" href="#sample-input-2"></a> Sample Input</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="sample-output-2"><a class="markdownIt-Anchor" href="#sample-output-2"></a> Sample Output</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 14 17 21 27 28...</span><br></pre></td></tr></table></figure><h3 id="解答-3"><a class="markdownIt-Anchor" href="#解答-3"></a> 解答</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">        for (int i = n; i &lt;= 100; ++i) &#123;</span><br><span class="line">            if (i % 7 == 0 || i % 10 == 7) &#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="d-兑换支票"><a class="markdownIt-Anchor" href="#d-兑换支票"></a> D 兑换支票</h2><p>Problem Description:<br />There are three kinds of coins:1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo separator="true">,</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">,2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span></span></span></span>,3$.</p><p>Given a chique of N$(0&lt;n&lt;=10^9),calculate the number of different ways to exchange the cheque.</p><p>Sample Input:1 2 3</p><p>Sample Outpt:1 2 3</p><h2 id="e-number-sequence"><a class="markdownIt-Anchor" href="#e-number-sequence"></a> E Number Sequence</h2><h3 id="problem-description"><a class="markdownIt-Anchor" href="#problem-description"></a> Problem Description</h3><blockquote><p>A number sequence is defined as follows:<br />f(1) = 1, f(2) = 1, f(n) = (A * f(n - 1) + B * f(n - 2)) mod 7.<br />Given A, B, and n, you are to calculate the value of f(n).</p></blockquote><h3 id="input-4"><a class="markdownIt-Anchor" href="#input-4"></a> Input</h3><p>The input consists of multiple test cases. Each test case contains 3 integers A, B and n on a single line (1 &lt;= A, B &lt;= 1000, 1 &lt;= n &lt;= 100,000,000). Three zeros signal the end of input and this test case is not to be processed.</p><h3 id="output-4"><a class="markdownIt-Anchor" href="#output-4"></a> Output</h3><p>For each test case, print the value of f(n) on a single line.</p><h3 id="sample-input-3"><a class="markdownIt-Anchor" href="#sample-input-3"></a> Sample Input</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 1 3</span><br><span class="line">1 2 10</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure><h3 id="sample-output-3"><a class="markdownIt-Anchor" href="#sample-output-3"></a> Sample Output</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="author"><a class="markdownIt-Anchor" href="#author"></a> Author</h3><p>CHEN, Shunbao</p><h3 id="source"><a class="markdownIt-Anchor" href="#source"></a> Source</h3><p><a href="https://acm.hdu.edu.cn/search.php?field=problem&amp;key=ZJCPC2004&amp;source=1&amp;searchmode=source">ZJCPC2004</a></p><h3 id="解答-4"><a class="markdownIt-Anchor" href="#解答-4"></a> 解答</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 7</span></span><br><span class="line"><span class="type">int</span> f[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;a, &amp;b, &amp;n)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!a &amp;&amp; !b &amp;&amp; !n)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        f[<span class="number">1</span>] = f[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">49</span>; i++)</span><br><span class="line">            f[i] = (a * f[i - <span class="number">1</span>] + b * f[i - <span class="number">2</span>]) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n % <span class="number">49</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="f-水果配载"><a class="markdownIt-Anchor" href="#f-水果配载"></a> F 水果配载</h2><h3 id="description-4"><a class="markdownIt-Anchor" href="#description-4"></a> Description</h3><p>水果销售公司接了一个单子，现要从公司将货运到火车站。水果都用箱子装好了，现有三种型号的，分别重量为910、462、和235kg的。现在有不同装载量的货车，请根据装载量给不同货车设计配载方案，使装载的重量总和最大。</p><h3 id="input-5"><a class="markdownIt-Anchor" href="#input-5"></a> Input</h3><p>多个测试案例，每个一行，输入货车的最大装载量m(m不超过20000），最后一行是0,不需要处理</p><h3 id="output-5"><a class="markdownIt-Anchor" href="#output-5"></a> Output</h3><p>每个测试案例输出分2行第一行输出&quot;Solution A is:“,然后是三种箱子各多少个，中间用一个空格隔开第二行输出&quot;Load A is:”,然后是总载重量其中A是第几个测试案例。</p><h3 id="sample-input-4"><a class="markdownIt-Anchor" href="#sample-input-4"></a> Sample Input</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8000</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id=""><a class="markdownIt-Anchor" href="#"></a> <a href=""></a>Sample Output</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Solution 1 is: 7 2 3</span><br><span class="line">Load 1 is: 7999</span><br></pre></td></tr></table></figure><h3 id="解答-5"><a class="markdownIt-Anchor" href="#解答-5"></a> 解答</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">20001</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">bool</span> v[<span class="number">20001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, l, n, cas = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> w[<span class="number">3</span>] = &#123;<span class="number">235</span>, <span class="number">462</span>, <span class="number">910</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cas++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">235</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Solution &quot;</span> &lt;&lt; cas &lt;&lt; <span class="string">&quot; is: 0 0 0&quot;</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Load &quot;</span> &lt;&lt; cas &lt;&lt; <span class="string">&quot; is: 0&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(v, <span class="literal">false</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">        v[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = w[i]; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[j - w[i]] &amp;&amp; !v[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (l = <span class="number">0</span>; l &lt; <span class="number">3</span>; l++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (l == i)</span><br><span class="line">                            f[j][l] = f[j - w[i]][l] + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            f[j][l] = f[j - w[i]][l];</span><br><span class="line">                    &#125;</span><br><span class="line">                    v[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; n &gt;= <span class="number">235</span>; n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[n])</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Solution &quot;</span> &lt;&lt; cas &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; f[n][<span class="number">2</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; f[n][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; f[n][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Load &quot;</span> &lt;&lt; cas &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="delta-wave"><a class="markdownIt-Anchor" href="#delta-wave"></a> Delta-wave</h2><h3 id="description-5"><a class="markdownIt-Anchor" href="#description-5"></a> Description</h3><p>A triangle field is numbered with successive integers in the way shown on the picture below.</p><p>The traveller needs to go from the cell with number M to the cell with number N. The traveller is able to enter the cell through cell edges only, he can not travel from cell to cell through vertices. The number of edges the traveller passes makes the length of the traveller’s route.</p><p>Write the program to determine the length of the shortest route connecting cells with numbers N and M.</p><h3 id="input-6"><a class="markdownIt-Anchor" href="#input-6"></a> Input</h3><p>Input contains two integer numbers M and N in the range from 1 to 1000000000 separated with space(s).</p><h3 id="output-6"><a class="markdownIt-Anchor" href="#output-6"></a> Output</h3><p>Output should contain the length of the shortest route.</p><h3 id="sample-input-5"><a class="markdownIt-Anchor" href="#sample-input-5"></a> Sample Input</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 12</span><br></pre></td></tr></table></figure><h3 id="sample-output-4"><a class="markdownIt-Anchor" href="#sample-output-4"></a> Sample Output</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="source-2"><a class="markdownIt-Anchor" href="#source-2"></a> Source</h3><p>Ural Collegiate Programming Contest 1998</p><p>问题链接：POJ2619 HDU1030 Delta-wave</p><h3 id="问题简述"><a class="markdownIt-Anchor" href="#问题简述"></a> 问题简述：</h3><blockquote><p>描述</p></blockquote><p>三角形字段按下图所示的方式用连续整数编号。</p><p>旅行者需要从编号为 M 的牢房转到编号为 N 的牢房。旅行者只能通过像元边缘进入像元，他不能通过顶点从一个像元移动到另一个像元。旅行者经过的边数决定了旅行者路线的长度。</p><p>编写程序以确定连接数字 N 和 M 的单元格的最短路径的长度。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/497edf2dedf0468b98f28d405632a828~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=310&amp;h=380&amp;s=32593&amp;e=png&amp;b=fefefe" alt="image.png" /></p><blockquote><p>输入</p></blockquote><p>输入包含两个整数 M 和 N，范围为 1 到 1000000000，用空格分隔。</p><blockquote><p>输出</p></blockquote><p>输出应包含最短路径的长度。</p><p>问题分析：</p><p>这是一个数学题，需要找出计算规律。</p><p>要想算出m到n的距离，需要从一个地方按行走、按左下方向走和按右下方向走，把这三个距离都加起来就得到了距离。</p><p>程序说明：</p><p>程序中的数组start[]和dest[]分别用于存储各行的起始值和终止值，然后搜索计算即可。</p><p>上述这两个数组最大需要多大，可以通过条件编译语句先算一下。</p><p>题记：（略）</p><p>参考链接：（略）</p><p>AC的C++语言程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* POJ2619 HDU1030 Delta-wave */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//#define DEBUG</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N1 = <span class="number">32000</span>;</span><br><span class="line"><span class="type">int</span> start[N1], dest[N1];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, j=<span class="number">1</span>; ;i+=<span class="number">2</span>, j++)</span><br><span class="line">        &#123;</span><br><span class="line">            start[j] = t;</span><br><span class="line">            dest[j] = (t += i) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(t &gt; N) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;N2=%d\n&quot;</span>, j);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; ;i++)</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= dest[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> m, n, ans;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n)==<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="type">int</span> mline = <span class="built_in">find</span>(m);</span><br><span class="line">        <span class="type">int</span> nline = <span class="built_in">find</span>(n);</span><br><span class="line">        ans = <span class="built_in">abs</span>(nline - mline) +</span><br><span class="line">                <span class="built_in">abs</span>((n - start[nline]) / <span class="number">2</span> - (m-start[mline]) / <span class="number">2</span>) +</span><br><span class="line">                <span class="built_in">abs</span>((dest[nline] - n) / <span class="number">2</span> - (dest[mline] - m) / <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu入门</title>
      <link href="/2023/10/06/Ubuntu%E5%85%A5%E9%97%A8/"/>
      <url>/2023/10/06/Ubuntu%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="配置文件"><a class="markdownIt-Anchor" href="#配置文件"></a> 配置文件</h2><p>普通用户获取root权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br></pre></td></tr></table></figure><p>此命令之后需要输入root密码<br />由于root密码为空，需要进行设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记</title>
      <link href="/2023/09/23/%E8%A7%A3%E5%86%B3Clion%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
      <url>/2023/09/23/%E8%A7%A3%E5%86%B3Clion%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>CLion乱码问题</p><p><img src="image.png" alt="Alt text" /></p><p>方法一<br />打开 File → Settings…：<br /><img src="image-1.png" alt="Alt text" /></p><p>选择 Editor，再选中 File Encodings：<br /><img src="image-2.png" alt="Alt text" /></p><p>调一下UTF-8，完成设置，然后点OK：<br /><img src="image-3.png" alt="Alt text" /></p><p>底部还有UTF-8：</p><p><img src="image-4.png" alt="Alt text" /><br />改成GBK：</p><p><img src="image-5.png" alt="Alt text" /><br />还有个弹窗，点Convert即可完成设置。</p><p>重新运行：<br /><img src="image-6.png" alt="Alt text" /></p><p>方法二<br />评论区有读者提到，每个文件都改是不是不好，所以本文于2022.04.21更新方法二，不需要改文件GBK。</p><p>文件是UTF-8格式，对于CLion命令行输出中文乱码的问题，解决方法是输入<code>Ctrl+Shift+Alt+/</code>：</p><p><img src="image-7.png" alt="Alt text" /></p><p>修改后即可在命令行看到正确不乱码的输出！<br />————————————————<br />本文为CSDN博主「星拱北辰」<br />原文链接：<a href="https://blog.csdn.net/weixin_43896318/article/details/104700306">https://blog.csdn.net/weixin_43896318/article/details/104700306</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Clion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记</title>
      <link href="/2023/09/13/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/13/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<hr /><h2 id="theme-vue-prohighlight-mono-blue"><a class="markdownIt-Anchor" href="#theme-vue-prohighlight-mono-blue"></a> theme: vue-pro<br />highlight: mono-blue</h2><p>本文档依据中国MOOC<a href="https://www.icourse163.org/course/PKU-1002029030">程序设计与算法（三）C++面向对象程序设计</a>撰写</p><hr /><h1 id="第一章从c到c"><a class="markdownIt-Anchor" href="#第一章从c到c"></a> 第一章从C到C++</h1><h2 id="类和对象的基本概念与用法1"><a class="markdownIt-Anchor" href="#类和对象的基本概念与用法1"></a> 类和对象的基本概念与用法(1)</h2><blockquote><p>对象的内存分配：成员函数不被包括在对象的内存吗？</p></blockquote><h1 id="第二章-类和对象基础"><a class="markdownIt-Anchor" href="#第二章-类和对象基础"></a> 第二章 类和对象基础</h1><h2 id="1类和对象的基本概念2"><a class="markdownIt-Anchor" href="#1类和对象的基本概念2"></a> 1.类和对象的基本概念(2)</h2><blockquote><p>question1</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设A是一个类的名字，下面的程序片段会调用类A的析构函数几次？ 答案：3次</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A * p = <span class="keyword">new</span> A[<span class="number">2</span>];</span><br><span class="line">A * p2 = <span class="keyword">new</span> A;</span><br><span class="line">A a;</span><br><span class="line"><span class="keyword">delete</span> [] p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不能访问私有成员变量？</p></blockquote><h2 id="2-构造函数"><a class="markdownIt-Anchor" href="#2-构造函数"></a> 2. 构造函数</h2><blockquote><p>对象所占用的存储空间是不是也是构造函数分配的？</p><p>answer：对象函数是在对象已经占用存储空间以后，在对象存储空间中做初始化的操作</p></blockquote><blockquote><p>对象一定有构造函数，如果定义类的时候没有写构造函数，则编译器生成个默认的无参数的构造函数</p><ul><li>默认构造函数无参数，不做任何操作</li></ul></blockquote><p>构造函数在数组中的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Test</span>( <span class="type">int</span> n)&#123;&#125;<span class="comment">//(1)</span></span><br><span class="line">        <span class="built_in">Test</span>( <span class="type">int</span> n, <span class="type">int</span> m) &#123;&#125;<span class="comment">//(2)</span></span><br><span class="line">        <span class="built_in">Test</span>()&#123;&#125;<span class="comment">//(3)</span></span><br><span class="line">&#125;;</span><br><span class="line">Test array1[<span class="number">3</span>]= &#123; <span class="number">1</span>, <span class="built_in">Test</span>(<span class="number">1</span>,<span class="number">2</span>)&#125;;<span class="comment">//三个元素分别用(1),(2),(3)初始化</span></span><br><span class="line">Test array2[<span class="number">3</span>]= &#123; <span class="built_in">Test</span>(<span class="number">2</span>,<span class="number">3</span>), <span class="built_in">Test</span>(<span class="number">1</span>,<span class="number">2</span>),<span class="number">1</span>&#125;;(/三个元素分别用(<span class="number">2</span>),(<span class="number">2</span>), (<span class="number">1</span>)初始化</span><br><span class="line">Test * pArray[<span class="number">3</span>]= &#123; <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">4</span>), <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">1</span>,<span class="number">2</span>)&#125;<span class="comment">//两个元素分别用(1),(2)初始化</span></span><br></pre></td></tr></table></figure><p>对于代码中的 <code>Test array1[3] = &#123;1, Test(1,2)&#125;</code>，它创建了一个名为 <code>array1</code> 的 <code>Test</code> 类型的数组，并初始化了其中的元素。</p><p><code>Test(1,2)</code> 是以参数值 <code>1</code> 和 <code>2</code> 调用 <code>Test</code> 类的构造函数 <code>(2)</code> 来创建一个临时对象。这个临时对象将被用来初始化 <code>array1</code> 中的第二个元素。</p><p>因此，<code>Test(1,2)</code> 将调用 <code>(2)</code> 构造函数，而不是其他的构造函数 <code>(1)</code> 或 <code>(3)</code>。</p><h2 id="3复制拷贝构造函数"><a class="markdownIt-Anchor" href="#3复制拷贝构造函数"></a> 3.复制（拷贝）构造函数</h2><p><strong>一. 什么是拷贝构造函数</strong><br />首先对于普通类型的对象来说，它们之间的复制是很简单的，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  <span class="type">int</span> a = <span class="number">100</span>;  </span><br><span class="line"><span class="number">1.</span>  <span class="type">int</span> b = a;   </span><br></pre></td></tr></table></figure><p>而类对象与普通对象不同，类对象内部结构一般较为复杂，存在各种成员变量。<br />下面看一个类对象拷贝的简单例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CExample</span> &#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    　<span class="type">int</span> a;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">      <span class="comment">//构造函数  </span></span><br><span class="line">    　<span class="built_in">CExample</span>(<span class="type">int</span> b)  </span><br><span class="line">    　&#123; a = b;&#125;  </span><br><span class="line">  </span><br><span class="line">      <span class="comment">//一般函数  </span></span><br><span class="line">    　<span class="function"><span class="type">void</span> <span class="title">Show</span> <span class="params">()</span>  </span></span><br><span class="line"><span class="function">    　</span>&#123;  </span><br><span class="line">        cout&lt;&lt;a&lt;&lt;endl;  </span><br><span class="line">      &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    　<span class="function">CExample <span class="title">A</span><span class="params">(<span class="number">100</span>)</span></span>;  </span><br><span class="line">    　CExample B = A; <span class="comment">//注意这里的对象初始化要调用拷贝构造函数，而非赋值  </span></span><br><span class="line">    　 B.<span class="built_in">Show</span> ();  </span><br><span class="line">    　<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>运行程序，屏幕输出100。从以上代码的运行结果可以看出，系统为对象 B 分配了内存并完成了与对象 A 的复制过程。就类对象而言，相同类型的类对象是通过拷贝构造函数来完成整个复制过程的。</p><p>下面举例说明拷贝构造函数的工作过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CExample</span> &#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> a;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="comment">//构造函数  </span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="type">int</span> b)  </span><br><span class="line">    &#123; a = b;&#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//拷贝构造函数  </span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="type">const</span> CExample&amp; C)  </span><br><span class="line">    &#123;  </span><br><span class="line">        a = C.a;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//一般函数  </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span> <span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout&lt;&lt;a&lt;&lt;endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">CExample <span class="title">A</span><span class="params">(<span class="number">100</span>)</span></span>;  </span><br><span class="line">    CExample B = A; <span class="comment">// CExample B(A); 也是一样的  </span></span><br><span class="line">     B.<span class="built_in">Show</span> ();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>CExample(const CExample&amp; C)　就是我们自定义的拷贝构造函数。可见，拷贝构造函数是一种<strong>特殊的</strong> <strong>构造函数</strong>，函数的名称必须和类名称一致，它必须的一个参数是本类型的一个<strong>引用变量</strong> 。</p><blockquote><p>在代码中，<code>a = C.a;</code> 是拷贝构造函数 <code>CExample(const CExample&amp; C)</code> 中的一行代码。它用于将另一个 <code>CExample</code> 类型对象 <code>C</code> 的私有成员变量 <code>a</code> 的值复制给当前对象的私有成员变量 <code>a</code>。</p><p>这行代码的作用是将 <code>C</code> 对象的 <code>a</code> 的值赋给当前对象的 <code>a</code>。通过这样的赋值操作，当前对象的 <code>a</code> 成员变量将具有与 <code>C</code> 对象相同的值。</p><p>需要注意的是，由于拷贝构造函数是通过传递参数（引用）来初始化对象的，因此可以访问 <code>C</code> 对象的私有成员变量。并且拷贝构造函数通常用于创建新对象并复制另一个对象的状态。</p></blockquote><h3 id="构造函数和拷贝构造函数的区别"><a class="markdownIt-Anchor" href="#构造函数和拷贝构造函数的区别"></a> 构造函数和拷贝构造函数的区别</h3><p>构造函数和拷贝构造函数是 C++ 中的两种特殊成员函数，它们在对象创建和复制时起着不同的作用。</p><ol><li><p>构造函数（Constructor）：</p><ul><li>构造函数是类中的一种特殊函数，在创建对象时被调用。</li><li>构造函数用于初始化对象的状态和数据成员。</li><li>构造函数的名称与类名相同，没有返回类型（包括 void）。</li><li>可以重载构造函数，根据参数的类型和数量，可以有多个构造函数。</li><li>在对象创建时，会自动调用适当的构造函数。</li></ul></li><li><p>拷贝构造函数（Copy Constructor）：</p><ul><li><p>拷贝构造函数是一种特殊的构造函数，用于创建一个新对象并将现有对象的值复制到新对象中。</p></li><li><p>拷贝构造函数在以下情况下被调用：</p><ul><li>通过用已存在的对象初始化新对象时。</li><li>将对象作为函数参数按值传递时。</li><li>在函数中返回对象时以值的形式返回。</li></ul></li><li><p>拷贝构造函数的参数是另一个相同类型的对象的引用。</p></li><li><p>如果没有提供自定义的拷贝构造函数，编译器会生成一个默认的拷贝构造函数。</p></li></ul></li></ol><p>区别：</p><ul><li>构造函数用于创建对象并初始化其状态，而拷贝构造函数则用于创建新对象并复制现有对象的值。</li><li>构造函数没有特定的参数类型，而拷贝构造函数的参数类型是同一类的引用。</li><li>构造函数在对象创建时自动调用，而拷贝构造函数在特定情况下（如对象初始化、按值传递参数和以值返回对象）才会被调用。</li><li>如果没有提供自定义的拷贝构造函数，编译器会生成一个默认的拷贝构造函数，但对于构造函数没有默认的实现。</li><li>通过适当地组合构造函数和拷贝构造函数，可以实现对象的初始化和复制操作。</li></ul><h2 id="41类型转换构造函数"><a class="markdownIt-Anchor" href="#41类型转换构造函数"></a> 4.1类型转换构造函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    <span class="built_in">Complex</span>( <span class="type">int</span> i) &#123;<span class="comment">//类型转换构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;IntConstructor calledn &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    real = i; imag = 0;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">Complex(double r,double i) &#123;real = r; imag = i;&#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">int main ()</span></span><br><span class="line"><span class="string">&#123;Complexc1(7,8);</span></span><br><span class="line"><span class="string">Complexc2 = 12;</span></span><br><span class="line"><span class="string">c1 = 9; // 9被自动转换成一个临时complex对象</span></span><br><span class="line"><span class="string">c1.imag &lt;&lt; endlcout &lt;&lt; c1.real &lt;&lt;endl;</span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>编译器会把9转换为一个临时对象，再把这个对象的值赋给c1。而不是把9转换为c1</p><h2 id="42-析构函数"><a class="markdownIt-Anchor" href="#42-析构函数"></a> 4.2 析构函数</h2><p>析构函数（Destructor）是一种特殊的类成员函数，它在对象生命周期结束时自动被调用，用于进行对象的清理工作和资源释放。</p><p>析构函数执行的时机是在以下情况下：</p><ol><li>当对象的作用域结束时，比如一个局部对象在离开其定义的作用域时，该对象的析构函数会被调用。</li><li>当对象以动态方式分配内存，通过 <code>new</code> 运算符创建时，需要手动使用 <code>delete</code> 运算符释放内存时，会显式调用对象的析构函数。</li><li>对象被销毁时，比如当一个对象是另一个对象的成员变量，而该容器对象被销毁时，包含的成员对象的析构函数会被调用。</li><li>对象从容器中移除或销毁时，比如当一个对象从容器（如数组、链表等）中删除或销毁时，被删除或销毁的对象的析构函数将被调用。</li></ol><p>需要注意的是：</p><ul><li>如果没有显式定义析构函数，编译器会生成默认的析构函数，它执行对象的默认清理操作。</li><li>析构函数不接受任何参数，且没有返回值。</li><li>在对象的析构函数中，可以释放在对象生命周期中分配的资源，例如释放动态分配的内存、关闭文件或释放其他外部资源。</li></ul><p>总之，对象的析构函数在对象生命周期结束时自动被调用，用于清理对象的资源和执行必要的清理操作。</p><blockquote><p>使用new创建的话需要手动delete吗？不会自动执行析构函数吗?</p></blockquote><p>是的，当你使用 <code>new</code> 运算符动态创建对象时，需要手动使用 <code>delete</code> 运算符来释放对象及其占用的内存。因为动态创建的对象不会自动执行析构函数和释放内存。</p><p>当使用 <code>new</code> 创建对象时，它会调用对象的构造函数进行初始化，但不会自动调用析构函数来销毁对象。同样，使用 <code>delete</code> 销毁对象时，它会调用对象的析构函数来清理资源并释放内存。</p><p>以下是一个示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class Ctest&#123;</span><br><span class="line">    pubilc:</span><br><span class="line">    ~<span class="built_in">Ctest</span>() &#123;cout&lt;&lt;<span class="string">&quot;destructor called&quot;</span> &lt;&lt;endl ; &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">ctest * pTest;</span><br><span class="line">pTest = <span class="keyword">new</span> Ctest;<span class="comment">//构造函数调用</span></span><br><span class="line"><span class="keyword">delete</span> pTest;/析构函数调用</span><br><span class="line">----------------------------------------</span><br><span class="line">pTest = <span class="keyword">new</span> Ctest[<span class="number">3</span>];<span class="comment">//构造函数调用3次</span></span><br><span class="line"><span class="keyword">delete</span> [] pTest;/析构函数调用<span class="number">3</span>次</span><br></pre></td></tr></table></figure><blockquote><p>✨若new-—个对象数组,那么用delete释放时应该写[ ].否则只delete一个对象(调用一次析构函数)</p></blockquote><blockquote><p>需要手动delete操作的原理是什么？</p></blockquote><p>使用 <code>new</code> 创建对象时，内存会在堆（Heap）上进行分配，而不是栈（Stack）。在堆上分配的内存不会自动被释放，需要手动释放。</p><p>原因如下：</p><ol><li><p>自由存储区域（Heap）和栈（Stack）的管理机制不同：</p><ul><li>栈是由编译器自动管理的一块内存区域，用于存储局部变量和函数调用的上下文。栈的分配和释放是由编译器自动完成的，且遵循先进后出的原则。</li><li>堆是由开发者手动管理的一块内存区域，用于存储动态分配的对象。堆上的内存分配和释放需要显式地由开发者指定，以确保更灵活和精确的控制。</li></ul></li><li><p><code>new</code> 运算符返回的是指向对象的指针：</p><ul><li>使用 <code>new</code> 创建对象时，它会在堆上分配一块内存，并调用对象的构造函数进行初始化。然后，<code>new</code> 运算符会返回指向分配对象的指针。</li><li>由于返回的是指针，编译器无法推断何时应该释放对应的内存区域，因此需要开发者手动调用 <code>delete</code> 运算符来显式释放内存。</li></ul></li><li><p>C++ 的设计哲学：</p><ul><li>C++ 的设计理念之一是“你所使用的资源就是你所负责的资源”。这意味着程序员有更多的控制权和灵活性，可以精确地控制对象的生命周期和内存的分配和释放。</li></ul></li></ol><p>总结起来，<code>new</code> 创建对象需要手动调用 <code>delete</code> 运算符释放内存，是因为堆上分配的内存不会自动释放，而 C++ 的设计使得开发者能够更灵活地管理对象的生命周期和内存的分配。这样可以避免不必要的内存消耗，并提供更高的灵活性和控制性。</p><h3 id="析构函数在对象作为函数返回值返回后被调用"><a class="markdownIt-Anchor" href="#析构函数在对象作为函数返回值返回后被调用"></a> 析构函数在对象作为函数返回值返回后被调用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMyclass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">CMyclass</span>() &#123; cout &lt;&lt;<span class="string">&quot;destructor&quot;</span> &lt;endl ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">CMyclass obj;</span><br><span class="line"><span class="function">CMyclass <span class="title">fun</span> <span class="params">(CMyclass sobj )</span> </span>&#123;<span class="comment">//参数对象消亡也会导致析</span></span><br><span class="line">                                <span class="comment">//构函数被调用</span></span><br><span class="line">    <span class="keyword">return</span> sobj;<span class="comment">//函数调用返回时生成临时对象返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    obj = <span class="built_in">fun</span> (obj);<span class="comment">//函数调用的返回值（临时对象）被</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;<span class="comment">//用过后,该临时对象析构函数被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出:</p><p>destructor<br />destructor<br />destructor</p></blockquote><h2 id="5-构造函数析构函数调用时机"><a class="markdownIt-Anchor" href="#5-构造函数析构函数调用时机"></a> 5. 构造函数析构函数调用时机</h2><p>复制构造函数在不同编译器下的表现</p><h1 id="第三章-类和对象提高"><a class="markdownIt-Anchor" href="#第三章-类和对象提高"></a> 第三章 类和对象提高</h1><h2 id="1-this指针"><a class="markdownIt-Anchor" href="#1-this指针"></a> 1. this指针</h2><p>this指针作用</p><blockquote><p><code>非静态</code>成员函数中可以直接使用this来代表指向该函数作用的对象的指针。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">double</span> real, imag;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;cout &lt;&lt; real &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; imag ; &#125;</span><br><span class="line">        <span class="built_in">Complex</span>(<span class="type">double</span> r,<span class="type">double</span> i):<span class="built_in">real</span>(r),<span class="built_in">imag</span>(i)</span><br><span class="line">        &#123;   &#125;</span><br><span class="line">        <span class="function">Complex <span class="title">AddOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;real ++;<span class="comment">//等价于real ++;</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">Print</span>();/等价于 Print</span><br><span class="line">            <span class="keyword">return</span>*<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span>,<span class="title">c2</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    c2 =c1.<span class="built_in">AddOne</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>this指针和静态成员函数<br />静态成员函数中不能使用 this 指针!<br />因为静态成员函数并不具体作用于某个对象!<br />因此，静态成员函数的真实的参数的个数，就是程序中写出的参数个数!</p></blockquote><p><strong>1. this</strong> <strong>指针的用处</strong> <strong>:</strong></p><p>一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。 　　例如，调用date.SetMonth(9) &lt;===&gt; SetMonth(&amp;date, 9)，this帮助完成了这一转换 .</p><p><strong>2. this</strong> <strong>指针的使用</strong> <strong>:</strong></p><p>一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；另外一种情况是当参数与成员变量名相同时，如this-&gt;n = n （不能写成n = n）。</p><p><strong>3. this</strong> <strong>指针程序示例</strong> <strong>:</strong></p><p>this指针存在于类的成员函数中,指向被调用函数所在的类实例的地址。 　　根据以下程序来说明this指针</p><p>#include</p><p>class Point 　　{ 　　int x, y;</p><p>public:</p><p>Point(int a, int b) { x=a; y=b;}</p><p>void MovePoint( int a, int b){ x+=a; y+=b;}</p><p>void print(){ cout&lt;&lt;“x=”&lt;</p><p>};</p><p>void main( ) 　　{</p><p>Point point1( 10,10);</p><p>point1.MovePoint(2,2);</p><p>point1.print( );</p><p>}</p><p>当对象point1调用MovePoint(2,2)函数时，即将point1对象的地址传递给了this指针。</p><p>MovePoint函数的原型应该是 void MovePoint( Point *this, int a, int b);第一个参数是指向该类对象的一个指针，我们在定义成员函数时没看见是因为这个参数在类中是隐含的。这样point1的地址传递给了this，所以在MovePoint函数中便显式的写成：</p><p>void MovePoint(int a, int b) { this-&gt;x +=a; this-&gt; y+= b;} 　　即可以知道，point1调用该函数后，也就是point1的数据成员被调用并更新了值。 　　即该函数过程可写成 point1.x+= a; point1. y + = b;</p><p><strong>4.</strong> <strong>关于</strong> <strong>this</strong> <strong>指针的一个经典回答</strong> <strong>:</strong></p><p>当你进入一个房子后，</p><p>你可以看见桌子、椅子、地板等，</p><p>但是房子你是看不到全貌了。</p><p>对于一个类的实例来说，</p><p>你可以看到它的成员函数、成员变量，</p><p>但是实例本身呢？</p><p>this是一个指针，它时时刻刻指向你这个实例本身</p><p></p><p><strong>5.</strong> <strong>类的</strong> <strong>this</strong> <strong>指针有以下特点：</strong>****</p><p><strong>（</strong> <strong>1</strong> <strong>）</strong> <strong>this</strong> <strong>只能在成员函数中使用。</strong>****</p><p>全局函数、静态函数都不能使用this.</p><p>实际上，成员函数默认第一个参数为T * const this。</p><p>如：</p><p>class A</p><p>{</p><p>public:</p><p>int func(int p)</p><p>{</p><p>}</p><p>};</p><p><strong>其中，</strong> <strong>func</strong> <strong>的原型在编译器看来应该是：</strong>****</p><p>** int func(A * const this,int p);**</p><p><strong>（</strong> <strong>2</strong> <strong>）由此可见，</strong> <strong>this</strong> <strong>在成员函数的开始前构造，在成员函数的结束后清除。</strong>****</p><p>这个生命周期同任何一个函数的参数是一样的，没有任何区别。</p><p>当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：</p><p>A a;</p><p>a.func(10);</p><p>此处，编译器将会编译成：</p><p>A::func(&amp;a,10);</p><p>看起来和静态函数没差别，对吗？<strong>不过，区别还是有的。编译器通常会对****this</strong> <strong>指针做一些优化，</strong> 因此，this指针的传递效率比较高–如VC通常是通过ecx寄存器传递this参数的。</p><p><strong>（</strong> <strong>3</strong> <strong>）几个</strong> <strong>this</strong> <strong>指针的易混问题。</strong>****</p><p><strong>A. this</strong> <strong>指针是什么时候创建的？</strong>****</p><p>this在成员函数的开始执行前构造，在成员的执行结束后清除。</p><p>但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用 TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式 创建对象的话，在堆里分配内存，new操作符通过eax返回分配 的地址，然后设置给指针变量。之后去调 用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面怎么处理请 看上面的回答。</p><p><strong>B. this</strong> <strong>指针存放在何处？堆、栈、全局变量，还是其他？</strong>****</p><p>this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级 别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内 存中，它们并不是和高级语言变量对应的。</p><p><strong>C. this</strong> <strong>指针是如何传递类中的函数的？</strong> 绑定？还是在函数参数的首参数就是this指针？那么，this指针 又是如何找到“类实例后函数的”？</p><p>大多数编译器通过ecx寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。</p><p>在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的。</p><p><strong>D. this</strong> <strong>指针是如何访问类中的变量的？</strong>****</p><p>如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，就很容易理解这个问题了。</p><p></p><p><strong>在</strong> <strong>C++</strong> <strong>中</strong> <strong>,</strong> <strong>类和结构是只有一个区别的：类的成员默认是</strong> <strong>private</strong> <strong>，而结构是</strong> <strong>public</strong> <strong>。</strong>****</p><p><strong>this</strong> <strong>是类的指针，如果换成结构，那</strong> <strong>this</strong> <strong>就是结构的指针了。</strong>****</p><p></p><p><strong>E.</strong> <strong>我们只有获得一个对象后，才能通过对象使用</strong> <strong>this</strong> <strong>指针。</strong> 如果我们知道一个对象this指针的位置，可以直接使用吗？</p><p>this指针只有在成员函数中才有定义。因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&amp;this获得），也可以直接使用它。</p><p><strong>F.</strong> <strong>每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</strong></p><p>普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译器能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。</p><h2 id="2静态成员变量"><a class="markdownIt-Anchor" href="#2静态成员变量"></a> 2.静态成员变量</h2><blockquote><p>普通成员变量每个对象有各自的一份，而静态成员变量一共就一份．<code>为所有对象共享</code>。</p><p>普通成员函数必须具体作用于某个对象，而静态成员函数并<code>不具体作用于某个对象</code>。</p><p>因此静态成员<code>不需要通过对象</code>就能访问。</p></blockquote><p>如何访问静态成员</p><ol><li>类名::成员名<br />CRectangle::PrintTotal();</li><li>对象名.成员名<br />CRectangle r; r.PrintTotal();</li><li>指针-&gt;成员名<br />CRectangle * p = &amp;r; p-&gt;PrintTotal();</li><li>引用.成员名<br />CRectangle &amp;ref = r int n = ref nTotalNuimber:</li></ol><blockquote><p><strong>静态成员变量本质上是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在。</strong></p><p><strong>静态成员函数本质上是全局函数。</strong></p><p><strong>设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CRectanglel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:<span class="type">int</span> w, h,</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> nTotalArea;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> nTotalNumber,</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">CRectangle</span>( <span class="type">int</span> w_,<span class="type">int</span> h_);</span><br><span class="line">        ~<span class="built_in">CRectangle</span>();</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">PrintTotal</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">CRectangle::<span class="built_in">CRectangle</span>(<span class="type">int</span> w_.<span class="type">int</span> h_)</span><br><span class="line">&#123;</span><br><span class="line">    W=W_;h =h_;</span><br><span class="line">    nTotalNumber ++;</span><br><span class="line">    nTotalArea +=w * h;</span><br><span class="line">&#125;</span><br><span class="line">CRectangle:~<span class="built_in">CRectangle</span>()</span><br><span class="line">&#123;</span><br><span class="line">    nTotalNumber --;</span><br><span class="line">    nTotalArea -= w * h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CRectangle::PrintTotal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; nTotalNumber &lt;&lt; <span class="string">&quot;,&quot;</span>&lt;&lt;nTotalArea&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态成员变量的声明和初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> CRectangle::nTotalNumber = <span class="number">0</span>;  </span><br><span class="line"><span class="type">int</span> CRectangle:nTotalArea = <span class="number">0</span>;<span class="comment">//见下</span></span><br></pre></td></tr></table></figure><p><strong>//必须在定义类的文件中对静态成员变量进行一次说明/或初始化。否则编译能通过，链接不能通过。</strong></p><blockquote><p>?静态成员函数能访问全局变量吗？静态全局函数能访问全局变量吗？</p></blockquote><blockquote><p>在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数(会访问非静态成员变量)。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CRectangle::PrintTotal</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt;w &lt;&lt;<span class="string">&quot;,&quot;</span> &lt;&lt;nTotalNumber &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt;nTotalArea &lt;&lt;endl;<span class="comment">//wrong</span></span><br><span class="line">&#125;</span><br><span class="line">CRetangle:<span class="built_in">PrintTotal</span>();/解释不通，w到底是属于那个对象的?</span><br></pre></td></tr></table></figure><p>✨<strong>由于复制构造函数会造成临时对象的生成，同时不经过复制构造函数，只在变量作用域结束时经过析构函数，会造成错误的输出。</strong></p><p><em><strong>eg.</strong></em> 在使用CRectangle类时，有时会调用复制构造函数生成临时的隐藏的CRectangle对象</p><blockquote><p>解决办法:为CRectangle类写一个复制构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;CRectangle :: <span class="built_in">CRectangle</span>(CRectangle &amp; r )</span><br><span class="line">&gt;&#123;</span><br><span class="line">  w=r.W:; h =r.h;</span><br><span class="line">  nTotfalNumber ++;</span><br><span class="line">  nTotalArea tw * h;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="3-成员对象和封闭类"><a class="markdownIt-Anchor" href="#3-成员对象和封闭类"></a> 3. 成员对象和封闭类</h2><blockquote><p>⛔ 封闭类构造函数和成员的构造函数？</p></blockquote><p>任何生成封闭类对象的语句，都要让编译器明白，对象中的成员对象,是如何初始化的。<br />具体的做法就是:通过封闭类的构造函数的初始化列表。<br />成员对象初始化列表中的参数可以是任意复杂的表达式，可以包括函数，变量，只要表达式中的函数或变量有定义就行。</p><h3 id="封闭类构造函数和析构函数的执行顺序"><a class="markdownIt-Anchor" href="#封闭类构造函数和析构函数的执行顺序"></a> 封闭类构造函数和析构函数的执行顺序</h3><ul><li>封闭类对象生成时，先执行所有对象成员的构造函数，然后才执行封闭类的构造函数。</li><li>对象成员的构造函数调用次序和对象成员在类中的说明次序一致与它们在成员初始化列表中出现的次序无关。</li><li>当封闭类的对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数。<strong>次序和构造函数的调用次序相反。</strong></li></ul><h2 id="4-常量对象-常量成员函数"><a class="markdownIt-Anchor" href="#4-常量对象-常量成员函数"></a> 4. 常量对象、常量成员函数</h2><h3 id="常量对象"><a class="markdownIt-Anchor" href="#常量对象"></a> 常量对象</h3><blockquote><p>如果不希望某个对象的值被改变，则定义该对象的时候可以在前面加const关键字。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> :</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetValue</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> Demo Obi: <span class="comment">// 常量对象</span></span><br></pre></td></tr></table></figure><h3 id="常量成员函数"><a class="markdownIt-Anchor" href="#常量成员函数"></a> 常量成员函数</h3><blockquote><p>在类的成员函数说明后面可以加<code>const</code>关键字，则该成员函数成为<code>常量成员函数</code>。<br />常量成员函数执行期间<code>不应修改其所作用的对象因此，在常量成员函数中不能修改成员变量的值(</code>静态成员变量除外<code>)，也不能调用同类的非常量成员函数(</code>静态成员函数除外`)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> GetValue0) <span class="type">const</span>:</span><br></pre></td></tr></table></figure><blockquote><p>✨常量对象上面不会执行非常量成员函数，编译器不会分析常量对象调用的函数是否会修改对象的值，而是直接编译失败</p></blockquote><h3 id="常量成员函数的重载"><a class="markdownIt-Anchor" href="#常量成员函数的重载"></a> 常量成员函数的重载</h3><blockquote><p>两个成员函数，名字和参数表都一样，但是一个是const,一个不是，算重载。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> :</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">CTest</span>() &#123; n= <span class="number">1</span> ; &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> n ; &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">( <span class="keyword">return</span> <span class="number">2</span>*n ; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> main( &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> CTest objTestl;</span></span></span><br><span class="line"><span class="params"><span class="function">    CTest objTest2;</span></span></span><br><span class="line"><span class="params"><span class="function">    cout &lt;&lt; objTest <span class="number">1.</span>GetValue() &lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;objTest2.GetValue() ;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">return</span> O;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure><h3 id="常引用"><a class="markdownIt-Anchor" href="#常引用"></a> 常引用</h3><blockquote><p>✨对象作为函数的参数时，生成该参数需要调用复制构造函数，效率比较低。用指针作参数，代码又不好看，如何解决?</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以用对象的引用作为参数，如:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintfObj</span><span class="params">(Sample &amp; o)</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对象引用作为函数的参数有一定风险性，若函数中不小心修改了形参o，则实参也跟着变，这可能不是我们想要的。如何避免?</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以用对象的常引用作为参数，如:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintfObj</span><span class="params">( <span class="type">const</span> Sample &amp; Lo)</span></span>&#123;</span><br><span class="line">    ......<span class="comment">//这样函数中就能确保不会出现无意中更改o值的语句了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5友元"><a class="markdownIt-Anchor" href="#5友元"></a> 5.友元</h2><blockquote><p>⛔友元类之间的关系不能传递，不能继承。</p></blockquote><p>友元分为友元函数和友元类两种</p><ol><li>友元函数:一个类的友元函数可以访问该类的私有成员</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">    <span class="comment">// 类的定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ReturnType <span class="title">FunctionName</span><span class="params">(ParameterList)</span></span>; <span class="comment">// 友元函数的声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ReturnType <span class="title">FunctionName</span><span class="params">(ClassName::ParameterList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 友元函数的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在所在类中以 <code>friend ReturnType FunctionName(ParameterList); </code> 友元函数的声明的形式，声明的函数可以访问该类私有的成员变量；</p><ul><li><code>ClassName</code> 是要声明友元函数的类名。</li><li><code>ReturnType</code> 是友元函数的返回类型。</li><li><code>FunctionName</code> 是友元函数的名称。</li><li><code>ParameterList</code> 是友元函数的参数列表，可以包含类的对象或其他参数。</li></ul><p><em><strong>eg.</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CCar</span> ; <span class="comment">//提前声明 ccar类，以便后面的cDriver类使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDriver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">ModifyCar</span> <span class="params">( cCar * pCar)</span> </span>; <span class="comment">//改装汽车</span></span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCar</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">                <span class="type">int</span> price ;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">MostExpensiveCar</span><span class="params">( Ccar cars[l, <span class="type">int</span> total)</span></span>;<span class="comment">//声明友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> CDriver: :<span class="built_in">ModifyCar</span> (ccar * pCar) ;<span class="comment">//声明友元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> CDriver:: <span class="built_in">ModifyCar</span> ( CCar * pCar)</span><br><span class="line">&#123;</span><br><span class="line">    pCar-&gt;price += <span class="number">1000</span>; <span class="comment">//汽车改装后价值增加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MostExpensiveCar</span> <span class="params">( ccar cars[ ] ,<span class="type">int</span> total)</span><span class="comment">//求最贵汽车的价格</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmpMax = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = o; i &lt; total; ++i )</span><br><span class="line">        <span class="keyword">if</span>( cars[i].price &gt; tmpMax)</span><br><span class="line">            tmpMax = cars[i].price;</span><br><span class="line">    <span class="keyword">return</span> tmpMax ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>友元类:如果A是B的友元类，那么A的成员函数可以访问B的私有成员</li></ol><p>友元类是指一个类可以访问另一个类的私有成员和保护成员。当一个类被声明为另一个类的友元类时，它可以在其成员函数中直接访问该类的私有成员和保护成员。</p><p>友元类的声明方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">    <span class="comment">// 类的定义</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">FriendClassName</span>; <span class="comment">// 友元类的声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>ClassName</code> 是要声明友元类的类名。</li><li><code>FriendClassName</code> 是友元类的名称。</li></ul><p>通过将一个类声明为另一个类的友元类，被声明的类就能够访问友元类中的所有成员，包括私有成员和保护成员。</p><p><em><strong>eg.</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CCar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> price ;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">CDriver</span>; l/声明cDriver为友元类</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDriver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CCar myCar;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">ModifyCar</span> <span class="params">()</span></span>&#123;<span class="comment">//改装汽车</span></span><br><span class="line">            myCar.price += <span class="number">1000</span>; <span class="comment">//因cDriver是ccar的友元类，</span></span><br><span class="line">                                <span class="comment">//故此处可以访问其私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">int</span> main&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中定义了两个类 <code>CCar</code> 和 <code>CDriver</code>，并且在 <code>CCar</code> 类中声明了 <code>CDriver</code> 为友元类。这意味着 <code>CDriver</code> 类可以访问 <code>CCar</code> 类的私有成员和保护成员。</p><p>在 <code>CDriver</code> 类中，有一个 <code>CCar</code> 类型的对象 <code>myCar</code>。在 <code>ModifyCar</code> 成员函数中，它可以直接访问 <code>myCar</code> 的私有成员 <code>price</code>。因为 <code>CDriver</code> 是 <code>CCar</code> 的友元类，所以可以在 <code>ModifyCar</code> 函数中修改 <code>myCar</code> 的私有成员。</p><h1 id="第四章-运算符重载"><a class="markdownIt-Anchor" href="#第四章-运算符重载"></a> 第四章 运算符重载</h1><h2 id="1-运算符重载的基本概念"><a class="markdownIt-Anchor" href="#1-运算符重载的基本概念"></a> 1. 运算符重载的基本概念</h2><p>运算符重载的目的是:扩展C++中提供的运算符的适用范围，使之能作用于对象。</p><ul><li>重载为成员函数时，参数个数为运算符目数减一。</li><li>重载为普通函数时，参数个数为运算符目数。</li></ul><p><em><strong>eg</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real ,imag ;</span><br><span class="line">    <span class="built_in">Cormplex</span>( <span class="type">double</span> r = <span class="number">0.0</span>,<span class="type">double</span> i= <span class="number">0.0</span> ) : <span class="built_in">real</span>(r),<span class="built_in">imag</span>(i)&#123; &#125;</span><br><span class="line">    complex <span class="keyword">operator</span>-(<span class="type">const</span> complex &amp;c) ;</span><br><span class="line">&#125;;</span><br><span class="line">Complex <span class="keyword">operator</span>+( <span class="type">const</span> Complex &amp; a, <span class="type">const</span> Complex &amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>( a.real+b.real,a.imag+b.imag);<span class="comment">//返回一个临时对象</span></span><br><span class="line">&#125;</span><br><span class="line">Complex Complex :: <span class="keyword">operator</span>- (<span class="type">const</span> Complex &amp; c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span> (real - c .real, imag-c.imag); <span class="comment">//返回一个临时对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">a</span> <span class="params">(<span class="number">4</span>,<span class="number">4</span>)</span>,<span class="title">b</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span> ,c</span>;</span><br><span class="line">    c= a + b; <span class="comment">//等价于c=operator+(a,b) ;</span></span><br><span class="line">    cout&lt;&lt;c.real &lt;&lt;<span class="string">&quot;, &quot;</span> &lt;&lt;c.imag &lt;&lt;end</span><br><span class="line">    cout &lt;&lt;, (a-b).real &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt;(a-b) .imag &lt;&lt; endl;<span class="comment">//a-b等价于a. operator-(b)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">c= a + b ;等价于c=<span class="keyword">operator</span>+(a, b) ;</span><br><span class="line">a-b   等价于a.<span class="keyword">operator</span>-(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-赋值运算符的重载"><a class="markdownIt-Anchor" href="#2-赋值运算符的重载"></a> 2. 赋值运算符的重载</h2><p>在C++中，赋值运算符“=”只能重载为成员函数。</p><h3 id="浅拷贝和深拷贝"><a class="markdownIt-Anchor" href="#浅拷贝和深拷贝"></a> 浅拷贝和深拷贝</h3><h3 id="对-operator-返回值类型的讨论"><a class="markdownIt-Anchor" href="#对-operator-返回值类型的讨论"></a> 对 operator = 返回值类型的讨论</h3><p>void 好不好?<br />String 好不好?<br />为什么是 String&amp;<br /><strong>对运算符进行重载的时候，好的风格是应该尽量保留运算符原本的特性</strong><br />考虑:a=b=c;<br />和<br />(a=b)=c;//会修改a的值</p><blockquote><p>qustion:赋值运算符的返回值是等号左边的引用，a=b的返回值是a的引用？</p></blockquote><h1 id="第五章-继承"><a class="markdownIt-Anchor" href="#第五章-继承"></a> 第五章 继承</h1><h2 id="1-继承和派生的基本概念"><a class="markdownIt-Anchor" href="#1-继承和派生的基本概念"></a> 1. 继承和派生的基本概念</h2><ul><li>在派生类的各个成员函数中，不能访问基类中的private成员。</li></ul><h3 id="派生类的写法"><a class="markdownIt-Anchor" href="#派生类的写法"></a> 派生类的写法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名: <span class="keyword">public</span> 基类名</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="派生类对象的内存空间"><a class="markdownIt-Anchor" href="#派生类对象的内存空间"></a> 派生类对象的内存空间</h3><p>派生类对象的体积，等于基类对象的体积，再加上派生类对象自己的成员变量的体积。<strong>在派生类对象中，包含着基类对象</strong>，而且基类对象的存储位置位于派生类对象新增的成员变量<strong>之前</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">classCBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v1, v2;</span><br><span class="line">&#125;</span><br><span class="line">classCDerived:<span class="keyword">public</span> CBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v3 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/146a128599714cf3a3ee8da881eb1f77~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=735&amp;h=308&amp;s=68248&amp;e=png&amp;b=fbf9fb" alt="1695133002079.png" /></p><h2 id="2-继承关系和复合关系"><a class="markdownIt-Anchor" href="#2-继承关系和复合关系"></a> 2. 继承关系和复合关系</h2><p>继承：<strong>“是”</strong> 关系。</p><ul><li>基类 A，B是基类A的派生类</li><li>逻辑上要求:“一个B对象也是一个A对象”</li></ul><p>复合:“<strong>有</strong>”关系</p><ul><li>类C中“有”成员变量k，k是类D的对象，则C和D是复合关系</li><li>一般逻辑上要求:“D对象是C对象的固有属性或组成部</li></ul><h3 id="复合关系的使用"><a class="markdownIt-Anchor" href="#复合关系的使用"></a> 复合关系的使用</h3><p>正确的写法:<br />为“狗”类设一个“业主”类的对象指针;<br />为“业主”类设一个“狗”类的对象指针数组。</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e97ea2e9c79442ebc2af3000da9f1e0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=912&h=399&s=250734&e=png&b=f9f7f9" alt="1695184236782.png" width="70%" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMaster</span>: <span class="comment">//CMaster必须提前声明，不能先写CMaster类后写Cdog类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDog</span> </span><br><span class="line">&#123;</span><br><span class="line">    CMaster* pm;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMaster</span> </span><br><span class="line">&#123;</span><br><span class="line">    CDog*dogs[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3覆盖和保护成员"><a class="markdownIt-Anchor" href="#3覆盖和保护成员"></a> 3.覆盖和保护成员</h2><h3 id="覆盖"><a class="markdownIt-Anchor" href="#覆盖"></a> 覆盖</h3><p>派生类可以定义一个和基类成员同名的成员，这叫覆盖。在派生类中访问这类成员时，<strong>缺省</strong>的情况是访问派生类中定义的成员。要在派生类中访问由基类定义的同名成员时，要使用作用域符号<code>::</code>。</p><h3 id="基类和派生类有同名成员的情况"><a class="markdownIt-Anchor" href="#基类和派生类有同名成员的情况"></a> 基类和派生类有同名成员的情况:</h3><p><em><strong>eg</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span> :<span class="keyword">public</span> base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">access</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">derived::access</span><span class="params">()</span></span>&#123;</span><br><span class="line">    j = <span class="number">5</span>; <span class="comment">//error</span></span><br><span class="line">    i= <span class="number">5</span>; <span class="comment">//引用的是派生类的i </span></span><br><span class="line">    base::i = <span class="number">5</span>;<span class="comment">//引用的是基类的 i</span></span><br><span class="line">    <span class="built_in">func</span>(); <span class="comment">//派生类的</span></span><br><span class="line">    base::func0;<span class="comment">//基类的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>一般来说，基类和派生类不定义同名成员变量。</p></blockquote><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b90c71bb63c44bfbb2d77c4ea8ccfcc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=555&h=380&s=78400&e=png&b=ffffff" alt="1695202815288.png" width="50%" /><p><em><strong>eg:存储空间</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        value = newValue;  <span class="comment">// 可以直接访问和赋值基类的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;  <span class="comment">// 可以直接访问基类的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>Derived</code> 派生类继承了 <code>Base</code> 基类的成员变量 <code>value</code>。派生类中的函数 <code>setValue()</code> 和 <code>getValue()</code> 直接对 <code>value</code> 进行赋值和返回操作，而不需要重新声明 <code>value</code>。</p><p>因此，基类的成员变量同样属于派生类，并且可以在派生类中进行直接访问和操作。<br />派生类的内存空间包含了基类的成员和派生类自己的成员。</p><p>当创建一个派生类的对象时，内存空间会按照以下方式进行分配：</p><ol><li>首先，分配基类的内存空间。这包括基类中的所有非静态成员变量和成员函数。</li><li>接下来，分配派生类的附加内存空间。这包括派生类中新增加的非静态成员变量和成员函数。</li></ol><p>派生类的内存布局可以看作是基类和派生类内存布局的组合。</p><p>在派生类中，可以通过派生类对象或指针访问基类的成员，因为基类的成员被继承到派生类中。同时，派生类还可以添加自己的成员，以实现其特定的功能。</p><p>需要注意的是，派生类对象的大小取决于基类和派生类成员的总和，以及可能的内存对齐要求。</p><p>总结：派生类的内存空间包括了基类的成员和派生类自己的成员。派生类的内存布局可以看作是基类和派生类内存布局的组合。通过派生类对象或指针，可以访问基类的成员和派生类自己的成员。</p><h3 id="private-protected和public的范围"><a class="markdownIt-Anchor" href="#private-protected和public的范围"></a> private、protected和public的范围</h3><p>基类的private成员: 可以被下列函数访问</p><ul><li>基类的成员函数</li><li>基类的友员函数</li></ul><p>基类的public成员: 可以被下列函数访问</p><ul><li>基类的成员函数</li><li>基类的友员函数</li><li>派生类的成员函数</li><li>派生类的友员函数</li><li>其他的函数</li></ul><p>基类的protected成员:可以被下列函数访问</p><ul><li>基类的成员函数</li><li>基类的友员函数</li><li>派生类的成员函数可以访问<strong>当前</strong>对象的基类的保护成员</li></ul><h2 id="4-派生类的构造函数"><a class="markdownIt-Anchor" href="#4-派生类的构造函数"></a> 4. 派生类的构造函数</h2><ul><li><strong>在创建派生类的对象时，需要调用基类的构造函数:初始化派生类对象中从基类继承的成员。在执行一个派生类的构造函数之前，总是先执行基类的构造函数。</strong></li><li>调用基类构造函数的两种方式<ul><li>显式方式:在派生类的构造函数中，为基类的构造函数提供参数.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">derived::<span class="built_in">derived</span>(arg_derived-list<span class="comment">/* 参数列表*/</span>):<span class="built_in">base</span>(arg_base-list<span class="comment">/* 参数列表*/</span>)<span class="comment">/* 派生类成员初始化列表 */</span>&#123; </span><br><span class="line">    <span class="comment">// 派生类构造函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>隐式方式:在派生类的构造函数中，省略基类构造函数时，派生类的构造函数则自动调用基类的默认构造函数<code>(无参构造函数)</code>.</li><li></li></ul></li><li><strong>派生类的析构函数被执行时，执行完派生类的析构函数后，自动调用基类的析构函数。</strong></li></ul><blockquote><p>先构造后析构</p></blockquote><h3 id="封闭派生类对象的构造函数的执行顺序"><a class="markdownIt-Anchor" href="#封闭派生类对象的构造函数的执行顺序"></a> 封闭派生类对象的构造函数的执行顺序</h3><p><strong>在创建派生类的对象时:</strong></p><ol><li><p>先执行基类的构造函数，用以初始化派<br />生类对象中从基类继承的成员;</p></li><li><p>再执行成员对象类的构造函数，用以初<br />始化派生类对象中成员对象。</p></li><li><p>最后执行派生类自己的构造函数</p></li></ol><p><strong>在派生类对象消亡时:</strong></p><ol><li><p>先执行派生类自己的析构函数</p></li><li><p>再依次执行各成员对象类的析构函数</p></li><li><p>最后执行基类的析构函数析构函数的调用顺序与构造函数的调用顺序相反。</p></li></ol><h2 id="public继承的赋值兼容规则"><a class="markdownIt-Anchor" href="#public继承的赋值兼容规则"></a> public继承的赋值兼容规则</h2><h3 id="public继承的赋值兼容规则-2"><a class="markdownIt-Anchor" href="#public继承的赋值兼容规则-2"></a> public继承的赋值兼容规则</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span> : <span class="keyword">public</span> base: &#123;&#125;;</span><br><span class="line">base b;</span><br><span class="line">derived d:</span><br></pre></td></tr></table></figure><ol><li><p>派生类的对象可以赋值给基类对象(不能把基类对象赋值给派生类对象，派生类可以对基类兼容）<br />b = d;</p></li><li><p>派生类对象可以初始化基类引用（可以认为基类的引用实际上引用了派生类对象多包含的基类的对象）<br />base &amp; br = d;</p></li><li><p>派生类对象的地址可以赋值给基类指针（基类的指针指向一个派生类的对象所包含的基类对象，所包含的基类对象位于派生类对象的存储空间最前面，即基类对象的起始地址就是派生类对象的起始地址）<br />base* pb=&amp; d;</p></li></ol><blockquote><p>如果派生方式是private或protected，则上述三条不可行。</p></blockquote><h3 id="直接基类和间接基类"><a class="markdownIt-Anchor" href="#直接基类和间接基类"></a> 直接基类和间接基类</h3><ul><li><p>在声明派生类时，只需要列出它的直接基类</p></li><li><p>派生类沿着类的层次自动向上继承它的间接基类</p></li><li><p>派生类的成员包括</p><ul><li>派生类自己定义的成员</li><li>直接基类中的所有成员</li><li>所有间接基类的全部成员</li></ul></li></ul><blockquote><p>派生类初始化时只需要指明直接基类，间接基类由直接基类初始化（递归初始化）</p></blockquote><h3 id="多层类嵌套的构造与析构"><a class="markdownIt-Anchor" href="#多层类嵌套的构造与析构"></a> 多层类嵌套的构造与析构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Base  constructed</span><br><span class="line">Derived constructed</span><br><span class="line">More Derived constructed</span><br><span class="line">More Derived destructed</span><br><span class="line">Derived destructed</span><br><span class="line">Base <span class="number">4</span> destructed</span><br></pre></td></tr></table></figure><h1 id="第六章-多态"><a class="markdownIt-Anchor" href="#第六章-多态"></a> 第六章 多态</h1><h2 id="1-虚函数和多态的基本概念"><a class="markdownIt-Anchor" href="#1-虚函数和多态的基本概念"></a> 1. 虚函数和多态的基本概念</h2><h3 id="虚函数"><a class="markdownIt-Anchor" href="#虚函数"></a> 虚函数</h3><p>虚函数是C++中实现多态的一种机制。当在基类中声明一个函数为虚函数时，派生类可以重写该虚函数，并根据自己的需要提供专门的实现。在运行时，根据对象的实际类型来调用相应的函数。</p><p>在C++中，使用关键字<code>virtual</code>来声明虚函数。基类中的虚函数可以通过在函数声明前加上<code>virtual</code>关键字来定义，</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">base::get</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>virtual 关键字只用在类定义里的函数声明中写函数体时不用。</li><li>构造函数和静态成员函数不能是虚函数</li></ul><p>派生类可以重写基类的虚函数，通过相同的函数名和参数列表来覆盖基类的虚函数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 派生类对虚函数的重写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意到，在派生类中重写虚函数时，可以使用<code>override</code>关键字来显式标记，以提高代码的可读性。</p><blockquote><p><code>override</code>关键字是C++11标准引入的一个特性，用于显式地表示派生类成员函数是覆盖（override）了基类中的虚函数。当我们使用该关键字时，编译器会检查派生类的这个函数是否确实重写了基类的虚函数（即函数名、参数列表和返回值类型都相同），否则会报错。</p></blockquote><p>使用<code>override</code>关键字的语法格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void function() override;</span><br></pre></td></tr></table></figure><h3 id="多态的表现形式一指针"><a class="markdownIt-Anchor" href="#多态的表现形式一指针"></a> 多态的表现形式一(指针)</h3><ul><li><p>派生类的指针可以赋给基类指针。</p></li><li><p>通过基类指针调用基类和派生类中的同名<strong>虚函数</strong>时:</p><p>(1) 若该指针指向一个基类的对象，那么被调用是基类的虚函数;</p><p>(2) 若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。</p></li></ul><p>这种机制就叫 <strong>“多态”</strong>。</p><p><em><strong>eg.指针</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived::func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">func</span>(); <span class="comment">// 输出 &quot;Derived::func()&quot;</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态的表现形式二引用"><a class="markdownIt-Anchor" href="#多态的表现形式二引用"></a> 多态的表现形式二(引用)</h3><ul><li><p>派生类的对象可以赋给基类引用。</p></li><li><p>通过基类引用调用基类和派生类中的同名<strong>虚函数</strong>时:</p><p>(1) 若该引用引用的是一个基类的对象，那么被调用是基类的虚函数;</p><p>(2) 若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数。</p></li></ul><p>这种机制也叫做 <strong>“多态”</strong>。</p><p><em><strong>eg.引用</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived::func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base&amp; ref = derived;</span><br><span class="line">    ref.<span class="built_in">func</span>();  <span class="comment">// 输出 &quot;Derived::func()&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在面向对象的程序设计中使用多态，能够增强程序的可扩充性，即程序需要修改或增加功能的时候，需要改动和增加的代码较少</p></blockquote><h2 id="2多态示例2纯虚函数"><a class="markdownIt-Anchor" href="#2多态示例2纯虚函数"></a> 2.多态示例2：纯虚函数</h2><p>在C++中，声明函数体为空（也称为空函数或虚函数的默认实现）和声明纯虚函数之间有明显的区别：</p><ol><li><p>纯虚函数（Pure Virtual Function）：</p><ul><li>纯虚函数是一个虚函数，它在基类中声明但没有提供具体的实现。</li><li>声明纯虚函数时，在函数声明的末尾使用 “= 0” 来标记它，例如：<code>virtual void foo() = 0;</code>。</li><li>类中包含至少一个纯虚函数的类被称为抽象基类，无法实例化对象。</li><li>派生类必须提供纯虚函数的具体实现，否则它们也会成为抽象类。</li></ul></li></ol><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pureVirtualFunction</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>声明函数体为空（Empty Function）：</p><ul><li>声明函数体为空的函数是一个虚函数，但它提供了一个默认的空实现，派生类可以选择是否覆盖这个实现。</li><li>在函数定义中使用关键字 <code>virtual</code>，然后在函数体中仅提供一个空实现即可。</li><li>派生类可以选择性地覆盖这个虚函数，如果不覆盖，将继续使用默认的空实现。</li></ul></li></ol><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">emptyVirtualFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 默认的空实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>主要区别在于，纯虚函数要求派生类必须提供自己的实现，而声明函数体为空的虚函数提供了一个默认实现，但派生类可以选择是否覆盖它。</li><li>纯虚函数用于定义接口，强制派生类提供特定的功能，而函数体为空的虚函数提供了一种可选的默认实现，派生类可以继承或覆盖它，具有更大的灵活性。在C++中，声明函数体为空（也称为空函数或虚函数的默认实现）和声明纯虚函数之间有明显的区别：</li></ul><h2 id="3-多态实例几何形体程序纯虚函数"><a class="markdownIt-Anchor" href="#3-多态实例几何形体程序纯虚函数"></a> 3. 多态实例：几何形体程序(纯虚函数)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">已知：</span><br><span class="line">几何形体处理程序: 输入若干个几何形体的参数，输出时要指明形状。要求按面积排序输出。</span><br><span class="line">Input:</span><br><span class="line">第一行是几何形体数目<span class="built_in">n</span> (不超过<span class="number">100</span>).下面有n行，每行以一个字母c开头.</span><br><span class="line">若c是则代表一个矩形，本行后面跟着两个整数，分别是矩形的宽和高;</span><br><span class="line">若 c 是 C’，则代表一个圆，本行后面跟着一个整数代表其半径;</span><br><span class="line">若c是“T’，则代表一个三角形，本行后面跟着三个整数，代表三条边的长度.</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CShape</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> <span class="type">double</span> Area = <span class="number">0</span>; <span class="comment">//纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Printlnfo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CRectangle</span>:<span class="keyword">public</span> CShape&#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="type">int</span> w,h;<span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">Area</span><span class="params">()</span></span>;<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PrintInfo</span><span class="params">()</span>&#125;</span>;</span><br><span class="line">CShape * pShapes[<span class="number">100</span>];<span class="function"><span class="type">int</span> <span class="title">MyCompare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * s1, <span class="type">const</span> <span class="type">void</span> *s2)</span>:</span></span><br><span class="line"><span class="function">int MyCompare(const void * s1, const void *s2)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line"><span class="type">double</span> a1,a2;</span><br><span class="line">CShape**pl; <span class="comment">// s1,s2 是 void * ，不可写“* s1”来取得s1指向的内容</span></span><br><span class="line">CShape**p2;</span><br><span class="line">p1=(CShape ** )s1;<span class="comment">//sl,s2指向pShapes数组中的元素，数组元素的类型是CShape*</span></span><br><span class="line">p2 =( CShape**)s2; <span class="comment">//  pl,p2都是指向指针的指针，类型为 CShape **</span></span><br><span class="line">a1 =(*p1)&gt;Area0);<span class="comment">// * p1 的类型是 Cshape *,是基类指针，故此句为多态</span></span><br><span class="line">a2 =(*p2)-&gt;<span class="built_in">Area</span>();</span><br><span class="line"><span class="keyword">if</span>( al &lt;a2)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>:</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( a2 &lt;a1)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对 MyCompare的解释：</p></blockquote><blockquote><p>const void * s1, const void *s2指向pShape数组中待比较的元素</p></blockquote><blockquote><p>不可写“* s1”来取得s1指向的内容:</p><p>编译时会出错，因为s1是void*类型的指针，s1的所占用的字节数无法判断。</p></blockquote><p>在C++中，<code>void*</code> 是一种特殊的指针类型，称为“无类型指针”（void pointer），它可以指向任何类型的数据，因为它没有指定具体的数据类型。当你使用 <code>void*</code> 类型的指针时，编译器不知道它指向的数据类型是什么，因此不允许直接对其进行解引用操作，即不允许使用 <code>*s1</code> 来取得指向的内容。</p><p>如果你想在 <code>MyCompare</code> 函数中访问 <code>s1</code> 和 <code>s2</code> 指向的内容，你需要进行类型转换，将它们转换为正确的类型，然后再进行解引用操作。这是因为编译器需要明确知道要访问的数据的类型，以便正确地解释和处理数据。</p><p>在你的代码中，你进行了如下的类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1 = (CShape**)s1; <span class="comment">// 将 void* 转换为 CShape** 类型的指针</span></span><br><span class="line">p2 = (CShape**)s2; <span class="comment">// 将 void* 转换为 CShape** 类型的指针</span></span><br></pre></td></tr></table></figure><p>这些类型转换允许你将 <code>s1</code> 和 <code>s2</code> 视为 <code>CShape**</code> 类型的指针，然后使用 <code>*p1</code> 和 <code>*p2</code> 来解引用它们，访问指向的 <code>CShape</code> 对象。</p><p>总之，<code>void*</code> 类型的指针是一种通用指针，不具有具体的类型信息，因此不能直接解引用。必须通过类型转换将其转换为正确的指针类型后，才能安全地使用 <code>*</code> 运算符来获取指向的内容。</p><blockquote><p>我们知道sl,s2指向pShapes数组中的元素，数组元素的类型是CShape*，因此需要强制类型转换。</p></blockquote><p>因此需要让p1指针指向CShape*类型的指针，p1是指向指针的指针（p1 = (CShape**)s1）</p><blockquote><p>对<code>Cshape**</code>的理解</p><blockquote><p>s1是void*类型，请解释为什么不转换为Cshape <em>类型而是Cshape</em>*</p><p><strong><i>Answer:</i></strong> 对于 <code>qsort</code> 函数的比较函数，<code>void*</code> 参数通常用于指向要排序的元素的指针。在这个特定的情境下，<code>s1</code> 和 <code>s2</code> 实际上是指向 <code>CShape*</code> 类型的指针数组中的元素的指针。</p><p>因此，在这里使用 <code>CShape**</code> 是为了将 <code>s1</code> 和 <code>s2</code> 转换为指向 <code>CShape*</code> 类型的指针，以便在比较函数中能够访问 <code>CShape</code> 对象。这是因为 <code>qsort</code> 函数需要比较函数的参数是 <code>const void*</code> 类型，但你实际上要比较的是 <code>CShape*</code> 类型的指针。</p><p>具体来说，<code>s1</code> 和 <code>s2</code> 是指向 <code>CShape*</code> 数组元素的指针，因此使用 <code>CShape**</code> 类型来进行类型转换，以便在比较函数中访问元素的实际内容。你可以把它看作是一种解开多层指针以获取元素的方法，因为元素本身就是 <code>CShape*</code> 类型的指针。</p><p>这种转换方式允许你在比较函数中访问 <code>CShape</code> 对象，以便进行排序操作，而不是仅仅比较指针地址。这是为了确保排序是基于元素的属性而不是元素的地址。</p></blockquote><blockquote><p>拆分<code>Cshape**</code>的层次理解<br />当你将 <code>s1</code> 和 <code>s2</code> 进行类型转换为 <code>CShape**</code> 时，实际上是在拆分多层指针，以便在比较函数中访问 <code>CShape</code> 对象。下面是拆分过程的详细解释：</p><ol><li>假设你有一个数组 <code>CShape* shapes[]</code>，其中包含了多个 <code>CShape*</code> 类型的指针。</li><li><code>qsort</code> 的比较函数期望接收 <code>void*</code> 类型的参数，这意味着它将接收指向数组元素的指针，而不是数组元素本身。</li><li>当你将 <code>s1</code> 和 <code>s2</code> 强制转换为 <code>CShape**</code> 类型时，实际上是将它们转换为指向 <code>CShape*</code> 类型指针的指针。</li><li>这样，你就可以在比较函数中使用 <code>*p1</code> 和 <code>*p2</code> 来访问指向 <code>CShape*</code> 对象的指针，而不仅仅是数组元素的地址。</li></ol><p>在代码中，这个过程如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;CShape** p1 = (CShape**)s1; <span class="comment">// 将 void* 转换为 CShape** 类型的指针</span></span><br><span class="line">&gt;&gt;CShape** p2 = (CShape**)s2; <span class="comment">// 将 void* 转换为 CShape** 类型的指针</span></span><br></pre></td></tr></table></figure><p>现在，<code>p1</code> 和 <code>p2</code> 分别是指向 <code>CShape*</code> 对象的指针的指针。这使得你可以使用 <code>*p1</code> 和 <code>*p2</code> 来获取 <code>CShape*</code> 对象的实际内容，然后在比较函数中进行排序操作，而不仅仅是比较指针地址。这允许你基于 <code>CShape</code> 对象的属性来进行排序。</p></blockquote></blockquote><blockquote><p>既然需要强制类型转换为什么 MyCompare(const void * s1, const void <em>s2)写成void</em>类型</p></blockquote><p>在这段代码中，<code>MyCompare</code> 函数是用作 <code>qsort</code> 函数的比较函数。<code>qsort</code> 函数是一个通用的排序函数，它接受一个比较函数作为参数，并且该比较函数必须满足特定的签名要求。该比较函数需要以 <code>const void*</code> 类型的参数作为输入，因为 <code>qsort</code> 不知道要排序的元素的具体类型。因此，这里使用 <code>const void*</code> 类型作为参数类型。</p><p>下面是关于为什么使用 <code>const void*</code> 的解释：</p><ol><li><strong>通用性：</strong> <code>qsort</code> 函数被设计成可以对任何类型的数组进行排序，因此它不能假设要排序的元素的具体类型。使用 <code>const void*</code> 允许你传递任意类型的指针作为参数。</li><li><strong>类型安全性：</strong> 如果 <code>MyCompare</code> 函数的参数类型是 <code>const CShape*</code>，那么它只能用于 <code>CShape</code> 类型的指针，而不能用于其他类型的指针。使用 <code>const void*</code> 允许你在比较函数中进行类型转换，以适应不同类型的元素。</li></ol><p>在 <code>MyCompare</code> 函数中，参数 <code>s1</code> 和 <code>s2</code> 是 <code>const void*</code> 类型，因此你需要将它们转换为 <code>CShape*</code> 类型的指针，以便访问它们指向的对象。这就是为什么在函数中使用 <code>p1</code> 和 <code>p2</code> 进行类型转换，然后使用 <code>*p1</code> 和 <code>*p2</code> 来访问它们所指向的 <code>CShape</code> 对象的原因。</p><p>总之，使用 <code>const void*</code> 类型的参数是为了增加通用性，使 <code>MyCompare</code> 函数能够用于不同类型的元素，并且允许在函数内部进行必要的类型转换。这是一种常见的技巧，用于处理泛型代码或需要对不同类型的数据进行排序的情况。</p><h3 id="非构造函数非析构函数的成员函数中调用虚函数是多态"><a class="markdownIt-Anchor" href="#非构造函数非析构函数的成员函数中调用虚函数是多态"></a> 非构造函数,非析构函数的成员函数中调用虚函数，是多态</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;<span class="built_in">fun2</span>();&#125;<span class="comment">//&#123;this-&gt;fun2();&#125; this是基类指针，fun2是虚函数，所以是多态</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;Base::fun2(&quot;</span>&lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived:fun2(0&quot;</span>&lt;&lt; endl;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    Base * pBase= &amp; d;</span><br><span class="line">    pBase-&gt;<span class="built_in">fun1</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>◎实际输出</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived:<span class="built_in">fun2</span>()</span><br></pre></td></tr></table></figure><blockquote><p>在非构造函数,非析构函数的成员函数中调用虚函数，是多态! ! !</p></blockquote><h3 id="构造函数和析构函数中调用虚函数"><a class="markdownIt-Anchor" href="#构造函数和析构函数中调用虚函数"></a> 构造函数和析构函数中调用虚函数</h3><blockquote><p>在构造函数和析构函数中调用虚函数，不是多态。编译时即可确定，调用的函数是<code>自己的类或基类</code>中定义的函数，不会等到运行时才决定调用自己的还是派生类的函数。</p><p>在构造和析构期间，对象的类型是已知的，不会发生多态性。只有在对象完全构造之后，并且通过派生类指针或引用访问对象时，多态性才会生效。</p></blockquote><p>原理：由于编译时，派生类对象在初始化时先初始化基类，先执行基类的构造函数，此时派生类对象的构造函数还没有被初始化，如果在基类的初始化过程中调用了派生类还未被初始化的虚函数，这样的结果有可能是不正确的。</p><h3 id="隐藏"><a class="markdownIt-Anchor" href="#隐藏"></a> 隐藏</h3><blockquote><p>派生类中和基类中虚函数同名同参数表的函数，不加virtual也自动成为虚函数</p></blockquote><p>对于派生类中和基类中虚函数同名同参数表的函数，如果不加 <code>virtual</code> 关键字，它不会自动成为虚函数，而是被视为普通的函数。这意味着在派生类中的该函数将会隐藏基类中的同名函数，而不是覆盖它。这种情况通常被称为函数的隐藏（function hiding）。</p><p>要使派生类中的同名函数成为虚函数，你需要在派生类中显式使用 <code>virtual</code> 关键字进行声明，并确保函数签名（参数列表和返回类型）与基类中的虚函数完全匹配。</p><p>以下是一个示例，说明了这一点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void virtualFunction() &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Base virtual function&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    void virtualFunction() override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Derived virtual function&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Base* basePtr = new Derived();</span><br><span class="line">    basePtr-&gt;virtualFunction();  // 输出 &quot;Derived virtual function&quot;</span><br><span class="line">    delete basePtr;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>Base</code> 类有一个虚函数 <code>virtualFunction()</code>。在 <code>Derived</code> 类中，我们重写了同名的函数，但没有显式添加 <code>virtual</code> 关键字。然而，由于函数签名匹配，<code>Derived</code> 类中的函数仍然被视为虚函数，并且在运行时多态性会生效，因此在 <code>main</code> 函数中通过基类指针调用时，将调用 <code>Derived</code> 类的版本。这是因为编译器会自动将覆盖的虚函数标记为 <code>override</code>，除非函数签名不匹配，否则可以省略 <code>virtual</code> 关键字。</p><h2 id="4多态的实现原理"><a class="markdownIt-Anchor" href="#4多态的实现原理"></a> 4.多态的实现原理</h2><p>“多态”的关键在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定——这叫 <strong>“动态联编”</strong>。 “动态联编”底是怎么实现的呢?</p><p><em><strong>eg</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base:Print&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Drived:Print&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(Base) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Derived);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理论上输出的内存大小Base=4（int i），Derived=8（继承的int i；int n）.程序输出为8,12.</p><blockquote><p>注：这里是理想化的算法，实际上会由于内存对齐等原因输出16,16.</p></blockquote><h3 id="多态实现的关键-虚函数表"><a class="markdownIt-Anchor" href="#多态实现的关键-虚函数表"></a> 多态实现的关键—-—虚函数表</h3><p>每一个有虚函数的类(或有虚函数的类的派生类）都有一个<strong>虚函数表</strong>，该类的任何对象（该类的实例）中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址。<strong>多出来的4个字节就是用来放虚函数表的地址的。</strong></p><blockquote><p>解释：</p><ol><li><strong>基类</strong>：当一个基类中包含虚函数时，编译器会在基类中生成一个虚函数表，其中包含了基类的虚函数的地址。这个虚函数表与基类的类型关联，并且基类的所有子类都会共享这个虚函数表。</li><li><strong>派生类</strong>：当你创建一个派生类时，它会继承基类的虚函数表，但也可以覆盖其中的虚函数，并在派生类的虚函数表中包含派生类的虚函数的地址。这样，派生类既包含了基类的虚函数表信息，又包含了自己的虚函数表信息。</li><li><strong>对象</strong>：每个类的对象中都包含一个指向该类的虚函数表的指针，这个指针通常被称为虚指针（vptr）。无论对象是基类的实例还是派生类的实例，都有一个虚指针，它指向该对象的实际类型的虚函数表。这是多态性的关键：通过虚指针，程序能够在运行时根据对象的实际类型来调用正确的虚函数。</li></ol></blockquote><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f47682cecb1436ab374f41ce3d19f48~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1091&h=690&s=196140&e=png&b=fcfafc" alt="LUP4W@M[RI@9$3MWW6D~2(D.png" width="70%" /></p><p>多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的)对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址,并调用虚函数的指令。</p><h3 id="虚函数表的证明"><a class="markdownIt-Anchor" href="#虚函数表的证明"></a> 虚函数表的证明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::Func&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::Func&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    A *pa = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    pa-&gt;<span class="built_in">Func</span>();</span><br><span class="line">    <span class="comment">//64位程序指针为8字节</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> *p1 = (<span class="type">long</span> <span class="type">long</span> *) &amp;a;;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> *p2 = (<span class="type">long</span> <span class="type">long</span> *) pa;</span><br><span class="line">    *p2 = *p1;</span><br><span class="line">    pa-&gt;<span class="built_in">Func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这段代码演示了C++中的虚函数和多态性，以及通过直接修改虚函数表指针来改变对象行为的技术。</p></blockquote><p>让我们逐步解释这段代码：</p><ol><li><p>首先，定义了两个类 <code>A</code> 和 <code>B</code>。<code>A</code> 类包含一个虚函数 <code>Func()</code>，而 <code>B</code> 类继承自 <code>A</code> 并重写了 <code>Func()</code> 函数，给出了不同的实现。</p></li><li><p>在 <code>main</code> 函数中：</p><ul><li>创建了一个 <code>A</code> 类对象 <code>a</code>。</li><li>创建了一个指向 <code>B</code> 类对象的基类指针 <code>pa</code>。这里使用了多态性，因为 <code>pa</code> 指向了 <code>B</code> 类对象，但是声明为 <code>A</code> 类指针。这意味着通过 <code>pa</code> 调用虚函数 <code>Func()</code> 时，将根据对象的实际类型调用相应的函数版本。</li></ul></li><li><p>接下来，通过将 <code>a</code> 对象的内存内容拷贝到 <code>pa</code> 对象的内存中，直接修改了虚函数表指针的值。这部分代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> *p1 = (<span class="type">long</span> <span class="type">long</span> *) &amp;a;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> *p2 = (<span class="type">long</span> <span class="type">long</span> *) pa;</span><br><span class="line">*p2 = *p1;</span><br></pre></td></tr></table></figure><p>这些操作实际上是将 <code>a</code> 对象的内存布局复制到 <code>pa</code> 指向的对象中，包括虚函数表指针。这样，<code>pa</code> 现在指向的虚函数表与 <code>a</code> 相同。</p></li><li><p>最后，再次通过 <code>pa</code> 调用虚函数 <code>Func()</code>。由于虚函数表指针已经被修改为与 <code>a</code> 相同，因此将调用 <code>A</code> 类中的 <code>Func()</code> 函数。</p></li></ol><blockquote><p>c++等语言的指针设计可以直接访问内存而不是需要借助整个对象，使程序更加丰富和灵活</p></blockquote><h2 id="5-虚析构函数-纯虚函数和抽象类"><a class="markdownIt-Anchor" href="#5-虚析构函数-纯虚函数和抽象类"></a> 5. 虚析构函数、纯虚函数和抽象类</h2><h3 id="虚析构函数"><a class="markdownIt-Anchor" href="#虚析构函数"></a> 虚析构函数</h3><ul><li>通过基类的指针删除派生类对象时，通常情况下只调用基类的析构函数<ul><li>但是，删除一个派生类的对象时，应该先调用派生类的析构函数，然后调用基类的析构函数。</li></ul></li><li>解决办法:把基类的<code>析构函数声明为virtual</code><ul><li>派生类的析构函数可以virtual不进行声明</li><li>通过基类的指针删除派生类对象时，首先调用派生类的析构函数，然后调用基类的析构函数</li></ul></li><li>一般来说，一个类如果定义了虚函数，则应该将析构函数也定义成虚函数。3或者，一个类打算作为基类使用，也应该将析构函数定义成虚函数。</li><li><strong>注意:</strong> 不允许以虚函数作为构造函数</li></ul><h3 id="纯虚函数和抽象类"><a class="markdownIt-Anchor" href="#纯虚函数和抽象类"></a> 纯虚函数和抽象类</h3><ul><li><p>包含纯虚函数的类叫抽象类</p><ul><li><p>抽象类只能作为基类来派生新类使用，不能创建抽象类的对象</p></li><li><p>抽象类的指针和引用可以指向由抽象类派生出来的类的对象</p><p>A a ;// 错，A 是抽象类，不能创建对象</p><p>A*pa ; // ok,可以定义抽象类的指针和引用</p><p>pa = new A ;//错误，A 是抽象类，不能创建对象</p></li></ul></li><li><p>在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能调用纯虚函数。</p></li><li><p>如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数，它才能成为非抽象类。</p></li></ul><h1 id="第七章-输入输出和模板"><a class="markdownIt-Anchor" href="#第七章-输入输出和模板"></a> 第七章 输入输出和模板</h1><h2 id="1-输入输出流相关的类"><a class="markdownIt-Anchor" href="#1-输入输出流相关的类"></a> 1. 输入输出流相关的类</h2><h3 id="输出重定向"><a class="markdownIt-Anchor" href="#输出重定向"></a> 输出重定向</h3><p><code>freopen</code> 函数是C/C++标准库中的一个函数，用于重新定向标准I/O流。你提到的代码片段 <code>freopen(&quot;test.txt&quot;, &quot;w&quot;, stdout);</code> 的作用是将标准输出流 <code>stdout</code> 重定向到一个文件 <code>&quot;test.txt&quot;</code> 中，以便将输出写入到这个文件中，而不是默认的控制台输出。</p><p>具体解释如下：</p><ul><li><code>&quot;test.txt&quot;</code> 是要打开的文件的名称，这里是一个文本文件。</li><li><code>&quot;w&quot;</code> 表示以写入（write）模式打开文件。这将创建一个新文件（如果文件不存在），或者覆盖已存在的文件。</li><li><code>stdout</code> 是标准输出流的文件指针，它通常用于将输出写入控制台。</li></ul><p>所以，<code>freopen(&quot;test.txt&quot;, &quot;w&quot;, stdout);</code> 的效果是将标准输出流重定向到 <code>&quot;test.txt&quot;</code> 文件，之后所有的 <code>cout</code> 输出操作将被写入到 <code>&quot;test.txt&quot;</code> 文件中而不是显示在控制台上。</p><p>这种技术通常用于将程序的输出保存到文件中，以便稍后进行查看、分析或记录程序的输出。一旦调用了 <code>freopen</code>，程序的输出将不再显示在终端上，而是写入到指定的文件中。如果需要再次将输出恢复到终端，可以使用类似的方法将 <code>stdout</code> 重定向到终端。</p><h3 id="输入重定向"><a class="markdownIt-Anchor" href="#输入重定向"></a> 输入重定向</h3><h3 id="判断输入流结束"><a class="markdownIt-Anchor" href="#判断输入流结束"></a> 判断输入流结束</h3><p>可以用如下方法判输入流结束:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;x)&#123;</span><br><span class="line">... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>已知</strong></em></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;istream &amp;operator &gt;&gt;(int a)//右移运算符在istream类的重载</span><br><span class="line">&gt;&#123;</span><br><span class="line">   ...</span><br><span class="line">&gt;return *this ;//返回值是istream的引用，实际是cin的引用（即cin）</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>cin是如何作为逻辑值的判断？</p><p>强制类型转换运算符的重载，返回值虽然是cin，但在istream类中有强制类型转换的重载，转换为布尔类型的值</p></blockquote><ul><li>如果是从文件输入，比如前面有freopen(“some.txt”,”r”,stdin);那么，读到文件尾部，输入流就算结束</li><li>如果从键盘输入，则在单独一行输入Ctrl+Z代表输入流结束</li></ul><h3 id="istream类的成员函数"><a class="markdownIt-Anchor" href="#istream类的成员函数"></a> istream类的成员函数</h3><p><code>istream</code> 类是 C++ 标准库中用于输入流操作的基类，它提供了一系列成员函数来从输入源（通常是键盘、文件或其他输入设备）中读取数据。以下是一些常用的 <code>istream</code> 类成员函数：</p><ol><li><strong><code>operator&gt;&gt;</code>：</strong> 这是输入运算符重载函数，用于从输入流中读取数据并存储到变量中。它的参数取决于要读取的数据类型，例如 <code>int</code>、<code>double</code>、<code>char</code>、<code>string</code> 等。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code</span><br><span class="line">istream&amp; operator&gt;&gt;(Type&amp; variable);</span><br></pre></td></tr></table></figure><ol start="2"><li><strong><code>get</code>：</strong> 用于从输入流中逐字符读取数据，可以指定读取的字符数。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; get(char&amp; ch);</span><br><span class="line">istream&amp; get(char* s, streamsize count, char delim = &#x27;\n&#x27;);</span><br></pre></td></tr></table></figure><ol start="3"><li><p><strong>getline</strong></p><ul><li><p><code>istream &amp; getline (char * buf，int bufSize);</code></p><p>从输入流中读取<code>bufSize-1</code>个字符到缓冲区<code>buf</code>，或读到碰到<code>‘\n'</code>为止(哪个先到算哪个）。</p></li><li><p><code>istream &amp; getline (char * buf，int bufSize, char delim) ;</code></p><p>从输入流中读取<code>bufSize-1</code>个字符到缓冲区<code>buf</code>，或读到碰到delim字符为止(哪个先到算哪个）。</p></li></ul><p><em><strong>两个函数都会自动在buf中读入数据的结尾添加<code>\0</code>。 <code>,</code> <code>‘n’</code>或delim都不会被读入buf，但会被从输入流中取走。</strong></em> 如果输入流中<code>‘\n’</code>或delim之前的字符个数<strong>达到或超过了</strong>bufSize个，就导致读入出错，其结果就是:虽然本次读入已经完成，但是之后的读入就都会失败了。</p></li></ol><ul><li>可以用<code>if(!cin.getline(…))</code>判断输入是否结束</li></ul><ol start="4"><li><p><strong><code>good</code>、<code>eof</code>、<code>fail</code> 和 <code>bad</code>：</strong></p><p>这些成员函数用于检查输入流的状态。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">good</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//bool eof();判断输入流是否结束</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">eof</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fail</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bad</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong><code>peek</code>：</strong> 返回下一个字符,用于查看输入流中的下一个字符而不从流中移除它。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ol start="6"><li><strong><code>putback</code>：</strong> 用于将字符ch放回输入流中，以便后续读取。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">putback</span><span class="params">(<span class="type">char</span> ch)</span></span>;</span><br></pre></td></tr></table></figure><ol start="7"><li><strong><code>ignore</code>：</strong> 用于跳过指定数量的字符或特定字符，通常用于清除输入流中的缓冲区或跳过不需要的字符。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; ignore(streamsize count = 1, int delim = EOF);//从流中删掉最多count个字符，遇到EOF时结束</span><br></pre></td></tr></table></figure><ol start="8"><li><strong><code>unget</code>：</strong> 用于将一个字符放回输入流中，与 <code>putback</code> 类似，但可以放回多个字符。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">unget</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ol start="9"><li><strong><code>clear</code>：</strong> 用于清除流的错误状态标志，通常与 <code>ignore</code> 和其他操作结合使用。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(iostate state = goodbit)</span></span>;</span><br></pre></td></tr></table></figure><ol start="10"><li><strong><code>tie</code>：</strong> 用于设置或获取与输入流相关联的输出流。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream* <span class="title">tie</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">ostream* <span class="title">tie</span><span class="params">(ostream* new_tie)</span></span>;</span><br></pre></td></tr></table></figure><p>以上是一些常用的 <code>istream</code> 类成员函数及其参数。这些函数允许你从输入流中读取和处理数据，并提供了一些控制输入流状态的方法，以满足不同的输入处理需求。具体的使用方式取决于要处理的数据类型和输入源。</p><h2 id="2-用流操纵算子控制输出格式"><a class="markdownIt-Anchor" href="#2-用流操纵算子控制输出格式"></a> 2. 用流操纵算子控制输出格式</h2><blockquote><p>使用流操纵算子需要 <code>#include &lt;iomanip&gt;</code></p></blockquote><h3 id="整数流的基数流操纵算子decocthex"><a class="markdownIt-Anchor" href="#整数流的基数流操纵算子decocthex"></a> 整数流的基数:流操纵算子dec,oct,hex</h3><p><strong><code>dec</code>：</strong> 这个流操纵算子用于将整数以十进制形式输出。</p><p><strong><code>oct</code>：</strong> 这个流操纵算子用于将整数以八进制形式输出。</p><p><strong><code>hex</code>：</strong> 这个流操纵算子用于将整数以十六进制形式输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">12</span>;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; hex &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; dec &lt;&lt; n &lt;&lt; endl &lt;&lt; oct &lt;&lt; n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="5泛型程序设计函数模板"><a class="markdownIt-Anchor" href="#5泛型程序设计函数模板"></a> 5.泛型程序设计·函数模板</h2><p>C++ 函数模板（Function Templates）是一种通用编程特性，允许你编写可以用于多种不同数据类型的函数。函数模板使得代码更加通用和可重用，它们在处理不同数据类型时可以减少代码的冗余。</p><p>注意事项：</p><ul><li>函数模板的模板参数可以有多个，并且可以是不同的类型。</li><li>使用模板时，编译器会根据传递的参数类型自动匹配模板参数的具体类型。</li><li>如果你需要特殊化某个数据类型的函数行为，可以提供特殊化版本的模板函数。</li></ul><p>函数模板是C++中强大的通用编程工具，它允许你编写通用、可重用的代码，以处理各种不同数据类型的情况。它在STL（标准模板库）中广泛使用，用于实现容器和算法。</p><p>函数模板︰</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>类型参数<span class="number">1</span> ，<span class="keyword">class</span>类型参数<span class="number">2</span>,......&gt;</span><br><span class="line">返回值类型 模板名(形参表)</span><br><span class="line">&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在C++中，函数模板的实例化通常是通过函数的参数类型来自动确定的。这是函数模板的主要用途之一，因为它允许根据不同的参数类型生成不同的函数实例。</p><p>但是，如果你想不通过参数实例化函数模板，可以考虑使用以下两种方法：</p><ol><li>显式指定模板参数类型：</li></ol><p>你可以使用尖括号 <code>&lt; &gt;</code> 显式指定函数模板的模板参数类型，而不依赖于函数的参数类型。这样可以创建特定模板参数类型的函数实例。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数模板的实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 显式实例化函数模板为 int 类型</span></span><br><span class="line">    <span class="built_in">MyFunction</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显式实例化函数模板为 double 类型</span></span><br><span class="line">    <span class="built_in">MyFunction</span>&lt;<span class="type">double</span>&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，通过在函数名后的尖括号中显式指定模板参数类型，可以实例化特定类型的函数。</p><ol start="2"><li>使用模板特化：</li></ol><p>另一种方法是使用模板特化（template specialization）来创建特定类型的函数实例。模板特化允许你为特定的数据类型提供定制的实现，而不仅仅是依赖于模板参数类型的自动推导。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通用实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板特化为 int 类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">MyFunction</span>&lt;<span class="type">int</span>&gt;() &#123;</span><br><span class="line">    <span class="comment">// int 类型的定制实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">MyFunction</span>&lt;<span class="type">int</span>&gt;();      <span class="comment">// 调用特化版本</span></span><br><span class="line">    <span class="built_in">MyFunction</span>&lt;<span class="type">double</span>&gt;();   <span class="comment">// 调用通用版本</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们创建了一个通用的函数模板 <code>MyFunction()</code>，然后使用模板特化为 <code>int</code> 类型提供了一个定制的实现。当函数调用时，如果传递的参数类型是 <code>int</code>，将调用特化版本；否则，将调用通用版本。</p><p>这两种方法都允许你在不依赖于函数的参数类型的情况下实例化函数模板。</p><h3 id="函数模版的重载"><a class="markdownIt-Anchor" href="#函数模版的重载"></a> 函数模版的重载</h3><p>函数模板可以重载，只要它们的形参表或类型参数表不同即可</p><p>在有多个函数和函数模板名字相同的情况下，编译器如下处理条函数调用语句</p><ol><li>先找参数完全匹配的普通函数(非由模板实例化而得的函数</li><li>再找参数完全匹配的模板函数</li><li>再找实参数经过自动类型转换后能够匹配的普通函数</li><li>上面的都找不到，则报错</li></ol><blockquote><p>匹配模板函数时，不进行类型自动转换</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">myFunction</span><span class="params">(T arg1, T arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; arg1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arg2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> arg1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">myFunction</span>(<span class="number">5.8</span>, <span class="number">8.4</span>); <span class="comment">// ok: replace T with double</span></span><br><span class="line"><span class="built_in">myFunction</span>(<span class="number">5</span>, <span class="number">8.4</span>);   <span class="comment">// error, no matching function for call &#x27;myFunction(int, double)&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>编译器不会将实参类型进行隐式转换，例如不会将5转换为5.0。</p></blockquote><h3 id="函数指针"><a class="markdownIt-Anchor" href="#函数指针"></a> 函数指针</h3><ol><li><p><strong>函数指针</strong>：</p><ul><li>函数指针是指向函数的指针变量。它允许你在运行时动态地选择要调用的函数，以便灵活地执行不同的操作。</li><li>在C/C++中，函数名本身就是指向函数的指针。</li></ul></li><li><p><strong>函数指针类型</strong>：</p><ul><li><p>函数指针类型定义了函数指针所指向的函数的签名（参数类型和返回类型）。函数指针类型告诉编译器函数指针可以指向哪种类型的函数。</p></li><li><p>函数指针类型的声明方式为：<code>returnType (*pointerName)(parameterType1, parameterType2, ...)</code>，其中：</p><ul><li><code>returnType</code> 是函数的返回类型。</li><li><code>pointerName</code> 是函数指针的名称。</li><li><code>parameterType1</code>, <code>parameterType2</code>, … 是函数的参数类型。</li></ul></li></ul></li><li><p><strong>函数模板</strong>：</p><ul><li>函数模板允许你编写通用的函数，可以用于多种不同的数据类型。</li><li>在你的例子中，<code>Map</code> 函数是一个函数模板，它接受迭代器范围和函数指针作为参数。</li></ul></li><li><p><strong>使用函数指针</strong>：</p><ul><li>函数指针可以像普通函数一样调用，使用 <code>()</code> 运算符，并传递相应的参数。例如，<code>int result = addPtr(5, 3);</code>。</li><li>在你的例子中，<code>Map</code> 函数接受一个函数指针作为参数 <code>Pred op</code>，并在迭代器范围上应用该函数。</li></ul></li><li><p><strong>模板函数的参数推断</strong>：</p><ul><li>在函数模板调用时，编译器会自动推断模板参数的类型。在你的例子中，<code>Pred op</code> 的类型与传递给它的函数的类型一致，因此函数指针类型 <code>double (*op)(double)</code> 可以自动推导。</li></ul></li><li><p><strong>函数指针的用途</strong>：</p><ul><li>函数指针可以用于实现回调函数，允许你传递函数作为参数，以在特定事件发生时调用这些函数。</li><li>函数指针还常用于设计模式中，如策略模式，以根据需要在运行时选择不同的算法。</li></ul></li></ol><p>总结起来，函数指针是一项强大的C/C++特性，它允许你以灵活的方式处理和操作函数，使代码更具通用性和可扩展性。函数指针类型用于定义函数指针的签名，使编译器能够正确推断函数指针的类型。函数模板和函数指针的结合使得你可以编写通用的代码，能够处理多种不同的数据类型和操作。</p><p><em><strong>eg</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> Pred&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Map</span><span class="params">(T s, T e,T x, Pred op)</span> </span>&#123; <span class="keyword">for</span>( ; s != e; ++s ,++x)&#123; *x=<span class="built_in">op</span> (*s); &#125; &#125; </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">square</span> <span class="params">(<span class="type">double</span> )</span></span>&#123;<span class="keyword">return</span> x * x; &#125; </span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;, b[<span class="number">5</span>]; </span><br><span class="line"><span class="type">double</span> d[<span class="number">5</span>] = &#123; <span class="number">1.1</span>,<span class="number">2.1</span>,<span class="number">3.1</span>,<span class="number">4.1</span>,<span class="number">5.1</span>&#125; , c[<span class="number">5</span>]; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Map</span> (a ,a+<span class="number">5</span>,b, Square) ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) </span><br><span class="line">    cout &lt;&lt;b[i] &lt;&lt;<span class="string">&quot; , &quot;</span>;</span><br><span class="line">    cout &lt;&lt;endl ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这段代码运行会实例化出<code>void Map(int * s, int * e, int * x,double ( *op)(double))</code>，请逐步详细解释<code>double ( *op)(double))</code>怎么得到的</p></blockquote><p>在你提供的代码中，<code>Map</code> 函数是一个通用的模板函数，它接受两个迭代器 <code>s</code> 和 <code>e</code>，还有一个指针 <code>x</code>，以及一个函数指针 <code>op</code> 作为参数。<code>Map</code> 函数的目的是将一个操作 <code>op</code> 应用于输入范围 <code>[s, e)</code> 中的每个元素，并将结果存储在输出数组 <code>x</code> 中。</p><p>在你的代码中，<code>Map</code> 函数的调用如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>(a, a+<span class="number">5</span>, b, Square);</span><br></pre></td></tr></table></figure><p>这里传递了以下参数：</p><ul><li><code>a</code> 是一个整数数组的指针，表示输入范围的起始位置。</li><li><code>a+5</code> 是整数数组的指针，表示输入范围的结束位置（不包括）。</li><li><code>b</code> 是一个整数数组的指针，表示输出数组的起始位置。</li><li><code>Square</code> 是一个函数指针，它指向 <code>double Square(double)</code> 函数。</li></ul><p>现在，让我们逐步解释如何得到 <code>double (*op)(double)</code> 类型的函数指针：</p><ol><li><code>Square</code> 是一个函数，它接受一个 <code>double</code> 参数并返回一个 <code>double</code> 值。因此，<code>Square</code> 具有类型 <code>double (double)</code>。</li><li>当你将 <code>Square</code> 作为参数传递给 <code>Map</code> 函数时，编译器会自动进行函数指针的类型推断，将 <code>Square</code> 的类型转化为函数指针类型。</li><li>因为 <code>op</code> 参数在 <code>Map</code> 函数中的类型是 <code>Pred op</code>，而 <code>Pred</code> 是模板参数，所以 <code>op</code> 的类型将与传递给它的参数类型一致。在这种情况下，<code>Square</code> 的类型 <code>double (double)</code> 被转化为 <code>double (*)(double)</code>，这表示一个指向接受 <code>double</code> 参数并返回 <code>double</code> 值的函数指针。</li></ol><p>所以，<code>double (*op)(double)</code> 表示一个函数指针类型，该指针指向一个函数，该函数接受一个 <code>double</code> 参数并返回一个 <code>double</code> 值。在 <code>Map</code> 函数中，它被用于对输入范围中的元素进行操作。</p><h2 id="6泛型程序设计类模板"><a class="markdownIt-Anchor" href="#6泛型程序设计类模板"></a> 6.泛型程序设计·类模板</h2><h3 id="类模板的定义"><a class="markdownIt-Anchor" href="#类模板的定义"></a> 类模板的定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>类型参数<span class="number">1</span> ，<span class="keyword">class</span>类型参数<span class="number">2</span>, .....&gt;<span class="comment">//类型参数表  注： &lt;typename T&gt;=&lt;class T&gt;</span></span><br><span class="line"><span class="keyword">class</span> 类模板名</span><br><span class="line">&#123;</span><br><span class="line">    成员函数和成员变量</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类模板里成员函数的写法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>类型参数<span class="number">1</span>，<span class="keyword">class</span>类型参数<span class="number">2</span>,......&gt;<span class="comment">//类型参数表</span></span><br><span class="line">返回值类型 类模板名 &lt;类型参数名列表&gt;::成员函数名（参数表)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用类模板定义对象的写法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模板名&lt;真实类型参数表&gt;对象名(构造函数实参表);</span><br></pre></td></tr></table></figure><p><em><strong>eg.类模板</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 key;<span class="comment">//关键字</span></span><br><span class="line">    T2 value;<span class="comment">//值</span></span><br><span class="line">    <span class="built_in">Pair</span>(T1 k, T2 v) : <span class="built_in">key</span>(k), <span class="built_in">value</span>(v) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Pair&lt;T1, T2&gt; &amp;p) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">bool</span> Pair&lt;T1, T2&gt;::<span class="keyword">operator</span>&lt;(<span class="type">const</span> Pair&lt;T1, T2&gt; &amp;p) <span class="type">const</span></span><br><span class="line"><span class="comment">//Pair的成员函数operator &lt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> key &lt; p.key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Pair&lt;string, <span class="type">int</span>&gt; <span class="title">student</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">19</span>)</span></span>;<span class="comment">//实例化出一个类Pair&lt;string ,int&gt;</span></span><br><span class="line">    cout &lt;&lt; student.key &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; student.value;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同一个类模板的两个模板类是不兼容的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Pair&lt;string ,<span class="type">int</span>&gt; *p;</span><br><span class="line">&gt;Pair&lt;string , <span class="type">double</span>&gt; a ;</span><br><span class="line">&gt;p=&amp;a; <span class="comment">//wrong</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="函数模板作为类模板成员"><a class="markdownIt-Anchor" href="#函数模板作为类模板成员"></a> 函数模板作为类模板成员</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">Func</span><span class="params">(T2 t)</span> </span>&#123; cout &lt;&lt; t; &#125;<span class="comment">//成员函数模板</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    a.<span class="built_in">Func</span>(<span class="string">&#x27;K&#x27;</span>); <span class="comment">//成员函数模板Func被实例化&lt;char&gt;</span></span><br><span class="line">    a.<span class="built_in">Func</span>(<span class="string">&quot;he1lo&quot;</span>); <span class="comment">//成员函数模板Func再次被实例化&lt;char*&gt;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板与非类型参数"><a class="markdownIt-Anchor" href="#类模板与非类型参数"></a> 类模板与非类型参数</h3><p>类模板的&quot;&lt;类型参数表&gt;”中可以出现非类型参数:<code>template &lt;class T, int size&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CArray</span> &#123;</span><br><span class="line">    T array[size];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            cout &lt;&lt; array[i] &lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">CArray&lt;<span class="type">double</span>, <span class="number">40</span>&gt; a2;</span><br><span class="line">CArray&lt;<span class="type">int</span>, <span class="number">50</span>&gt; a3;<span class="comment">// a2和a3属于不同的类</span></span><br></pre></td></tr></table></figure><h2 id="7-类模板与派生-友元和静态成员变量"><a class="markdownIt-Anchor" href="#7-类模板与派生-友元和静态成员变量"></a> 7. 类模板与派生、友元和静态成员变量</h2><h3 id="类模板与继承"><a class="markdownIt-Anchor" href="#类模板与继承"></a> 类模板与继承</h3><ul><li>类模板从类模板派生</li><li>类模板从模板类派生</li><li>类模板从普通类派生</li><li>普通类从模板类派生</li></ul><h3 id="类模板与友元"><a class="markdownIt-Anchor" href="#类模板与友元"></a> 类模板与友元</h3><ul><li>函数、类、类的成员函数作为类模板的友元</li><li>函数模板作为类模板的友元</li><li>函数模板作为类的友元</li><li>类模板作为类模板的友元</li></ul><h3 id="类模板与static成员"><a class="markdownIt-Anchor" href="#类模板与static成员"></a> 类模板与static成员</h3><ul><li>类模板中可以定义静态成员，那么从该类模板实例化得到的所有类，都包含同样的静态成员。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>() &#123; count ++;&#125;</span><br><span class="line">        ~<span class="built_in">A</span>() &#123; count -- ; &#125;;</span><br><span class="line">        <span class="built_in">A</span>( A &amp;) &#123; count ++ ; &#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">PrintCount</span><span class="params">()</span> </span>&#123; cout &lt;&lt;count &lt;&lt;endl; &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">template</span>&lt;&gt; <span class="type">int</span> A&lt;<span class="type">int</span>&gt; :: count = <span class="number">0</span> ;</span><br><span class="line"> <span class="keyword">template</span>&lt;&gt; <span class="type">int</span> A&lt;<span class="type">double</span>&gt; ::count = <span class="number">0</span> ;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A&lt;<span class="type">int</span>&gt; ia;</span><br><span class="line">    A&lt;<span class="type">double</span>&gt; da;</span><br><span class="line">    <span class="function">ia <span class="title">PrintCount</span><span class="params">()</span> </span>;</span><br><span class="line">    da.<span class="built_in">PrintCount</span>() ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：1</span></span><br><span class="line"><span class="comment">//      1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>“<code>template&lt;&gt; int A&lt;int&gt;::count = 0;</code>” 行和 “<code>template&lt;&gt; int A&lt;double&gt;::count = 0;</code>” 行，对静态成员变量在类外部加以声明是必需的。在 Visual Studio 2008 中，这两行也可以简单地写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int A&lt;int&gt;::count = 0;  </span><br><span class="line">int A&lt;double&gt;::count = 0;  </span><br></pre></td></tr></table></figure><p><code>A&lt;int&gt;</code> 和 <code>A&lt;double&gt; </code>是两个不同的类。虽然它们都有静态成员变量 <code>count</code>，但是显然，<code>A&lt;int&gt; </code>的对象 <code>ia </code>和 <code>A&lt;double&gt;</code> 的对象 <code>da</code> 不会共享一份<code> count</code>。</p><blockquote><p>同一个类模板实例出来类的静态成员变量名字一样，但是存储在不同的位置，不能共享。</p><p><strong>静态成员变量必须拿到类的外面单独声明一下，从包含静态变量的类模板实例化出来的类，同样要把这个类的静态成员拿出来声明一下。生命的同时你可以对他进行初始化也可以不进行初始化</strong></p></blockquote><h4 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h4><p><a href="https://blog.csdn.net/ydxlt/article/details/51111654"># c++类模板遇上static关键字</a></p><p><a href="https://blog.csdn.net/zhizhengguan/article/details/116108271">C/C++编程：类模板中的静态成员</a></p><p><a href="https://www.cnblogs.com/tangzhenqiang/p/4332801.html">C++ 模板 静态成员 定义（实例化）</a></p><p>当<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E6%A8%A1%E6%9D%BF&amp;spm=1001.2101.3001.7020">类模板</a>中有静态成员变量时，情况与普通类的静态成员变量不同。<strong>普通类中的静态成员函数需要在某个代码文件中显式声明，以便在该代码文件编译后可以为静态成员变量留出存储空间以供之后链接使用</strong>。而类模板中的静态变量却无法如此处理。</p><p><strong>C++标准提倡将模板的所有实现都放在头文件中以便编译器可以当场实现模板实例，这样能够避免产生跨目标链接</strong>。但是类模板静态成员变量却与这一提倡冲突。<strong>类模板的静态成员变量是所有同类型的类模板实例共享的一块数据。</strong> <strong>当多个目标文件中声明了同一类模板的同类型实例后，必然会产生跨目标文件链接</strong>。为了与标准所倡导的风格一致，C.++编译器都会对类模板静态成员变量做特殊处理。</p><p>只要静态成员变量的模板与其类模板同时可见，编译器就可针对类模板的静态成员变量做特殊处理：</p><ul><li>在目标文件中写入类模板实例中静态成员变量的初始值。</li><li>将此模板实例静态成员变量做类似外部变量处理，即在汇编代码中为该变量临时分配一个内存地址，但在目标文件中标记该地址所关联的变量名以及链接属性等，以便在随后又链接器修改地址，以正确实现多个类模板实例共享同一内存地址</li></ul><p>在链接时同样需要对类模板静态成员变量做特殊处理。因为类模板静态成员变量的实现以及初始值是写在头文件中，故而在每个包含了该头文件的代码文件中，都会存在若干个该类实例的静态成员变量“副本”。如果在不同文件中都生成了同一模板参数值的实例，则会有多个该实例的“副本”，从而产生冲突。此时，链接器需要解决此冲突。</p><p><em><strong>前言：</strong></em></p><p>在c++中我们可以使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。</p><p>在c++中，我们不能把静态成员放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化，如下面的实例所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明类静态成员，这里不能对它进行初始化赋值</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化类静态成员（通过范围解析符::)</span></span><br><span class="line"><span class="type">int</span> Obj::m_a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 通过对象访问静态属性</span></span><br><span class="line">    Obj o;</span><br><span class="line">    o.m_a = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; o.m_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过类访问静态属性</span></span><br><span class="line">    cout &lt;&lt; Obj::m_a &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c++类模板遇到static</p><p>当类模板中出现static修饰的静态类成员的时候，我们只要按照正常理解就可以了。static的作用是将类的成员修饰成静态的，所谓的静态类成员就是指类的成员为类级别的，不需要实例化对象就可以使用，而且类的所有对象都共享同一个静态类成员，因为类静态成员是属于类而不是对象。那么，类模板的实现机制是通过二次编译原理实现的。c++编译器并不是在第一个编译类模板的时候就把所有可能出现的类型都分别编译出对应的类（太多组合了），而是在第一个编译的时候编译一部分，遇到泛型不会替换成具体的类型（这个时候编译器还不知道具体的类型），而是在第二次编译的时候再将泛型替换成具体的类型（这个时候编译器知道了具体的类型了）。由于类模板的二次编译原理再加上static关键字修饰的成员，当它们在一起的时候实际上一个类模板会被编译成多个具体类型的类，所以，不同类型的类模板对应的static成员也是不同的（不同的类），但相同类型的类模板的static成员是共享的（同一个类）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> T <span class="type">m_t</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T Obj&lt;T&gt;::<span class="type">m_t</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Obj&lt;<span class="type">int</span>&gt; i1,i2,i3;</span><br><span class="line">    i1.<span class="type">m_t</span> = <span class="number">10</span>;</span><br><span class="line">    i2.<span class="type">m_t</span>++;</span><br><span class="line">    i3.<span class="type">m_t</span>++;</span><br><span class="line">    cout &lt;&lt; Obj&lt;<span class="type">int</span>&gt;::<span class="type">m_t</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    Obj&lt;<span class="type">float</span>&gt; f1,f2,f3;</span><br><span class="line">    f1.<span class="type">m_t</span> = <span class="number">10</span>;</span><br><span class="line">    f2.<span class="type">m_t</span>++;</span><br><span class="line">    f3.<span class="type">m_t</span>++;</span><br><span class="line">    cout &lt;&lt; Obj&lt;<span class="type">float</span>&gt;::<span class="type">m_t</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    Obj&lt;<span class="type">char</span>&gt; c1,c2,c3;</span><br><span class="line">    c1.<span class="type">m_t</span> = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    c2.<span class="type">m_t</span>++;</span><br><span class="line">    c3.<span class="type">m_t</span>++;</span><br><span class="line">    cout &lt;&lt; Obj&lt;<span class="type">char</span>&gt;::<span class="type">m_t</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">12</span> </span><br><span class="line">&gt;<span class="number">12</span> </span><br><span class="line">&gt;c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以看到相同类型如<span class="type">int</span>对应的类模板的对象之间的<span class="type">static</span>成员是共享的，不同类型之间如<span class="type">int</span>,<span class="type">float</span>,<span class="type">char</span>对应的类模板的对象之间的<span class="type">static</span>是不共享的。</span><br><span class="line"></span><br><span class="line">## 第八章 标准模板库<span class="built_in">STL</span>(一)</span><br><span class="line">### <span class="number">1.</span>string类</span><br><span class="line">- string类是模板类:</span><br><span class="line">`<span class="keyword">typedef</span> basic_string&lt;<span class="type">char</span>&gt; string`</span><br><span class="line">- 使用string类要包含头文件`&lt;string&gt;`</span><br><span class="line"></span><br><span class="line">- string 对象的长度用成员函数<span class="built_in">length</span>()读取</span><br><span class="line">   - <span class="function">string <span class="title">s</span><span class="params">( <span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">   - cout &lt;&lt; s.<span class="built_in">length</span>() &lt;&lt; endl;</span><br><span class="line">- string支持流读取运算符(直接读入到stringObject）</span><br><span class="line">   - string stringObject;</span><br><span class="line">   - cin &gt;&gt; stringObject; </span><br><span class="line"></span><br><span class="line">- string支持getline函数（读入一行）</span><br><span class="line">   - string s;</span><br><span class="line">   - <span class="built_in">getline</span>(cin,s);</span><br><span class="line"></span><br><span class="line">###<span class="meta"># string的赋值和连接</span></span><br><span class="line">- 用=赋值</span><br><span class="line">   - string <span class="built_in">s1</span>(<span class="string">&quot;cat&quot;</span>), s2</span><br><span class="line">   - ;- s2 = s1;</span><br><span class="line">- 用assign成员函数复制</span><br><span class="line">   - string <span class="built_in">s1</span>(<span class="string">&quot;cat&quot;</span>), s3;</span><br><span class="line">   - s3.<span class="built_in">assign</span>(s1);</span><br><span class="line">- assian 成员函数部分复制</span><br><span class="line">   - string <span class="built_in">s1</span>(<span class="string">&quot;catpig&quot;</span>), s3;</span><br><span class="line">   - s3.<span class="built_in">assign</span>(s1,<span class="number">1</span>，<span class="number">3</span>);</span><br><span class="line">   - <span class="comment">//从s1中下标为1的字符开始复制3个字</span></span><br><span class="line">- 单个字符复制</span><br><span class="line">   - s2[<span class="number">5</span>] = s1[<span class="number">3</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">- 逐个访问string对象中的字符</span><br><span class="line">  - string <span class="built_in">s1</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  - <span class="keyword">for</span>(<span class="type">int</span> i=O;i&lt;s1.<span class="built_in">length</span>();i++)cout &lt;&lt; s1.<span class="built_in">at</span>(i) &lt;&lt; endl;</span><br><span class="line">- 成员函数at会做`范围检查`，如果超出范围，会抛出out_of_range异常，而`下标运算符[]`不做范围检查。</span><br><span class="line">- 用+运算符连接字符串</span><br><span class="line">- 用成员函数append连接字符串</span><br><span class="line">- </span><br><span class="line">#### 比较string</span><br><span class="line">- 用关系运算符比较string的大小</span><br><span class="line">   - =，&gt;，&gt;=,&lt;,&lt;=，!=</span><br><span class="line">   - 用成员函数compare比较string的大小</span><br><span class="line"></span><br><span class="line">#### 子串</span><br><span class="line">- 成员函数 substr</span><br><span class="line"></span><br><span class="line">#### 交换函数</span><br><span class="line">- 成员函数 swap</span><br><span class="line"></span><br><span class="line">#### 查找string中的字符</span><br><span class="line">- 成员函数<span class="built_in">find</span>()</span><br><span class="line">   - 在s1中从前向后查找</span><br><span class="line">- 成员函数<span class="built_in">rfind</span>()</span><br><span class="line">    - 在s1中从后向前查找</span><br><span class="line">- 成员函数<span class="built_in">find_first_of</span>()</span><br><span class="line">   - 在字符串中从前向后查找一个指定字符集中第一个出现的字符位置，并返回该位置的下标。否则返回 `std::string::npos`。</span><br><span class="line">- 成员函数<span class="built_in">find_last_of</span>()</span><br><span class="line">   - 在字符串中从后向前查找一个指定字符集中第一个出现的字符位置，并返回该位置的下标。否则返回 `std::string::npos`。</span><br><span class="line">- 成员函数 <span class="built_in">find_first_not_of</span>()</span><br><span class="line">   - 在字符串中从前向后查找第一个不属于指定字符集的字符，并返回该字符在字符串中的位置下标。否则返回 `std::string::npos`。 </span><br><span class="line">- 成员函数 <span class="built_in">find_last_not_of</span>()</span><br><span class="line">   - 在字符串中从后向前查找第一个不属于指定字符集的字符，并返回该字符在字符串中的位置下标。否则返回 `std::string::npos`。 </span><br><span class="line"></span><br><span class="line">#### 删除string中的字符</span><br><span class="line">- 成员函数<span class="built_in">erase</span>()</span><br><span class="line"></span><br><span class="line">#### 替换string中的字符</span><br><span class="line">- 成员函数<span class="built_in">replace</span>()</span><br><span class="line"></span><br><span class="line">#### 在string中插入字符</span><br><span class="line">- 成员函数<span class="built_in">insert</span>()</span><br><span class="line"></span><br><span class="line">#### 转换成C语言式<span class="type">char</span>*字符串</span><br><span class="line">- 成员函数<span class="built_in">c_str</span>()</span><br><span class="line">   - .<span class="built_in">c_str</span>()返回传统的`<span class="type">const</span> <span class="type">char</span> *`类型字符串，且该字符串以\<span class="number">0</span>’结尾。</span><br><span class="line">- 成员函数<span class="built_in">data</span>()</span><br><span class="line">   - .<span class="built_in">data</span>()返回的是` <span class="type">char</span> *`类型字符串。</span><br><span class="line"></span><br><span class="line">&gt;需要注意的是，<span class="built_in">data</span>()函数返回的指针是指向内部数据的指针，并且在字符串对象被修改或销毁之前都是有效的。但是，应该避免在返回的指针上进行写操作，除非你非常清楚其影响和风险。通常情况下，更推荐使用成员函数<span class="built_in">c_str</span>()来获取字符串的<span class="type">const</span> <span class="type">char</span>*指针，因为它会保证以空字符结尾（null-terminated），并且不允许对返回的指针进行写操作。</span><br><span class="line"></span><br><span class="line">#### 字符串流处理</span><br><span class="line">- 除了标准流和文件流输入输出外，还可以从string进行输入输出;</span><br><span class="line">- 类似istream和osteram进行标准流输入输出，我们用istringstream和ostringstream进行字符串上的输入输出，也称为内存输入输出。</span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h4 id="字符串流处理-字符串输入流-istringstream"><a class="markdownIt-Anchor" href="#字符串流处理-字符串输入流-istringstream"></a> 字符串流处理-字符串输入流 <code>istringstream</code></h4><p><code>istringstream</code> 类是用于从字符串中提取数据的类。同样，我们首先需要包含头文件 <code>&lt;sstream&gt;</code>：</p><p>然后，我们可以使用 <code>istringstream</code> 来构建一个字符串流对象，并使用 <code>&gt;&gt;</code> 运算符从该流中提取数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">input</span> <span class="params">( <span class="string">&quot; Input test 123 4.7 A&quot;</span>)</span></span>;<span class="function">istringstream <span class="title">inputstring</span> <span class="params">(input)</span> </span>;</span><br><span class="line">string string1 , string2 ;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">double</span> d;<span class="type">char</span> c;</span><br><span class="line">inputstring &gt;&gt;string1 &gt;&gt;string2 &gt;&gt;i &gt;</span><br><span class="line">d &gt;&gt;c;</span><br><span class="line">cout &lt;&lt;string1 &lt;&lt;endl &lt;&lt;string2 &lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; i &lt;endl &lt;&lt; d &lt;&lt; endl &lt;&lt;c &lt;&lt;endl;<span class="type">long</span> L;</span><br><span class="line"><span class="keyword">if</span> (inputstring &gt;&gt;L) cout &lt;&lt;<span class="string">&quot;long\n&quot;</span> ;<span class="keyword">else</span> cout &lt;&lt;<span class="string">&quot;ermpty \n&quot;</span> ;</span><br></pre></td></tr></table></figure><p><em><strong>输出：</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lnput</span><br><span class="line">test</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">4.7</span></span><br><span class="line">A</span><br><span class="line">empty</span><br></pre></td></tr></table></figure><h4 id="字符串流处理-字符串输出流-ostringstream"><a class="markdownIt-Anchor" href="#字符串流处理-字符串输出流-ostringstream"></a> 字符串流处理-字符串输出流 <code>ostringstream</code></h4><p><code>ostringstream</code> 类是用于将其他数据类型（如整数、浮点数、字符串等）转换为字符串的类。</p><p>然后，我们可以使用 <code>ostringstream</code> 来构建一个字符串流对象，并使用 <code>&lt;&lt;</code> 运算符将数据写入该流：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostringstream oss;</span><br><span class="line"><span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">string text = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;The number is: &quot;</span> &lt;&lt; number &lt;&lt; <span class="string">&quot;. The text is: &quot;</span> &lt;&lt; text;</span><br><span class="line">cout &lt;&lt; oss.<span class="built_in">str</span>() &lt;&lt; endl; </span><br></pre></td></tr></table></figure><p><em><strong>输出：</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The number is: <span class="number">42.</span> The text is: Hello, World!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习笔记</title>
      <link href="/2023/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="本笔记依据计算机网络自顶向下整理"><a class="markdownIt-Anchor" href="#本笔记依据计算机网络自顶向下整理"></a> 本笔记依据《计算机网络（自顶向下）》整理</h2>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构学习笔记</title>
      <link href="/2023/09/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本笔记依据《数据结构（c语言版）》（第二版）殷人昆和《数据结构精讲与习题详解》整理</p><hr /><h1 id="第一章绪论"><a class="markdownIt-Anchor" href="#第一章绪论"></a> 第一章绪论</h1><h2 id="11数据结构的概念及分类"><a class="markdownIt-Anchor" href="#11数据结构的概念及分类"></a> 1.1数据结构的概念及分类</h2><h3 id="112与数据结构相关的基本术语"><a class="markdownIt-Anchor" href="#112与数据结构相关的基本术语"></a> 1.1.2与数据结构相关的基本术语</h3><h4 id="7抽象数据类型adt"><a class="markdownIt-Anchor" href="#7抽象数据类型adt"></a> 7.抽象数据类型ADT</h4><blockquote><p>思考题：系统开发中数据设计三视图为数据内容，数据结构和数据流其中有关数据结构的道路主要涉及数据元素之间的关系，那么数据元素内容应在什么时候考虑？</p></blockquote><p>数据元素的内容应在系统开发的早期阶段考虑，并且通常是在数据设计的第一个视图——数据内容视图中进行定义和确定的。数据设计的三个视图包括数据内容视图、数据结构视图和数据流视图，这些视图通常是并行进行的，但它们之间存在着一定的依赖关系。</p><p>以下是关于何时考虑数据元素内容的一些重要考虑因素：</p><ol><li><strong>需求分析阶段：</strong> 在系统开发的早期，首先要进行需求分析。这一阶段涉及与项目相关的各方（包括业务用户、利益相关者等）合作，以了解他们的需求和期望。在这个过程中，要确定系统需要收集、存储和处理哪些数据。这有助于确定数据元素的内容。</li><li><strong>数据模型设计：</strong> 在需求分析之后，您可以开始设计数据模型，其中包括定义数据元素的内容。这通常涉及到创建实体-关系图（ER图）或其他数据建模工具，以明确定义数据元素之间的关系、属性和约束。</li><li><strong>数据字典：</strong> 创建数据字典是一种记录数据元素内容和定义的方式。数据字典包含了关于每个数据元素的详细信息，包括名称、数据类型、长度、格式、描述、取值范围等。这是确保整个开发团队对数据元素有清晰共识的重要工具。</li><li><strong>数据结构视图：</strong> 一旦数据元素的内容确定，您可以开始考虑数据元素之间的关系和如何组织它们以满足系统的功能需求。这会涉及到定义表、字段、键和约束等。</li></ol><p>总之，数据元素内容的考虑应该尽早进行，并与系统开发的其他阶段紧密协调。这有助于确保系统可以有效地收集、存储和处理所需的数据，同时也有助于减少后期开发中的变更和修正。在整个系统开发过程中，数据设计的三视图都需要不断协同工作，以确保数据的一致性、完整性和可用性。</p><h3 id="113数据结构的分类"><a class="markdownIt-Anchor" href="#113数据结构的分类"></a> 1.1.3数据结构的分类</h3><h4 id="2逻辑结构与存储结构"><a class="markdownIt-Anchor" href="#2逻辑结构与存储结构"></a> 2.逻辑结构与存储结构</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce16be58974646aeb04cbe94c7b87829~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3184&amp;h=440&amp;s=91746&amp;e=jpg&amp;b=fefefe" alt="映射到_使用.jpg" /></p><h4 id="3逻辑结果的分类"><a class="markdownIt-Anchor" href="#3逻辑结果的分类"></a> 3.逻辑结果的分类</h4><ul><li>（1）线性结构</li><li>（2）非线性结构</li></ul><blockquote><p>多维数组和广义表属于线性表的扩展，从宏观山看，不具有线性结构的一对一的特点，从可共享情况来看，又有多对多的特点</p></blockquote><ol><li><strong>多维数组（Multidimensional Array）：</strong> 多维数组是一种扩展的线性表，它可以看作是多个一维数组的组合。多维数组中的元素是通过多个索引（通常是多维的）来访问的。这意味着每个元素可以由多个维度的索引组合来唯一确定，因此不再具有传统线性表的一对一结构。例如，在二维数组中，元素可以通过行索引和列索引来定位，这是多对多的关系。</li><li><strong>广义表（Generalized List）：</strong> 广义表是一种更灵活的数据结构，它允许在一个表中包含多种类型的元素，包括原子元素和子表（广义表的嵌套）。这使得广义表可以表示更复杂的数据结构，如树状结构或图状结构。因为广义表可以包含多个元素，其中一些可以是子表，因此也具有多对多的特点。</li></ol><p>从宏观角度来看，多维数组和广义表都在某种程度上扩展了线性表的概念，允许更复杂的数据结构和多对多的关系。这使它们更适合表示和处理更复杂的数据组织需求。</p><p>从可共享性的角度来看，这两种数据结构也可以包含多对多的关系。在多维数组中，多个元素可以共享相同的行或列，而在广义表中，多个元素可以共享相同的子表。这种共享性使得数据的组织更加灵活，可以更有效地表示一些复杂的数据关系。</p><blockquote><p>思考题：数据的逻辑结构是否可以独立于存储结构来考虑，反制数据的特殊结构是否可以独立于逻辑结构来考虑？</p></blockquote><p>数据的逻辑结构和存储结构通常是相互关联的，但在某些情况下可以独立考虑，具体取决于数据管理和操作的需求以及系统设计的目标。让我们更详细地探讨这两种情况：</p><ol><li><p><strong>逻辑结构独立于存储结构：</strong></p><p>在某些情况下，您可以定义数据的逻辑结构，而不必关心其具体的存储方式。这通常发生在高层数据模型的设计阶段，例如在数据库设计中。您可以首先定义数据的实体、属性、关系和约束等逻辑结构，而不必考虑如何在物理存储层面实现它们。数据库管理系统会负责将逻辑结构映射到物理存储结构，以便高效地存储和检索数据。这种分离逻辑和物理结构的方法有助于数据抽象和数据独立性，使系统更易于维护和扩展。</p></li><li><p><strong>存储结构独立于逻辑结构：</strong></p><p>在另一方面，有些情况下，您可能需要关注数据的存储方式，而不考虑其逻辑结构。这可能出现在低层数据存储和处理的情况下，例如在编程中。在这种情况下，您可能需要考虑如何在内存或磁盘上组织和访问数据，以便实现特定的算法或性能优化。这可能涉及到数据结构的选择和数据布局的优化，而不必关心数据的逻辑关系。</p></li></ol><p>总的来说，逻辑结构和存储结构的关系通常是相互关联的，但可以根据需要独立考虑。在实际应用中，合理的抽象和分离可以提高系统的可维护性、可扩展性和性能。不过，在设计和开发过程中，需要确保逻辑结构和存储结构之间的一致性，以确保数据在逻辑和物理层面的正确性和有效性。这通常需要仔细的规划和协同工作，以平衡逻辑和存储需求。</p><blockquote><p>思考题：集合结构中的元素之间没有特定的联系，如图那么集合结构属于线性结构还是非线性结构？这是否意味着需要借助其他结构来表示？</p></blockquote><h3 id="114数据结构的存储结构"><a class="markdownIt-Anchor" href="#114数据结构的存储结构"></a> 1.1.4数据结构的存储结构</h3><p>数据结构根据存取方法的不同，可分为3类:</p><ul><li>(1）直接存取结构。可以按序号直接存取某一无素，如向量、多维数组、散列表等。</li><li>(2）顺序存取结构。只能从序列中第一个元素起，按逻辑顺序逐个访问元素，如各种链表结构(单链表、循环链表、双向链表、二叉或三叉链表、图的邻接表等）就属于此类。</li><li>(3）索引结构。通过关键码来识别和访问元素，如线性索引、多叉查找树等。</li></ul><p>一般地,常用的4种存储方式如下:</p><p>(1）顺序存储方式。该存储方式把逻辑上相邻的元素存放到物理位置上相邻的存储单元中，数据元素之间的逻辑关系由存储单元的邻接位置关系来体现。由此得到的存储结构称为顺序存储结构，通常，顺序存储结构可借助程序设计语言中的一维数组来描述。</p><p>(2）链接存储方式。该存储方式不要求逻辑上相邻的元素在物理位置上也相邻，元素之间的逻辑关系由附加的链接指针指示。由此得到的存储结构称为链表存储结构，通常，链表存储结构要借助程序设计语言中的指针类型来描述。</p><p>(3）索引存储方式。该存储方式在存储元素信息的同时还建立索引表。索引表中每一项称为索引项,索引项的形式是（关键码,地址)。关键码是能够标识一个元素的数据项。按照索引项是针对每个元素还是针对一组元素，可分为稠密索引和稀疏索引。此外，根据索引表是一层还是多层,可分为线性索引和多级索引。<br />(4）散列存储方式。该存储方式根据元素的关键码通过一个函数计算直接得到该元素的存储地址。</p><p>上述4种基本的存储结构既可以单独使用，也可以组合起来建立数据结构的存储结构。同一种逻辑结构可以有不同的存储结构。选择何种存储结构来表示相应的逻辑结构，要视不同的资源要求而定。对于数据结构的实现者来说，选择存储结构主要考虑的要素如下:</p><ul><li><p>(1）访问频率。对于其内容需要经常访问但修改不频繁的数据结构,宜采取存取速度快、存储利用率高的存储结构。</p></li><li><p>(2）修改频率。对于其内容经常需要修改的数据结构,宜采用修改速度快、尽可能不移动元素的存储结构。</p></li><li><p>(3）安全保密。对于安全保密要求高的数据结构，宜采用面向对象方法，用类的继承式设计存储结构，用公有(public)、私有(private）和保护(protected）来划定访问级别。要考虑运算的时间和空间要求以及算法的简单性。</p></li></ul><h3 id="115定义在数据结构上的操作"><a class="markdownIt-Anchor" href="#115定义在数据结构上的操作"></a> 1.1.5定义在数据结构上的操作</h3><p>定义在数据结构上的操作是一个操作集,它提供了操纵数据结构的各种运算。对于不同的数据结构，操作集所包含的操作也有所不同。基本的操作有以下几种:</p><ol><li>创建。构建属于数据结构的一个实例，对其所有成分赋予初值。</li><li>销毁。撤销属于数据结构的一个实例，释放实例占用的动态分配的存储空间。</li><li>查找。按照给定值搜索数据结构的一个实例内是否有满足要求的元素或结点。</li><li>插入。把新元素按照指定位置插入到数据结构的一个实例内。</li><li>删除。删去数据结构的一个实例内指定的元素或结点。</li><li>排序。把线性结构内所有元素按照指定域的值从小到大或从大到小重新排列。</li></ol><blockquote><p>思考题为何在数据结构课程中既要讨论各种在解决问题时可能遇到的典型的逻辑结构还要讨论这些逻辑结构的存储映像(存储结构)，此外还要讨论这种数据结构的相关操作(基本运算）及其实现?<br />在数据结构课程中涵盖逻辑结构、存储结构以及相关操作的原因有以下几点：</p></blockquote><ol><li><strong>理解问题和选择合适的数据结构：</strong> 数据结构是解决问题的关键。在解决现实世界的问题时，我们首先需要选择适当的数据结构，以便高效地组织和操作数据。了解不同的逻辑结构，如栈、队列、链表、树、图等，有助于学生理解何时应该使用哪种数据结构，以满足问题的需求。</li><li><strong>存储映像和内存管理：</strong> 理解存储结构有助于学生了解数据在计算机内部的物理存储方式。这对于内存管理和性能优化至关重要。不同的存储结构会对数据的访问和操作产生不同的影响，学生需要知道如何选择适当的存储结构以及如何有效地使用内存。</li><li><strong>操作和算法设计：</strong> 数据结构的基本操作（基本运算）包括插入、删除、查找、遍历等。学生需要了解这些操作的特点和复杂度分析，以便能够设计高效的算法。讨论这些操作还有助于学生理解数据结构的功能和用途。</li><li><strong>实际应用和编程：</strong> 数据结构不仅仅是理论概念，它们在实际编程中起着关键作用。学生需要知道如何实现各种数据结构，以便将它们应用到编程项目中。这包括了解如何在编程语言中表示和操作数据结构。</li></ol><p>综上所述，数据结构课程的综合性质旨在帮助学生建立解决问题的整体思维和编程能力。逻辑结构、存储结构和相关操作之间的关系密切相关，学生通过学习这些内容可以更好地理解和应用数据结构，以解决各种计算和信息处理问题。这些知识不仅对计算机科学专业的学生有价值，对于任何需要处理和组织数据的领域都具有广泛的适用性。</p><h3 id="121-c语言的数据类型"><a class="markdownIt-Anchor" href="#121-c语言的数据类型"></a> 1.2.1 C语言的数据类型</h3><h4 id="1构造性struct"><a class="markdownIt-Anchor" href="#1构造性struct"></a> 1.构造性struct</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">long</span> number;</span><br><span class="line"><span class="type">char</span> *name;</span><br><span class="line"><span class="type">float</span> score;</span><br><span class="line"><span class="type">int</span> code;</span><br><span class="line">&#125;Examinee;</span><br></pre></td></tr></table></figure><blockquote><p>思考题： 如果结构定义时没有写typedef，定义的是一个类型吗？通过Examinee s1定义的考生记录s1是否属于该类型的变量？<br />如果在结构定义时没有使用typedef，那么该结构定义并不会创建一个新的类型，而只会定义一个结构。这意味着Examinee只是一个结构的标签或标识符，而不是一个独立的数据类型。</p></blockquote><p>当您使用Examinee s1来定义考生记录s1时，s1不会被认为是该类型的变量，因为在没有使用typedef的情况下，Examinee只是一个结构的标签，而不是数据类型。要使s1成为该类型的变量，您需要使用typedef来为结构定义创建一个新的数据类型。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> number;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">    <span class="type">int</span> code;</span><br><span class="line">&#125; Examinee;</span><br><span class="line"></span><br><span class="line">Examinee s1; <span class="comment">// 现在s1是Examinee类型的变量</span></span><br></pre></td></tr></table></figure><p>通过这种方式，您定义了一个Examinee类型的变量s1，它可以存储一个考生记录的数据。如果没有使用typedef，s1将无法识别Examinee作为类型，因此会导致编译错误。使用typedef有助于提高代码的可读性和可维护性，因为它允许您为结构定义创建更具有意义的数据类型名称。</p>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言入门</title>
      <link href="/2023/08/13/GO%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
      <url>/2023/08/13/GO%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>笔记根据GO圣经</p></blockquote><hr /><h2 id="程序结构"><a class="markdownIt-Anchor" href="#程序结构"></a> 程序结构</h2><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><h4 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h4><ol><li><a href="https://books.studygolang.com/gopl-zh/ch2/ch2-03.html">2.3.2. 指针</a>  指针是实现标准库中flag包的关键技术，它使用命令行参数来设置对应变量的值，而这些对应命令行标志参数的变量可能会零散分布在整个程序中。为了说明这一点，在早些的echo版本中，就包含了两个可选的命令行参数：<code>-n</code>用于忽略行尾的换行符，<code>-s sep</code>用于指定分隔字符（默认是空格）。</li></ol><h4 id="new"><a class="markdownIt-Anchor" href="#new"></a> new</h4><ol><li>new另一个创建变量的方法是调用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为<code>*T</code>。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="type">int</span>)   <span class="comment">// p, *int 类型, 指向匿名的 int 变量</span></span><br><span class="line">fmt.Println(p)  <span class="comment">// &quot;0xc00001e218&quot;</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// &quot;0&quot;</span></span><br><span class="line">*p = <span class="number">2</span>          <span class="comment">// 设置 int 匿名变量的值为 2</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// &quot;2&quot;</span></span><br></pre></td></tr></table></figure><p>用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用new(T)。换言之，new函数类似是一种语法糖，而不是一个新的基础概念。</p><blockquote><p>语法糖：在编程中，“语法糖”（Syntactic Sugar）是一种语法上的便利特性，它不会引入新的基础概念，但是能够使代码更加简洁、易读或者方便。</p><p> 对于Go语言中的<code>new(T)</code>函数来说，确实可以被称为一种语法糖。虽然它看起来像一个函数调用，但它实际上并不创建新的基础概念。它的功能非常简单，只是为指定类型<code>T</code>分配了足够的内存，并返回指向该内存的指针。</p><p> 与使用普通的变量声明语句来创建变量相比，<code>new(T)</code>的确省去了为临时变量取名的步骤，但实际上并没有引入任何新的概念。使用<code>new(T)</code>只是一种更为简洁的方式来动态分配内存，返回一个指针，使得代码更加清晰和便于使用。</p><p> 这里的&quot;语法糖&quot;一词是用来比喻编程语言中的某种特性，这种特性并不是必需的，也不会引入新的语言规则或语义，而只是为了提高代码的可读性、简洁性或使用便捷性。类似于人们在喝咖啡时可以添加糖来提升口感，但糖本身并非必需的咖啡成分。语法糖是一种让代码更甜的编程技巧。</p></blockquote><ol start="2"><li>在Go语言中，<code>new</code>是一个预定义的函数，而不是关键字。因此，你可以使用<code>new</code>作为变量名来重新定义它，并将其赋予不同的类型。</li></ol><p>在你提供的例子中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delta</span><span class="params">(old, <span class="built_in">new</span> <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span> - old</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你在函数<code>delta</code>的参数列表中使用了<code>int</code>类型的变量名<code>new</code>，这会导致在函数体内部无法直接使用预定义的<code>new</code>函数。由于函数参数优先级高于预定义函数，函数参数名会覆盖预定义的<code>new</code>函数。</p><p>在这种情况下，如果你需要使用预定义的<code>new</code>函数，你可以通过使用包名进行限定来调用它，例如<code>fmt.Println(new(...))</code>。这样做可以明确告诉编译器你想要调用预定义的<code>new</code>函数。</p><p>需要注意的是，虽然在Go语言中可以重新定义<code>new</code>作为变量名，但这样的命名并不推荐，因为这样会导致代码可读性下降，并可能造成混淆。通常，我们应该遵循良好的命名规范，避免使用与预定义函数或关键字相同的名称来定义变量或函数名。这有助于保持代码的清晰和易读性。</p><h4 id="变量的生命周期"><a class="markdownIt-Anchor" href="#变量的生命周期"></a> 变量的生命周期</h4><p>变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。<br />那么Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。</p><p>因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。</p><p>编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var global *int</span><br><span class="line"></span><br><span class="line">func f() &#123;</span><br><span class="line">    var x int</span><br><span class="line">    x = 1</span><br><span class="line">    global = &amp;x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func g() &#123;</span><br><span class="line">    y := new(int)</span><br><span class="line">    *y = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量<code>*y</code>将是不可达的，也就是说可以马上被回收的。因此，<code>*y</code>并没有从函数g中逃逸，编译器可以选择在栈上分配<code>*y</code>的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。</p><p>Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。</p><h3 id="赋值"><a class="markdownIt-Anchor" href="#赋值"></a> 赋值</h3><h4 id="元组赋值"><a class="markdownIt-Anchor" href="#元组赋值"></a> 元组赋值</h4><p>通常，这类函数会用额外的返回值来表达某种错误类型，例如os.Open是用额外的返回值返回一个error类型的错误，还有一些是用来返回布尔值，通常被称为ok。在稍后我们将看到的三个操作都是类似的用法。如果map查找（§4.3）、类型断言（§7.10）或通道接收（§8.4.2）出现在赋值语句的右边，它们都可能会产生两个结果，有一个额外的布尔结果表示操作是否成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v, ok = m[key]             // map lookup</span><br><span class="line">v, ok = x.(T)              // type assertion</span><br><span class="line">v, ok = &lt;-ch               // channel receive</span><br></pre></td></tr></table></figure><p>译注：map查找（§4.3）、类型断言（§7.10）或通道接收（§8.4.2）出现在赋值语句的右边时，并不一定是产生两个结果，也可能只产生一个结果。对于只产生一个结果的情形，map查找失败时会返回零值，类型断言失败时会发生运行时panic异常，通道接收失败时会返回零值（阻塞不算是失败）。例如下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v = m[key]                // map查找，失败时返回零值</span><br><span class="line">v = x.(T)                 // type断言，失败时panic异常</span><br><span class="line">v = &lt;-ch                  // 管道接收，失败时返回零值（阻塞不算是失败）</span><br><span class="line"></span><br><span class="line">_, ok = m[key]            // map返回2个值</span><br><span class="line">_, ok = mm[&quot;&quot;], false     // map返回1个值</span><br><span class="line">_ = mm[&quot;&quot;]                // map返回1个值</span><br></pre></td></tr></table></figure><p>和变量声明一样，我们可以用下划线空白标识符<code>_</code>来丢弃不需要的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_, err = io.Copy(dst, src) // 丢弃字节数</span><br><span class="line">_, ok = x.(T)              // 只检测类型，忽略具体值</span><br></pre></td></tr></table></figure><h3 id="类型"><a class="markdownIt-Anchor" href="#类型"></a> 类型</h3><p>为了说明类型声明，我们将不同温度单位分别定义为不同的类型：</p><p><em><a href="http://gopl.io/ch2/tempconv0">gopl.io/ch2/tempconv0</a></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Package tempconv performs Celsius and Fahrenheit temperature computations.</span><br><span class="line">package tempconv</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Celsius float64    // 摄氏温度</span><br><span class="line">type Fahrenheit float64 // 华氏温度</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    AbsoluteZeroC Celsius = -273.15 // 绝对零度</span><br><span class="line">    FreezingC     Celsius = 0       // 结冰点温度</span><br><span class="line">    BoilingC      Celsius = 100     // 沸水温度</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func CToF(c Celsius) Fahrenheit &#123; return Fahrenheit(c*9/5 + 32) &#125;</span><br><span class="line"></span><br><span class="line">func FToC(f Fahrenheit) Celsius &#123; return Celsius((f - 32) * 5 / 9) &#125;</span><br></pre></td></tr></table></figure><p>我们在这个包声明了两种类型：Celsius和Fahrenheit分别对应不同的温度单位。它们虽然有着相同的底层类型float64，但是它们是不同的数据类型，因此它们不可以被相互比较或混在一个表达式运算。刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致的错误；因此需要一个类似Celsius(t)或Fahrenheit(t)形式的显式转型操作才能将float64转为对应的类型。Celsius(t)和Fahrenheit(t)是类型转换操作，它们并不是函数调用。类型转换不会改变值本身，但是会使它们的语义发生变化。另一方面，CToF和FToC两个函数则是对不同温度单位下的温度进行换算，它们会返回不同的值。</p><p>对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型（译注：如果T是指针类型，可能会需要用小括弧包装T，比如<code>(*int)(0)</code>）。只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。如果x是可以赋值给T类型的值，那么x必然也可以被转为T类型，但是一般没有这个必要。</p><blockquote><p>例子1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">package</span> main</span><br><span class="line">&gt;<span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">&gt;)</span><br><span class="line">&gt;<span class="keyword">type</span> Celsius <span class="type">float64</span>    <span class="comment">// 摄氏温度</span></span><br><span class="line">&gt;<span class="keyword">type</span> Fahrenheit <span class="type">float64</span> <span class="comment">// 华氏温度</span></span><br><span class="line">&gt;<span class="keyword">const</span> (</span><br><span class="line">   AbsoluteZeroC Celsius = <span class="number">-273.15</span> <span class="comment">// 绝对零度</span></span><br><span class="line">  FreezingC     Celsius = <span class="number">0</span>       <span class="comment">// 结冰点温度</span></span><br><span class="line">   BoilingC      Celsius = <span class="number">100</span>     <span class="comment">// 沸水温度</span></span><br><span class="line">&gt;)</span><br><span class="line">&gt;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   c := Celsius(<span class="number">100</span>)</span><br><span class="line">   f := Fahrenheit(<span class="number">15</span>)</span><br><span class="line">   fmt.Println(c+f)</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>报错： invalid operation: c + f (mismatched types Celsius and Fahrenheit)</p></blockquote><p>在Go语言中，不能直接将不同类型的自定义类型进行相加，即使它们的底层类型是相同的。虽然 <code>Celsius</code> 和 <code>Fahrenheit</code> 都是基于 <code>float64</code> 类型的自定义类型，但它们被视为完全不同的类型。</p><p>这是因为在Go语言中，类型的名称包括了类型本身和其所属的包。在这种情况下，<code>Celsius</code> 和 <code>Fahrenheit</code> 都是包级别的类型，即使它们的底层类型都是 <code>float64</code>，Go语言也不会自动进行类型转换。因此，编译器会报错，提示类型不匹配。</p><p>要实现相加操作，我们需要显式地将它们转换为相同的类型。在之前的修正代码中，我们使用了类型转换将 <code>Celsius</code> 和 <code>Fahrenheit</code> 分别转换为 <code>float64</code> 类型，然后再进行相加。最后，我们再将相加后的结果转换为 <code>Celsius</code> 类型。这样做是因为Go语言强制执行类型安全，不会自动进行不同类型的隐式转换。</p><p>所以，为了在Go语言中相加不同类型的值，我们需要显式地进行类型转换。这样可以确保类型安全，避免意外的类型错误。</p><blockquote><p>例2：该代码能过编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">double</span> Celsius;</span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">double</span> Fahrenheit;</span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   Celsius c = <span class="number">100</span>;</span><br><span class="line">   Fahrenheit f = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, c+f);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li>请注意，C语言并不执行类型检查，所以编译器不会报错，即使相加的类型不同。这可能导致潜在的运行时错误或意外的结果。因此，在C语言中，程序员需要特别小心，并确保进行适当的类型转换以避免错误。</li></ul><blockquote><p>因此正确的形式应为</p></blockquote><p>在C语言中，不同类型的自定义类型不能直接相加，就像Go语言中一样。C语言也要求显式地进行类型转换，以确保类型安全。</p><p>在C语言中，我们可以通过显式类型转换将不同类型的值进行相加。例如，假设我们有两个自定义类型 <code>Celsius</code> 和 <code>Fahrenheit</code>，它们都是基于 <code>double</code> 类型的自定义类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cCopy code</span><br><span class="line">typedef double Celsius;</span><br><span class="line">typedef double Fahrenheit;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Celsius c = 100;</span><br><span class="line">    Fahrenheit f = 15;</span><br><span class="line"></span><br><span class="line">    // 需要显式类型转换</span><br><span class="line">    double sum = (double)c + (double)f;</span><br><span class="line">    printf(&quot;%lf\n&quot;, sum);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个C语言代码中，我们将 <code>Celsius</code> 和 <code>Fahrenheit</code> 都定义为 <code>double</code> 的类型别名。然后，在 <code>main</code> 函数中，我们声明一个 <code>Celsius</code> 类型的变量 <code>c</code> 和一个 <code>Fahrenheit</code> 类型的变量 <code>f</code>。由于它们都是 <code>double</code> 的别名，我们需要在相加前进行显式类型转换。</p><h3 id="包和文件"><a class="markdownIt-Anchor" href="#包和文件"></a> 包和文件</h3><h4 id="包的初始化"><a class="markdownIt-Anchor" href="#包的初始化"></a> 包的初始化</h4><blockquote><p>这个算法？</p></blockquote><p>下面的代码定义了一个PopCount函数，用于返回一个数字中含二进制1bit的个数。它使用init初始化函数来生成辅助表格pc，pc表格用于处理每个8bit宽度的数字含二进制的1bit的bit个数，这样的话在处理64bit宽度的数字时就没有必要循环64次，只需要8次查表就可以了。（这并不是最快的统计1bit数目的算法，但是它可以方便演示init函数的用法，并且演示了如何预生成辅助表格，这是编程中常用的技术）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> popcount</span><br><span class="line"></span><br><span class="line"><span class="comment">// pc[i] is the population count of i.</span></span><br><span class="line"><span class="keyword">var</span> pc [<span class="number">256</span>]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> pc &#123;</span><br><span class="line">        pc[i] = pc[i/<span class="number">2</span>] + <span class="type">byte</span>(i&amp;<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PopCount returns the population count (number of set bits) of x.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PopCount</span><span class="params">(x <span class="type">uint64</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int</span>(pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">0</span>*<span class="number">8</span>))] +</span><br><span class="line">        pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">1</span>*<span class="number">8</span>))] +</span><br><span class="line">        pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">2</span>*<span class="number">8</span>))] +</span><br><span class="line">        pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">3</span>*<span class="number">8</span>))] +</span><br><span class="line">        pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">4</span>*<span class="number">8</span>))] +</span><br><span class="line">        pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">5</span>*<span class="number">8</span>))] +</span><br><span class="line">        pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">6</span>*<span class="number">8</span>))] +</span><br><span class="line">        pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">7</span>*<span class="number">8</span>))])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>译注：对于pc这类需要复杂处理的初始化，可以通过将初始化逻辑包装为一个匿名函数处理，像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pc[i] is the population count of i.</span></span><br><span class="line"><span class="keyword">var</span> pc [<span class="number">256</span>]<span class="type">byte</span> = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (pc [<span class="number">256</span>]<span class="type">byte</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> pc &#123;</span><br><span class="line">        pc[i] = pc[i/<span class="number">2</span>] + <span class="type">byte</span>(i&amp;<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>要注意的是在init函数中，range循环只使用了索引，省略了没有用到的值部分。循环也可以这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> pc &#123;</span><br></pre></td></tr></table></figure><h3 id="作用域"><a class="markdownIt-Anchor" href="#作用域"></a> 作用域</h3><p>作用域：声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。<br />生命周期：一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。</p><blockquote><p>注意：任何在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。</p></blockquote><h3 id="slice"><a class="markdownIt-Anchor" href="#slice"></a> slice</h3><ol><li>如果切片操作超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展了slice，因为新slice的长度会变大：另外，字符串的切片操作和[]byte字节类型切片的切片操作是类似的。都写作x[m:n]，并且都是返回一个原始字节序列的子序列，底层都是共享之前的底层数组，因此这种操作都是常量时间复杂度。x[m:n]切片操作对于字符串则生成一个新字符串，如果x是[]byte的话则生成一个新的[]byte。</li></ol><p>因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名（§2.3.2）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">months := [...]<span class="type">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;January&quot;</span>, <span class="comment">/* ... */</span>, <span class="number">12</span>: <span class="string">&quot;December&quot;</span>&#125;</span><br><span class="line">summer := months[<span class="number">6</span>:<span class="number">9</span>]</span><br><span class="line">fmt.Println(summer) <span class="comment">// [&quot;June&quot; &quot;July&quot; &quot;August&quot;]</span></span><br><span class="line">fmt.Println(summer[:<span class="number">20</span>]) <span class="comment">// panic: out of range</span></span><br><span class="line"></span><br><span class="line">endlessSummer := summer[:<span class="number">5</span>] <span class="comment">// extend a slice (within capacity)</span></span><br><span class="line">fmt.Println(endlessSummer)  <span class="comment">// &quot;[June July August September October]&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>From：ChatGPT：在Go语言中，对切片进行操作时，有两个相关的属性：<code>len()</code>和<code>cap()</code>。</p><ul><li><code>len(s)</code>：返回切片<code>s</code>的当前长度，表示切片中实际存储的元素个数。</li><li><code>cap(s)</code>：返回切片<code>s</code>的容量，表示切片底层数组的大小。</li></ul><ol><li><code>fmt.Println(summer[:20])</code>：在这里，尝试获取<code>summer</code>切片中索引0到19的元素。如果<code>summer</code>切片的长度（<code>len(summer)</code>）小于20，那么这个操作将超出切片的长度范围，会导致运行时错误，触发<code>panic</code>异常。这是因为Go语言在切片操作时会检查索引是否在合法范围内，不允许访问超出切片长度的索引。</li><li><code>endlessSummer := summer[:5]</code>：这里创建了一个新的切片<code>endlessSummer</code>，它是从<code>summer</code>切片的索引0开始，一直到索引4（包括索引4）的一个子切片。这个操作并没有超出<code>summer</code>切片的容量（<code>cap(summer)</code>），因为切片容量表示底层数组的大小，而<code>endlessSummer</code>的长度（<code>len(endlessSummer)</code>）为5，在<code>summer</code>的容量范围内。因此，这个操作是合法的。</li></ol><p>总结：对于切片操作，当索引超出切片的长度（<code>len()</code>）时，会导致<code>panic</code>异常。但是，如果切片操作在切片的容量范围内（<code>cap()</code>），可以有效地扩展切片。这种扩展产生一个新的切片，新切片的长度可以大于原始切片的长度。要注意的是，在扩展切片时，不能超出切片的容量，否则也会触发<code>panic</code>异常。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python切片完全指南(语法篇)</title>
      <link href="/2023/06/20/Python-%E5%88%87%E7%89%87%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97-%E8%AF%AD%E6%B3%95%E7%AF%87/"/>
      <url>/2023/06/20/Python-%E5%88%87%E7%89%87%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97-%E8%AF%AD%E6%B3%95%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载原文链接<a href="https://zhuanlan.zhihu.com/p/79541418#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C">胡小涂</a></p></blockquote><h2 id="什么是切片操作"><a class="markdownIt-Anchor" href="#什么是切片操作"></a> 什么是切片操作</h2><p>在Python中,<strong>切片(slice)</strong> 是对序列型对象(如list, string, tuple)的一种高级索引方法。普通索引只取出序列中 <strong>一个下标</strong>对应的元素，而切片取出序列中<strong>一个范围</strong>对应的元素，这里的范围不是狭义上的连续片段。下面的代码初步展示了切片索引的力量。</p><pre class="highlight"><code class="python"> &gt;&gt;&gt; a = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>)) &gt;&gt;&gt; a [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] &gt;&gt;&gt; a[:<span class="number">5</span>] [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] &gt;&gt;&gt; a[<span class="number">5</span>:] [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] &gt;&gt;&gt; a[<span class="number">2</span>:<span class="number">8</span>] [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] &gt;&gt;&gt; a[::<span class="number">2</span>] [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>] &gt;&gt;&gt; a[::-<span class="number">1</span>] [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex快速入门</title>
      <link href="/2023/04/22/Latex%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2023/04/22/Latex%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="latex-文档类documentclass"><a class="markdownIt-Anchor" href="#latex-文档类documentclass"></a> LaTeX 文档类（\documentclass)</h2><p><a href="https://blog.csdn.net/qq_37556330/article/details/106179833">相关链接</a></p><blockquote><p>\part</p><blockquote><p>\chapter</p><blockquote><p>\section<br />\subsection</p><blockquote><p>\subsubsection</p></blockquote></blockquote></blockquote></blockquote><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\part</span>&#123;排版&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">\chapter</span>&#123;第一章 LATEX chapters and sections&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">\section</span>&#123;这是第一个章节&#125;</span><br><span class="line">可以添加章节内容。  </span><br><span class="line"></span><br><span class="line"><span class="keyword">\subsection</span>&#123;这是一个子章节&#125;</span><br><span class="line">子章节内容  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">\section</span>&#123;这是第二个章节&#125;</span><br><span class="line">第二个章节的内容。</span><br><span class="line"><span class="keyword">\subsubsection</span>&#123;这是一个三级章节&#125;</span><br><span class="line">第三个章节的内容。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构前备知识</title>
      <link href="/2023/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%89%8D%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%89%8D%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h1><h2 id="c指针与地址基础认知"><a class="markdownIt-Anchor" href="#c指针与地址基础认知"></a> C指针与地址(基础认知)</h2><blockquote><p>在C语言的学习过程中，常理不清指针（即一个变量的地址）和指针变量（专门用来存放另一变量的地址(指针)的变量）的关系，因此通过程序打印地址运行结果，来分析加强理解。老师在教授过程当中常将两个概念混在一起说，很多人听不明白，某个小学生多要理解几遍这段话。</p></blockquote><h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><h4 id="一-代码示例"><a class="markdownIt-Anchor" href="#一-代码示例"></a> 一、代码示例</h4><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">88</span>,b=<span class="number">60</span> ;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p=&amp;a;<span class="comment">//指向a的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#p&quot;</span>,p);<span class="comment">//以十六进制的形式输出</span></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot; %p &quot;</span>,*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %p\n&quot;</span>,&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot; %d &quot;</span>,*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %d\n&quot;</span>,&amp;p);</span><br><span class="line">    p--;<span class="comment">//指针移动指向b的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#p&quot;</span>,p);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot; %p &quot;</span>,*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %p\n&quot;</span>,&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot; %d &quot;</span>,*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %d\n&quot;</span>,&amp;p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2运行结果"><a class="markdownIt-Anchor" href="#2运行结果"></a> 2.运行结果</h4><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000000000061F</span>E1C</span><br><span class="line"><span class="number">0X000000000061FE1C</span> <span class="number">0000000000000058</span>  <span class="number">000000000061F</span>E10</span><br><span class="line"><span class="number">6422044</span> <span class="number">88</span>  <span class="number">6422032</span></span><br><span class="line"><span class="number">000000000061F</span>E18</span><br><span class="line"><span class="number">0X000000000061FE18</span> <span class="number">000000000000003</span>C  <span class="number">000000000061F</span>E10</span><br><span class="line"><span class="number">6422040</span> <span class="number">60</span>  <span class="number">6422032</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>在指针*p=&amp;a初始化后，p等同于&amp;a即a的地址，在运行过程中可以代换。%#p是输出位0X开开头的16进制数。因此printf(“%p\n”,&amp;a);    printf(“%#p”,p);本质是一样的。*p则是通过指针变量p存储的a的地址，间接获取a的值。*p=a,对数值%p等同于对数值以十六进制位输出。%d对p,*p,&amp;p则是以十进制形式分别输出地址，值，地址。</p><p>p–，由于p是整型指针，p–减去int的4个字节刚好移动到b。</p><blockquote><p>【注】1.这里发现后定义的变量b的地址要小于a的地址，这是因为c语言中，先定义的数据先入栈，在栈的底部（不分配内存），声明结束后，b在栈顶，所以b先出栈，先为b分配内存。因此b的地址小于a的地址。<br />   2.数据的地址位数和数据能存储的位数无关。学习阶段曾存在疑问（输出的地址是16位，int是4字节，即16进制的4位代表一个字节（实际应该是一个字节等于2位16进制），一个字节等于八位二进制，但八位二进制不等于四位16进制？）通过交流请教得知有关计算机组成原理，地址位数只取决于系统，所有类型的指针所占长度相同。</p></blockquote><h2 id="指针知识框架详解"><a class="markdownIt-Anchor" href="#指针知识框架详解"></a> 指针知识框架（详解）</h2><p><a href="https://www.dreamchasing.top/2023/01/29/%E6%8C%87%E9%92%88%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%EF%BC%88%E8%AF%A6%E8%A7%A3%EF%BC%89/">具体内容请单击此链接，某个小学生可以待会再看，上面看完直接看结构体</a></p><h1 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h1><h2 id="如何声明一个结构体类型"><a class="markdownIt-Anchor" href="#如何声明一个结构体类型"></a> 如何声明一个结构体类型？</h2><p>例子：形如下列代码的形式为结构体模板（struct template），仅是构造一个数据类型，如同构造int类型代表了什么样的数据类型，但未定义结构体变量，编译器不会为此分配内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> ID;</span><br><span class="line">    <span class="type">char</span> Name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>  score[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何定义一个结构体变量"><a class="markdownIt-Anchor" href="#如何定义一个结构体变量"></a> 如何定义一个结构体变量？</h2><h3 id="1先定义结构体类型再定义结构体变量名"><a class="markdownIt-Anchor" href="#1先定义结构体类型再定义结构体变量名"></a> 1.先定义结构体类型再定义结构体变量名</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> ID;</span><br><span class="line">    <span class="type">char</span> Name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>  score[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu1</span>;</span> <span class="comment">//合法的√</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu1</span>;</span> <span class="comment">//非法的×</span></span><br><span class="line">student stu1; <span class="comment">//非法的×</span></span><br></pre></td></tr></table></figure><h3 id="2在定义结构体类型的同时定义变量"><a class="markdownIt-Anchor" href="#2在定义结构体类型的同时定义变量"></a> 2.在定义结构体类型的同时定义变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> ID;</span><br><span class="line">    <span class="type">char</span> Name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>  score[<span class="number">4</span>];</span><br><span class="line">&#125;stu1;</span><br></pre></td></tr></table></figure><h3 id="3直接定义结构体变量不指定结构体标签"><a class="markdownIt-Anchor" href="#3直接定义结构体变量不指定结构体标签"></a> 3.直接定义结构体变量（不指定结构体标签）</h3><p>不写struct （结构体标签）的标签，相当于没有给该结构体类型起名字，不推荐使用，会导致不一致和重复的问题，不能用于声明函数的形参。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> ID;</span><br><span class="line">    <span class="type">char</span> Name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>  score[<span class="number">4</span>];</span><br><span class="line">&#125;stu1;</span><br></pre></td></tr></table></figure><h2 id="为结构体类型定义名字"><a class="markdownIt-Anchor" href="#为结构体类型定义名字"></a> 为结构体类型定义名字</h2><h3 id="1用结构体标签来标识结构体类型"><a class="markdownIt-Anchor" href="#1用结构体标签来标识结构体类型"></a> 1.用结构体标签来标识结构体类型</h3><p>struct （结构体标签）</p><h3 id="2用typedef给数据类型定义一个别名"><a class="markdownIt-Anchor" href="#2用typedef给数据类型定义一个别名"></a> 2.用typedef给数据类型定义一个别名</h3><p>typedef即使某个词何某个词为同义词<br />如下面示例中<code>STUDENT</code> 与 <code>struct student</code>是同义词</p><h4 id="类型1"><a class="markdownIt-Anchor" href="#类型1"></a> 类型1</h4><p>使用typedef为已存在的类型定义一个别名，并未声明新的类型。这种定义方法结构体标签不可以省略。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> ID;</span><br><span class="line">    <span class="type">char</span> Name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>  score[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">STUDENT</span>;</span></span><br></pre></td></tr></table></figure><p>使用typedef成为同义词后，可以直接用<code>STUDENT stu1</code>定义结构体变量</p><h4 id="类型2"><a class="markdownIt-Anchor" href="#类型2"></a> 类型2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> ID;</span><br><span class="line">    <span class="type">char</span> Name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>  score[<span class="number">4</span>];</span><br><span class="line">&#125;STUDENT; </span><br></pre></td></tr></table></figure><h4 id="类型3"><a class="markdownIt-Anchor" href="#类型3"></a> 类型3</h4><p>结构体标签可以省略</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> ID;</span><br><span class="line">    <span class="type">char</span> Name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>  score[<span class="number">4</span>];</span><br><span class="line">&#125;STUDENT; </span><br></pre></td></tr></table></figure><hr /><p>分割线</p><hr /><h2 id="typedef与链表的联系"><a class="markdownIt-Anchor" href="#typedef与链表的联系"></a> typedef与链表的联系</h2><p>typedef的作用是为已有的数据类型定义一个新名字，其主要目的是为了我们在使用时能用这个更加清晰简单的新名字，还有一个目的就是为了简化变量的声明。</p><h3 id="样式1"><a class="markdownIt-Anchor" href="#样式1"></a> 样式1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> data;  <span class="comment">// 节点的数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span>  <span class="comment">// 节点的指针域 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">n</span>;</span>  <span class="comment">// 定义一个单个节点</span></span><br></pre></td></tr></table></figure><h3 id="样式2"><a class="markdownIt-Anchor" href="#样式2"></a> 样式2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> data;  <span class="comment">// 节点的数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span>  <span class="comment">// 节点的指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">NODE</span>;</span>  <span class="comment">// 把struct node型的结构体用别名NODE表示</span></span><br><span class="line">NODE n;  <span class="comment">// 定义一个单个节点</span></span><br></pre></td></tr></table></figure><h3 id="样式3"><a class="markdownIt-Anchor" href="#样式3"></a> 样式3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> data;  <span class="comment">// 节点的数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span>  <span class="comment">// 节点的指针域</span></span><br><span class="line">&#125;NODE;</span><br><span class="line">NODE n;  <span class="comment">// 定义一个单个节点</span></span><br></pre></td></tr></table></figure><hr /><p>分割线</p><hr /><h2 id="单链表的实际运用"><a class="markdownIt-Anchor" href="#单链表的实际运用"></a> 单链表的实际运用</h2><h3 id="单链表结构定义"><a class="markdownIt-Anchor" href="#单链表结构定义"></a> 单链表结构定义</h3><p>参考文章编写<a href="https://blog.csdn.net/weixin_44162361/article/details/115665501">结构体中的LNode与*LinkList</a>编写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> DateType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="comment">//链表节点的结构定义</span></span><br><span class="line">    DateType date;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StuNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">&#125;LinkNode,*LinkList;<span class="comment">//单链表的结构定义</span></span><br></pre></td></tr></table></figure><p>初学时往往不理解LinkNode,<em>LinkList的意义。<br />对于这个结构体来说，LinkNode和</em>LinkList其实都是结构体struct node的别名，只不过类型不同。</p><ul><li>LinkNode是一个普通的结构体名，相当于将结构体类型<code>struct node</code> 重命名为<code>LinkNode</code>;</li><li>*LinkList是一个指针类型，相当于将<code>struct node * </code>重命名为<code>LinkList</code>。</li></ul><p>本质上<code>LinkNode</code>和<code>LinkList</code>都只是为了简化代码省略<code>struct node</code>部分，它们仍然是用来表示数据类型的别名。<br />实际使用中运用这些别名来定义变量，如<code>LinkList L</code>; 等价于<code>struct node *L</code>;</p><h3 id="linklist-l-与linklist-llnode-l-lnode-l"><a class="markdownIt-Anchor" href="#linklist-l-与linklist-llnode-l-lnode-l"></a> LinkList L 与LinkList &amp;L（LNode* L ， LNode* &amp;L）</h3><p>参考<a href="https://www.zhihu.com/question/66781500/answer/2230081680">陆加壹</a>编写</p><h4 id="linklist-l"><a class="markdownIt-Anchor" href="#linklist-l"></a> LinkList L</h4><p>1.当函数参数为LinkList L时，意味着只改变或操作List的内容，而不需要改变L这个指针<br />如查找操作<code>Status GetElem(LinkList L,int i,ElemType)</code></p><h4 id="linklist-l-2"><a class="markdownIt-Anchor" href="#linklist-l-2"></a> LinkList &amp;L</h4><p>2.当参数为LinkList &amp;L时，意味着需要改变或操作L这个指针本身<br />如初始化操作(初始化单链表，需要给L分配内存空间，即需要改变L)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">    L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&amp;其实是C++的知识，其在此处的作用是使函数运行后可以改变实参。<br />&amp;详解请见<a href="https://www.runoob.com/cplusplus/cpp-references.html">c++引用|菜鸟教程</a></p><h4 id="linklist-l-3"><a class="markdownIt-Anchor" href="#linklist-l-3"></a> LinkList *L</h4><p>当参数为LinkList <em>L时，意味着需要改变或操作L这个指针指向的LinkList类型的指针(此处的L可以理解为指向前两点中的L的指针)<br />此时给头结点分配储存空间时要这样写<code>(*L)=(LinkList)malloc(sizeof(struct LNode));</code><br />L前面要加</em>,表示L所指向的那个指针<br />该情况属于二级指针即指向指针的指针<br />参考<a href="https://zhuanlan.zhihu.com/p/410715721">星辰</a>编写</p><h1 id="mark某个小学生能不能看到这知识点看完找个实际例子对照着理解下mark"><a class="markdownIt-Anchor" href="#mark某个小学生能不能看到这知识点看完找个实际例子对照着理解下mark"></a> <mark>某个小学生能不能看到这？知识点看完，找个实际例子对照着理解下</mark></h1>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 结构体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷深入浅出基础篇整理</title>
      <link href="/2023/03/12/%E6%B4%9B%E8%B0%B7%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/2023/03/12/%E6%B4%9B%E8%B0%B7%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>原题链接 <a href="https://www.luogu.com.cn/problem/P1957">P1957 口算练习题</a></p><h2 id="6字符串与文件操作"><a class="markdownIt-Anchor" href="#6字符串与文件操作"></a> 6.字符串与文件操作</h2><h3 id="字符数组"><a class="markdownIt-Anchor" href="#字符数组"></a> 字符数组</h3><h4 id="例6-4口算练习题"><a class="markdownIt-Anchor" href="#例6-4口算练习题"></a> 例6-4：口算练习题</h4><blockquote><p>题目描述<br />王老师正在教简单算术运算。细心的王老师收集了i道学生经常做错的口算题，并且想整理编写成一份练习。 编排这些题目是一件繁琐的事情，为此他想用计算机程序来提高工作效率。王老师希望尽量减少输入的工作量，比如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">5+8</mtext></mrow><annotation encoding="application/x-tex">\texttt{5+8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61111em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">5+8</span></span></span></span></span> 的算式最好只要输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">5</mtext></mrow><annotation encoding="application/x-tex">\texttt 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61111em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">5</span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">8</mtext></mrow><annotation encoding="application/x-tex">\texttt 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61111em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">8</span></span></span></span></span>，输出的结果要尽量详细以方便后期排版的使用，比如对于上述输入进行处理后输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">5+8=13</mtext></mrow><annotation encoding="application/x-tex">\texttt{5+8=13}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61111em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">5+8=13</span></span></span></span></span> 以及该算式的总长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>。王老师把这个光荣的任务交给你，请你帮他编程实现以上功能。<br />输入格式<br />第一行为数值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span><br />接着的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 行为需要输入的算式，每行可能有三个数据或两个数据。<br />若该行为三个数据则第一个数据表示运算类型，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">a</mtext></mrow><annotation encoding="application/x-tex">\texttt a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">a</span></span></span></span></span> 表示加法运算，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">b</mtext></mrow><annotation encoding="application/x-tex">\texttt b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61111em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">b</span></span></span></span></span> 表示减法运算，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">c</mtext></mrow><annotation encoding="application/x-tex">\texttt c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">c</span></span></span></span></span> 表示乘法运算，接着的两个数据表示参加运算的运算数。<br />若该行为两个数据，则表示本题的运算类型与上一题的运算类型相同，而这两个数据为运算数。<br />输出格式<br />输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">2\times i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 行。对于每个输入的算式，输出完整的运算式及结果，第二行输出该运算式的总长度<br />样例 #1<br />样例输入 #1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">a 64 46</span><br><span class="line">275 125</span><br><span class="line">c 11 99</span><br><span class="line">b 46 64</span><br></pre></td></tr></table></figure><p>样例输出 #1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">64+46=110</span><br><span class="line">9</span><br><span class="line">275+125=400</span><br><span class="line">11</span><br><span class="line">11*99=1089</span><br><span class="line">10</span><br><span class="line">46-64=-18</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p>提示<br />数据规模与约定<br />对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>50</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">50\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，输入的算式都有三个数据，第一个算式一定有三个数据。<br />对于所有数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>i</mi><mo>≤</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">0&lt;i\leq 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span>，运算数为非负整数且小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10000</mn></mrow><annotation encoding="application/x-tex">10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。</p><h5 id="官方题解有误"><a class="markdownIt-Anchor" href="#官方题解有误"></a> 官方题解：(有误)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n, a, b, c;</span><br><span class="line">  <span class="type">char</span> last, s[<span class="number">20</span>], ans[<span class="number">20</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">while</span> (n--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fgets</span>(s, <span class="built_in">sizeof</span>(s), stdin); <span class="comment">// 读入一行</span></span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;a&#x27;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;b&#x27;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">      last = s[<span class="number">0</span>];</span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&#x27; &#x27;</span>;                 <span class="comment">// 获取计算符号，并替换为空格</span></span><br><span class="line">    <span class="built_in">sscanf</span>(s, <span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b); <span class="comment">// 从这个字符串里面读出两个数a和b</span></span><br><span class="line">    <span class="keyword">switch</span> (last)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">      c = a + b;</span><br><span class="line">      <span class="built_in">sprintf</span>(ans,<span class="string">&quot;%d+%d=%d&quot;</span>, a, b, c);</span><br><span class="line">      <span class="keyword">break</span>; <span class="comment">//+</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">      c = a - b;</span><br><span class="line">      <span class="built_in">sprintf</span>(ans,<span class="string">&quot;%d-%d=%d&quot;</span>, a, b, c);</span><br><span class="line">      <span class="keyword">break</span>; <span class="comment">//-</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">      c = a * b;</span><br><span class="line">      <span class="built_in">sprintf</span>(ans,<span class="string">&quot;%d*%d=%d&quot;</span>, a, b, c);</span><br><span class="line">      <span class="keyword">break</span>; <span class="comment">//+</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n%d\n&quot;</span>, ans, <span class="built_in">strlen</span>(ans)); <span class="comment">// 输出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通过代码"><a class="markdownIt-Anchor" href="#通过代码"></a> 通过代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;data.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">char</span> a[<span class="number">10</span>], ans[<span class="number">100</span>];</span><br><span class="line">  <span class="type">char</span> temp;</span><br><span class="line">  <span class="type">int</span> n, x, y;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">while</span> (n--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; a[<span class="number">0</span>] &lt;= <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      temp = a[<span class="number">0</span>];</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      x = <span class="built_in">atoi</span>(a);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="built_in">sizeof</span>(ans));<span class="comment">//清空原有的字符串，防止长度判断错误</span></span><br><span class="line">    <span class="keyword">switch</span> (temp)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">      <span class="built_in">sprintf</span>(ans, <span class="string">&quot;%d+%d=%d&quot;</span>, x, y, x + y);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">      <span class="built_in">sprintf</span>(ans, <span class="string">&quot;%d-%d=%d&quot;</span>, x, y, x - y);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">      <span class="built_in">sprintf</span>(ans, <span class="string">&quot;%d*%d=%d&quot;</span>, x, y, x * y);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n%d\n&quot;</span>, ans, <span class="built_in">strlen</span>(ans));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新知识"><a class="markdownIt-Anchor" href="#新知识"></a> 新知识</h4><ul><li>scanf遇到空格换行停止读入</li><li>sscanf(s,“%d”,&amp;a);就可以从字符串s中读入一个整数a。</li><li>sprintf将数据输入到字符串，sprintf(ans, “%d*%d=%d”, x, y, x * y);就是以%d*%d=%d的格式输入到字符串ans中ans存储x*y=xy。</li><li>atoi ((表示 ascii to integer)是把字符串转换成整型数的一个函数)头文件为#include&lt;stdlib.h&gt;</li></ul><h3 id="string类型字符串stl"><a class="markdownIt-Anchor" href="#string类型字符串stl"></a> string类型字符串(STL)</h3><h4 id="例6文字处理软件"><a class="markdownIt-Anchor" href="#例6文字处理软件"></a> [例6]文字处理软件</h4><blockquote><p>题目描述<br />你需要开发一款文字处理软件。最开始时输入一个字符串作为初始文档。可以认为文档开头是第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 个字符。需要支持以下操作：</p></blockquote><ul><li><code>1 str</code>：后接插入，在文档后面插入字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">str</mtext></mrow><annotation encoding="application/x-tex">\texttt{str}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55358em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">str</span></span></span></span></span>，并输出文档的字符串。</li><li><code>2 a b</code>：截取文档部分，只保留文档中从第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 个字符起 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> 个字符，并输出文档的字符串。</li><li><code>3 a str</code>：插入片段，在文档中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 个字符前面插入字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">str</mtext></mrow><annotation encoding="application/x-tex">\texttt{str}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55358em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">str</span></span></span></span></span>，并输出文档的字符串。</li><li><code>4 str</code>：查找子串，查找字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">str</mtext></mrow><annotation encoding="application/x-tex">\texttt{str}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55358em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">str</span></span></span></span></span> 在文档中最先的位置并输出；如果找不到输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。<br />为了简化问题，规定初始的文档和每次操作中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">str</mtext></mrow><annotation encoding="application/x-tex">\texttt{str}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55358em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">str</span></span></span></span></span> 都不含有空格或换行。最多会有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 次操作。<br />输入格式<br />第一行输入一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>，表示操作次数。<br />第二行输入一个字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">str</mtext></mrow><annotation encoding="application/x-tex">\texttt{str}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55358em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">str</span></span></span></span></span>，表示最开始的字符串。<br />第三行开始，往下 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 行，每行表示一个操作，操作如题目描述所。<br />输出格式<br />一共输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 行。<br />对于每个操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">1,2,3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span></span></span></span>，根据操作的要求输出一个字符串。<br />对于操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>，根据操作的要求输出一个整数。<br />样例 #1<br />样例输入 #1</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">ILove</span><br><span class="line">1 Luogu</span><br><span class="line">2 5 5</span><br><span class="line">3 3 guGugu</span><br><span class="line">4 gu</span><br></pre></td></tr></table></figure><p>样例输出 #1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ILoveLuogu</span><br><span class="line">Luogu</span><br><span class="line">LuoguGugugu</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>提示<br />数据保证，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>q</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">1 \leq q\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，开始的字符串长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\leq 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。</p><h5 id="ac代码官方"><a class="markdownIt-Anchor" href="#ac代码官方"></a> AC代码（官方）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  string s, a;</span><br><span class="line">  <span class="type">int</span> opt, q, begin, end;</span><br><span class="line">  cin &gt;&gt; q;</span><br><span class="line">  cin &gt;&gt; s;</span><br><span class="line">  <span class="keyword">while</span> (q--)</span><br><span class="line">  &#123;</span><br><span class="line">    cin &gt;&gt; opt;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      cin &gt;&gt; a;</span><br><span class="line">      s.<span class="built_in">append</span>(a);</span><br><span class="line">      cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      cin &gt;&gt; begin &gt;&gt; end;</span><br><span class="line">      s = s.<span class="built_in">substr</span>(begin, end);</span><br><span class="line">      cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      cin &gt;&gt; begin &gt;&gt; a;</span><br><span class="line">      s = s.<span class="built_in">insert</span>(begin, a);</span><br><span class="line">      cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      cin &gt;&gt; a;</span><br><span class="line">      cout &lt;&lt; (<span class="type">int</span>)s.<span class="built_in">find</span>(a) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="string类型"><a class="markdownIt-Anchor" href="#string类型"></a> string类型</h5><p>1.引入头文件 <code>#include &lt;string&gt;</code><br />2.初始化<code>string s</code><br />注：string与字符数组相类似，从存储从0,1,2,3…开始。<br />区别string可以直接复制常量也可以相互赋值，字符数组不能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string a,b;</span><br><span class="line">a=<span class="string">&quot;LUOGU&quot;</span></span><br><span class="line">b=a;</span><br><span class="line"><span class="comment">//但是如果是字符数组</span></span><br><span class="line"><span class="type">char</span> a=<span class="string">&quot;abc&quot;</span>是错误的。因为字符数组名a，本质上是一个地址，不可以用来直接复制和相互赋值。</span><br></pre></td></tr></table></figure><p>3.常用操作</p><ul><li>s+=str或s.append(str):在字符串s后拼接字符串str。</li><li>s &lt; str：比较字符串s的字典序是否在字符串str之前</li><li>s.size()或s.length()：得到字符串s的长度</li><li>s.substr(pos,len)以字符串数组来理解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string a=<span class="string">&quot;acwing&quot;</span></span><br><span class="line">cout &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">3</span>) &lt;&lt; endl; <span class="comment">//acw,当第一个数是0 则后一位数:输出从头开始的长度为3的子串</span></span><br><span class="line">cout &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl; <span class="comment">//cwi,当第一个数是1 则输出下标为1 到下标为3的子串  </span></span><br><span class="line">cout &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">9</span>) &lt;&lt; endl;<span class="comment">//acwing如果超出长度范围 则输出原子串</span></span><br><span class="line">cout &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">1</span>) &lt;&lt; endl; <span class="comment">//cwing,从下标为1开始输出</span></span><br><span class="line">cout &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">0</span>) &lt;&lt; endl; <span class="comment">//acwing原子串</span></span><br></pre></td></tr></table></figure><ul><li>s.insert</li></ul><blockquote><p>str1（被插入字符串）.insert(pos(插入位置),str2（被插入字符串），n ，m)<br />ps：n，m分别是插入字符串要截取的（真正要插入的部分）即在str2.n位置数m个，不写这个的话就是将str2整个全部插入。<br />如题中代码s.insert(1,a)省略n,m将字符串a全部插入<br />【注】在输入的位置之前插入，如0，在开头插入，1插在第二个位置，<mark>下方代码有存疑还未解决</mark></p></blockquote> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">string a;<span class="comment">//区别：string a=&quot; &quot;;char a=&#x27;&#x27;;</span></span><br><span class="line"><span class="comment">// 尾插一个字符</span></span><br><span class="line">  a.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  cout&lt;&lt;a&lt;&lt;endl;<span class="comment">//输出a；</span></span><br><span class="line"><span class="comment">// insert(pos,char):在制定的位置pos前插入字符char</span></span><br><span class="line">  a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(),<span class="string">&#x27;1&#x27;</span>); <span class="comment">//输出 1a</span></span><br><span class="line"><span class="comment">/*【注】此处存疑a.insert(a.begin(),&#x27;1&#x27;);可以后面只能是一个字节的char类型，字符串和string类型；前面也不能把a.begin()改成数字0等表示插入位置。*/</span></span><br><span class="line"><span class="comment">//插入字符串</span></span><br><span class="line">  string str2=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  string s2=<span class="string">&quot;weakhaha&quot;</span>;</span><br><span class="line">  str2.<span class="built_in">insert</span>(<span class="number">0</span>,s2,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">   cout&lt;&lt;str2&lt;&lt;endl;<span class="comment">//eakhello,将字符串s2从下标为1的e开始数3个字符，分别是eak，插入原串的下标为0的字符h前   </span></span><br><span class="line"><span class="comment">/*-------------------------------------*/</span>    </span><br><span class="line">string str2=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  string s2=<span class="string">&quot;weakhaha&quot;</span>;</span><br><span class="line">  str2.<span class="built_in">insert</span>(<span class="number">1</span>,s2,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">   cout&lt;&lt;str2&lt;&lt;endl;<span class="comment">//heakello将字符串s2从下标为1的e开始数3个字符，分别是eak，插入原串的下标为1的字符e前   </span></span><br></pre></td></tr></table></figure><ul><li>s.find(str,[pos]):在字符串第pos个字符开始寻找str，并返回位置，如果找不到返回-1.pos可以省略，默认值是0。<br />【注】使用find函数查找子串但是找不到时，它会返回一个常数string::npos，但是由于它不一定是一个int类型的常量，所以需要将其强制转换为int才能直接输出-1<mark>（读者可以试一下直接使用cout输出，这个数字会是什么）</mark></li></ul><p>此处内容参考<br /><a href="https://blog.csdn.net/weixin_49486457/article/details/123439229?spm=1001.2014.3001.5502">【C++】算法竞赛常用STL万字总结</a><br /><a href="https://blog.csdn.net/weixin_63003502/article/details/122562640?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=c++insert&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-122562640.142%5Ev73%5Einsert_down2,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;spm=1018.2226.3001.4187">指定位置插入字符串（c++insert函数、find函数使用）</a><br /><a href="https://blog.csdn.net/qq_51271013/article/details/116170964?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167860392816800186584851%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167860392816800186584851&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-116170964-null-null.142%5Ev73%5Einsert_down2,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=c%2B%2Bfind&amp;spm=1018.2226.3001.4187">C++中的find函数用法</a></p><h2 id="第9章排序"><a class="markdownIt-Anchor" href="#第9章排序"></a> 第9章排序</h2><h3 id="经典排序方法"><a class="markdownIt-Anchor" href="#经典排序方法"></a> 经典排序方法</h3><h4 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h4><h4 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h4><p>P1923 【深基9.例4】求第 k 小的数 ,<mark>快排优化还没想明白</mark></p><h4 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h4><h4 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h4><h4 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h4><h4 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h4><h4 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h4><h4 id="基数排序"><a class="markdownIt-Anchor" href="#基数排序"></a> 基数排序</h4><h4 id="桶排序"><a class="markdownIt-Anchor" href="#桶排序"></a> 桶排序</h4><h3 id="stl"><a class="markdownIt-Anchor" href="#stl"></a> STL</h3><h4 id="sort函数"><a class="markdownIt-Anchor" href="#sort函数"></a> sort函数</h4><h5 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h5><blockquote><p>需要引入头文件#include&lt; algorithm &gt;</p></blockquote><p>sort()函数是类似于快速排序的方法，时间复杂度为n*log2(n)，执行效率较高。并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。所以说sort()是一个比较灵活的函数，它也会根据我们数据的需要进行排序，所以我们就不用担心以上的问题了。对于大部分的排序需求，sort()都是可以满足的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(begin, end, cmp);</span><br></pre></td></tr></table></figure><p>其中begin为指向待sort()的数组的第一个元素的指针，end为指向待sort()的数组的最后一个元素的下一个位置的指针，cmp参数为排序准则，cmp参数可以不写，如果不写的话，默认从小到大进行排序。<br />如果我们想从大到小排序可以将cmp参数写为  <code>greater&lt;int&gt;()</code>  就是对int数组进行排序，例如  <code>sort(a,a+n,greater&lt;int&gt;());</code></p><p>当然&lt;&gt;中我们也可以写<mark>double、long、float</mark>等等。</p><h5 id="自定义排序标准"><a class="markdownIt-Anchor" href="#自定义排序标准"></a> 自定义排序标准</h5><p>也可以以自定义排序准则的形式来写cmp函数如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><blockquote><p>可能你有点懵，不知道这是什么原理，为什么要这么写。<br />我认为cmp函数的一个特性就是，a是前面的元素， b是后面的元素，如果return 0, 那么sort就会将他们互换位置, return 1就会保持原来位置不变。<br />所以这函数可以解读为：<br />如果前面的元素比后面的元素大，就保持不变<br />如果前面的元素比后面的元素小，就交换他们的位置<br />简单来说就是把大的元素放在前面<br />我直接把这个cmp背下来不好吗？<br />cmp在结构体排序里也要用到，你背下来写那种二级排序的题也不会<br />在return里面  a放前面，b放前面，大于号，小于号，有好几种情况<br />理解起来有点绕怎么办？<br />我教你一种好理解的方法。<br />你永远把a放在前面，b放在后面。想把大的放在前面，就写大于号，想把小的放在前面，就写小于号（大口朝前大在前，小口朝前小在前）<br />这样就省去了分析的时间，还不容易出错。—— <a href="https://blog.csdn.net/suanrongye/article/details/121271088">c++应用sort函数时的cmp函数怎么写</a></p></blockquote><p>如果我们需要按照其他的排序准则，那么就需要我们自己定义一个bool类型的函数来传入。比如说我们按照每个数的个位进行从大到小排序，我们就可以根据自己的需求来写一个函数作为排序的准则传入到sort()中。<br />我们可以将这个函数定义为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x % <span class="number">10</span> &gt; y % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们将这个cmp函数作为参数传入sort()中即可实现了上述排序需求。<br />完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x % <span class="number">10</span> &gt; y % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>] = &#123;<span class="number">65</span>,<span class="number">59</span>,<span class="number">96</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">80</span>,<span class="number">72</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">99</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(num,num+<span class="number">10</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">cout&lt;&lt;num[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;<span class="comment">//输出结果：59 99 96 65 44 13 33 72 21 80</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对结构体进行排序"><a class="markdownIt-Anchor" href="#对结构体进行排序"></a> 对结构体进行排序</h5><p><a href="https://blog.csdn.net/qq_41575507/article/details/105936466?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167930091016800217273553%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167930091016800217273553&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105936466-null-null.142%5Ev74%5Einsert_down2,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=sort&amp;spm=1018.2226.3001.4187">C++ sort()排序详解</a><br />例题9-6</p><blockquote><p>[NOIP2007 普及组] 奖学金<br />题目描述<br />某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 名学生发奖学金。期末，每个学生都有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 门课的成绩:语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学 排在前面，这样，每个学生的排序是唯一确定的。<br />任务：先根据输入的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名名学生的学号和总分。注意，在前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据(每行输出两个数:学号、总分) 是:<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>279</mn></mrow><annotation encoding="application/x-tex">279</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mord">9</span></span></span></span><br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>279</mn></mrow><annotation encoding="application/x-tex">279</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mord">9</span></span></span></span><br />这两行数据的含义是:总分最高的两个同学的学号依次是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span> 号、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 号。这两名同学的总分都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>279</mn></mrow><annotation encoding="application/x-tex">279</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mord">9</span></span></span></span> (总分等于输入的语文、数学、英语三科成绩之和) ，但学号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span> 的学生语文成绩更高一些。如果你的前两名的输出数据是:<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>279</mn></mrow><annotation encoding="application/x-tex">279</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mord">9</span></span></span></span><br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>279</mn></mrow><annotation encoding="application/x-tex">279</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mord">9</span></span></span></span><br />则按输出错误处理，不能得分。<br />输入格式<br />共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>行。<br />第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 行为一个正整数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>300</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n ( \le 300)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，表示该校参加评选的学生人数。<br />第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 行，每行有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 个用空格隔开的数字，每个数字都在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 之间。第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 行的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 个数字依次表示学号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1\sim n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>（恰好是输入数据的行号减 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>）。<br />所给的数据都是正确的，不必检验。<br />输出格式<br />共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 行，每行是两个用空格隔开的正整数，依次表示前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 名学生的学号和总分。<br />样例 #1<br />样例输入 #1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">80 89 89</span><br><span class="line">88 98 78</span><br><span class="line">90 67 80</span><br><span class="line">87 66 91</span><br><span class="line">78 89 91</span><br><span class="line">88 99 77</span><br><span class="line">67 89 64</span><br><span class="line">78 89 98</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">样例输出 #2  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>8 265<br />2 264<br />6 264<br />1 258<br />5 258</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct student</span><br><span class="line">&#123;</span><br><span class="line">  int id;</span><br><span class="line">  int score[3];</span><br><span class="line">  int total;</span><br><span class="line">&#125; STUDENT;</span><br><span class="line">STUDENT a[310];</span><br><span class="line">bool cmp(student x, student y)</span><br><span class="line">&#123;</span><br><span class="line">  if (x.total != y.total)</span><br><span class="line">    return x.total &gt; y.total;</span><br><span class="line">  if (x.score[0] != y.score[0])</span><br><span class="line">    return x.score[0] &gt; y.score[0];</span><br><span class="line">  return x.id &lt; y.id;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  for (int i = 1; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    a[i].id = i;</span><br><span class="line">    cin &gt;&gt; a[i].score[0] &gt;&gt; a[i].score[1] &gt;&gt; a[i].score[2];</span><br><span class="line">    a[i].total = a[i].score[0] + a[i].score[1] + a[i].score[2];</span><br><span class="line">  &#125;</span><br><span class="line">  sort(a + 1, a + n + 1, cmp);</span><br><span class="line">  for (int i = 1; i &lt;= 5; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; a[i].id &lt;&lt; &quot; &quot; &lt;&lt; a[i].total &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">##### 利用字符串进行排序</span><br><span class="line">&gt;P1781宇宙总统</span><br><span class="line">题目描述</span><br><span class="line">地球历公元 6036 年，全宇宙准备竞选一个最贤能的人当总统，共有 $n$ 个非凡拔尖的人竞选总统，现在票数已经统计完毕，请你算出谁能够当上总统。</span><br><span class="line">输入格式</span><br><span class="line">第一行为一个整数 $n$，代表竞选总统的人数。</span><br><span class="line">接下来有 $n$ 行，分别为第一个候选人到第 $n$ 个候选人的票数。</span><br><span class="line">输出格式</span><br><span class="line">共两行，第一行是一个整数 $m$，为当上总统的人的号数。</span><br><span class="line">第二行是当上总统的人的选票。</span><br><span class="line">样例 #1</span><br><span class="line">样例输入 #1</span><br></pre></td></tr></table></figure><p>5<br />98765<br />12365<br />87954<br />1022356<br />985678</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">样例输出 #1  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4<br />1022356</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">提示</span><br><span class="line">票数可能会很大，可能会到 $100$ 位数字。</span><br><span class="line">$1 \leq n \leq 20$  </span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node</span><br><span class="line">&#123; </span><br><span class="line">  int id;//编号</span><br><span class="line">  string num;//票数</span><br><span class="line">&#125; a[25];</span><br><span class="line">bool cmp(node x, node y)</span><br><span class="line">&#123;</span><br><span class="line">  if(x.num.length()!=y.num.length())return x.num.length()&gt;y.num.length();//a比b位数多时a在前面</span><br><span class="line">  return x.num&gt;y.num;//位数相同，但a字典序排列比b大</span><br><span class="line">  //字符串的比较是比较字典序（第一位小的在前面，如果相同比较第二位，以此类推）例如10000小于1200小于200；</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  for (int i = 1; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    a[i].id = i;</span><br><span class="line">    cin &gt;&gt; a[i].num;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(a + 1, a + n + 1, cmp);</span><br><span class="line">    cout &lt;&lt; a[1].id &lt;&lt; endl &lt;&lt; a[1].num ;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="unique函数"><a class="markdownIt-Anchor" href="#unique函数"></a> unique函数</h4><p><a href="https://blog.csdn.net/weixin_44162158/article/details/115575549">unique() 去重函数</a></p><blockquote><p>需要引入头文件#include&lt; algorithm &gt;</p></blockquote><p>unique()函数是一个去重函数，STL中unique的函数 unique的功能是去除相邻的重复元素(只保留一个)<br />它并不真正把重复的元素删除,而是该函数把重复的元素移到后面去了，然后依然保存到了原数组中，然后返回去重后容器中不重复序列的最后一个元素的下一个元素。<br />因为unique去除的是相邻的重复元素，所以一般用之前都会要排一下序。</p><h5 id="例9-5"><a class="markdownIt-Anchor" href="#例9-5"></a> 例9-5</h5><blockquote><p>[NOIP2006 普及组] 明明的随机数<br />题目描述<br />明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1000</mn></mrow><annotation encoding="application/x-tex">1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 之间的随机整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>N</mi><mo>≤</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(N\leq100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。<br />输入格式<br />输入有两行，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 行为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个正整数，表示所生成的随机数的个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>。<br />第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 行有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个用空格隔开的正整数，为所产生的随机数。<br />输出格式<br />输出也是两行，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 行为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，表示不相同的随机数的个数。<br />第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 行为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 个用空格隔开的正整数，为从小到大排好序的不相同的随机数。<br />样例 #1<br />样例输入 #1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">20 40 32 67 40 20 89 300 400 15</span><br></pre></td></tr></table></figure><p>样例输出 #1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">15 20 32 40 67 89 300 400</span><br></pre></td></tr></table></figure><p>AC(运用)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n,cnt;</span><br><span class="line">  cin&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    cin&gt;&gt;a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(a,a+n);</span><br><span class="line">  cnt=<span class="built_in">unique</span>(a,a+n)-a;<span class="comment">//去重后最后一个元素对应的指针减去首地址的差就是去重后的元素个数</span></span><br><span class="line">  cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">    <span class="comment">/*样例输入条件下，如果输出到n，结果为15 20 32 40 67 89 300 400 300 400 可以发现后面为重复的数字仍在数组当中*/</span></span><br><span class="line">    cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">## 第<span class="number">15</span>章线性表</span><br><span class="line">### 数组</span><br><span class="line">#### 例<span class="number">15.1</span></span><br><span class="line">&gt;深基<span class="number">15.</span>例<span class="number">1</span>】询问学号</span><br><span class="line">题目描述</span><br><span class="line">有 $<span class="built_in">n</span>(n \le <span class="number">2</span> \times <span class="number">10</span>^<span class="number">6</span>)$ 名同学陆陆续续进入教室。我们知道每名同学的学号（在 $<span class="number">1</span>$ 到 $<span class="number">10</span>^<span class="number">9</span>$ 之间），按进教室的顺序给出。上课了，老师想知道第 $i$ 个进入教室的同学的学号是什么（最先进入教室的同学 $i=<span class="number">1</span>$），询问次数不超过 $<span class="number">10</span>^<span class="number">5</span>$ 次。</span><br><span class="line">输入格式</span><br><span class="line">第一行 $<span class="number">2</span>$ 个整数 $n$ 和 $m$，表示学生个数和询问次数。</span><br><span class="line">第二行 $n$ 个整数，表示按顺序进入教室的学号。</span><br><span class="line">第三行 $m$ 个整数，表示询问第几个进入教室的同学。</span><br><span class="line">输出格式</span><br><span class="line">输出 $m$ 个整数表示答案，用换行隔开。</span><br><span class="line">样例 #<span class="number">1</span></span><br><span class="line">样例输入 #<span class="number">1</span></span><br></pre></td></tr></table></figure><p>10 3<br />1 9 2 60 8 17 11 4 5 14<br />1 5 9</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">样例输出 #1</span><br></pre></td></tr></table></figure><p>1<br />8<br />5</p><pre class="highlight"><code class="">##### AC代码  ```c++#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123;  vector&lt;int&gt; stu;  int n, m, temp;  cin &gt;&gt; n &gt;&gt; m;  for (int i = 0; i &lt; n; i++)  &#123;    cin &gt;&gt; temp;    stu.push_back(temp);    //cin &gt;&gt; stu[i];这种输入不行  &#125;  for (int i = 0; i &lt; m; i++)  &#123;    cin &gt;&gt; temp;    cout &lt;&lt; stu[temp - 1] &lt;&lt; endl;  &#125;  return 0;&#125;</code></pre><h3 id="vector数组"><a class="markdownIt-Anchor" href="#vector数组"></a> vector数组</h3>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 总结整理 </tag>
            
            <tag> 算法入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>for循环的理解问题</title>
      <link href="/2023/03/05/for%E5%BE%AA%E7%8E%AF%E7%90%86%E8%A7%A3%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/05/for%E5%BE%AA%E7%8E%AF%E7%90%86%E8%A7%A3%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ul><li>笔者在做下题时发现了对于for循环的重大理解错误</li></ul><blockquote><p>[NOIP2013 普及组] 计数问题<br />题目描述<br />试计算在区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 的所有整数中，数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>x</mi><mo>≤</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">0\le x\le9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span>）共出现了多少次？例如，在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>11</mn></mrow><annotation encoding="application/x-tex">11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span></span></span></span> 中，即在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>11</mn></mrow><annotation encoding="application/x-tex">1,2,3,4,5,6,7,8,9,10,11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span></span></span></span> 中，数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 出现了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 次。<br />输入格式<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">n,x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span></span></span></span>，之间用一个空格隔开。<br />输出格式<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个整数，表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 出现的次数。<br />样例输入 #1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 1</span><br></pre></td></tr></table></figure><p>样例输出 #1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>提示<br />对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">1\le n\le 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>x</mi><mo>≤</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">0\le x \le 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span>。</p><h2 id="练习代码为"><a class="markdownIt-Anchor" href="#练习代码为"></a> 练习代码为</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> n,x,sum=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span> (i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(i%<span class="number">10</span>==x)</span><br><span class="line">        sum++;</span><br><span class="line">      i/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;sum;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>程序运行时发现为死循环 ，调试过程中发现通过while循环i=0退出后，i重新被赋值为1，重现上一次循环。通过调试我发现自己在for循环理解出现问题。之前认为for(int i=1;i&lt;=n;i++)固定的是，第一层为i=1,执行循环体后i就是2,现在才发现理解出现了很大的差错。关键在于i++，本题练习过程中i为循环变量，通过while循环改变i为0后，循环体结束下一步i++，i变为1，而不是理想中的2。<br />因此本题应该添加临时变量让替代循环变量。</p><p>##ACcode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> n,x,temp,sum=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    temp=i;</span><br><span class="line">    <span class="keyword">while</span> (temp)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(temp%<span class="number">10</span>==x)</span><br><span class="line">        sum++;</span><br><span class="line">      temp/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;sum;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
            <tag> 反思 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题目反思</title>
      <link href="/2023/03/05/%E9%A2%98%E7%9B%AE%E5%8F%8D%E6%80%9D/"/>
      <url>/2023/03/05/%E9%A2%98%E7%9B%AE%E5%8F%8D%E6%80%9D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[NOIP2015 普及组] 金币<br />题目背景<br />NOIP2015 普及组 T1<br />题目描述<br />国王将金币作为工资，发放给忠诚的骑士。第一天，骑士收到一枚金币；之后两天（第二天和第三天），每天收到两枚金币；之后三天（第四、五、六天），每天收到三枚金币；之后四天（第七、八、九、十天），每天收到四枚金币……；这种工资发放模式会一直这样延续下去：当连续 n 天每天收到 n 枚金币后，骑士会在之后的连续 n+1 天里，每天收到 n+1 枚金币。<br />请计算在前 k 天里，骑士一共获得了多少金币。<br />输入格式<br />一个正整数 k，表示发放金币的天数。<br />输出格式<br />一个正整数，即骑士收到的金币数。<br />样例输入 #1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p>样例输出 #1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure><p>样例输入 #2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000</span><br></pre></td></tr></table></figure><p>样例输出 #2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">29820</span><br></pre></td></tr></table></figure><p>提示<br />【样例 1 说明】<br />骑士第一天收到一枚金币；第二天和第三天，每天收到两枚金币；第四、五、六天，每天收到三枚金币。因此一共收到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>3</mn><mo>=</mo><mn>14</mn></mrow><annotation encoding="application/x-tex">1+2+2+3+3+3=14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">4</span></span></span></span> 枚金币。<br />对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">1\le k\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>。</p><h3 id="ac代码个人"><a class="markdownIt-Anchor" href="#ac代码个人"></a> AC代码(个人)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> k,sum=<span class="number">0</span>;</span><br><span class="line">  cin &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;k&gt;<span class="number">0</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i;k&gt;<span class="number">0</span>&amp;&amp;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">      k=k<span class="number">-1</span>;</span><br><span class="line">      sum=sum+i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ac官方"><a class="markdownIt-Anchor" href="#ac官方"></a> AC（官方）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> k, coin = <span class="number">0</span>, day = <span class="number">0</span>;</span><br><span class="line">  cin &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      coin += i;</span><br><span class="line">      day++;</span><br><span class="line">      <span class="keyword">if</span> (day == k)</span><br><span class="line">      &#123;</span><br><span class="line">        cout &lt;&lt; coin &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
            <tag> 反思 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>acm(测试方法)</title>
      <link href="/2023/02/24/acm%EF%BC%88%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%EF%BC%89/"/>
      <url>/2023/02/24/acm%EF%BC%88%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>注：本文根据《算法入门经典第（2）版》撰写</p><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><blockquote><p>由于程序需要测试大量用例，手动输入较为麻烦。因此可以使用文件操作。一个好的方法是用文件——把输入数据保存在文件中，输出数据也保存在文件中。这样，只要事先把输入数据保存在文件中，就不必每次重新输入了；数据输出在文件中也避免了“输出太多，一卷屏前面的就看不见了”这样的尴尬，运行结束后，慢慢浏览输出文件即可。如果有标准答案文件，还可以进行文件比较，而无须编程人员逐个检查输出是否正确。事实上，几乎所有算法竞赛的输入数据和标准答案都是保存在文件中的。</p></blockquote><p>示例中采用创建date.in文件存储输入，date.out存储输出。</p><h2 id="一-文件重定向"><a class="markdownIt-Anchor" href="#一-文件重定向"></a> 一、文件重定向</h2><p>使用文件最简单的方法是使用输入输出重定向，只需在 main 函数的入口处加入以下两条语句：</p><ul><li>freopen(“input.txt”, “r”, stdin);</li><li>freopen(“output.txt”, “w”, stdout);</li></ul><p>上述语句将使得 scanf 从文件 input.txt 读入，printf 写入文件 output.txt。事实上，不只是 scanf 和 printf，所有读键盘输入、写屏幕输出的函数都将改用文件。尽管这样做很方便，并不是所有算法竞赛都允许用程序读写文件。甚至有的竞赛允许访问文件，但不允许用freopen 这样的重定向方式读写文件。参赛之前请仔细阅读文件读写的相关规定。</p><p>利用文件是一种很好的自我测试方法，但如果比赛要求采用标准输入输出，就必须在自我测试完毕之后删除重定向语句。<br />但是还有一种操作就是条件编译。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOCAL </span></span><br><span class="line">······</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL </span></span><br><span class="line"> <span class="built_in">freopen</span>(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); </span><br><span class="line"> <span class="built_in">freopen</span>(<span class="string">&quot;data.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout); </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">······</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该操作通过定义宏来规避影响，因为许多oj评测，编译时会定义ONLINE_JUDGE宏。如果有检测到这个宏，就不会运行重定向操作，这样就可以在本地使用文件输入输出。</p><h3 id="示例代码"><a class="markdownIt-Anchor" href="#示例代码"></a> 示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOCAL </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000000 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL </span></span><br><span class="line"> freopen(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>); </span><br><span class="line"> freopen(<span class="string">&quot;data.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>); </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> <span class="type">int</span> x, n = <span class="number">0</span>, min = INF, max = -INF, s = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x) == <span class="number">1</span>) </span><br><span class="line"> &#123; </span><br><span class="line"> s += x; </span><br><span class="line"> <span class="keyword">if</span>(x &lt; min) min = x; </span><br><span class="line"> <span class="keyword">if</span>(x &gt; max) max = x; </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> printf(&quot;x = %d, min = %d, max = %d\n&quot;, x, min, max); </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"> n++; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d %d %.3f\n&quot;</span>, min, max, (<span class="type">double</span>)s/n); </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这是一份典型的比赛代码，包含了几个特殊之处：</p><ul><li>重定向的部分被写在了#ifdef 和#endif 中。其含义是：只有定义了符号 LOCAL，才编译两条 freopen 语句。</li><li>输出中间结果的 printf 语句写在了注释中——它在最后版本的程序中不应该出现，但是又舍不得删除它（万一发现了新的 bug，需要再次用它输出中间信息）。将其注释的好处是：一旦需要时，把注释符去掉即可。</li></ul><p>上面的代码在程序首部就定义了符号 LOCAL，因此在本机测试时使用重定向方式读写文件。如果比赛要求读写标准输入输出，只需在提交之前删除#define LOCAL 即可。一个更好的方法是在编译选项而不是程序里定义这个 LOCAL 符号（不知道如何在编译选项里定义符号的读者请参考附录 A），这样，提交之前不需要修改程序，进一步降低了出错的可能。<br />提示 ：在算法竞赛中，有经验的选手往往会使用条件编译指令并且将重要的测试语句注释掉而非删除。</p><h2 id="fopen版"><a class="markdownIt-Anchor" href="#fopen版"></a> fopen版</h2><p>如果比赛要求用文件输入输出，但禁止用重定向的方式，又当如何呢？程序如下：<br />数据统计（fopen 版）</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; FILE *fin, *fout; </span><br><span class="line"> fin = fopen(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;rb&quot;</span>); </span><br><span class="line"> fout = fopen(<span class="string">&quot;data.out&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">  <span class="type">int</span> n, u, d, i, time = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">fscanf</span>(fin,<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;u, &amp;d) !=EOF &amp;&amp; (n!=<span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= u)</span><br><span class="line">      time = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;  <span class="keyword">for</span> (i = <span class="number">1</span>;; i++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= ((u - d) * i + u))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      time = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(fout,<span class="string">&quot;%d\n&quot;</span>, time);</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(fin); </span><br><span class="line">  fclose(fout);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>虽然新内容不少，但也很直观：先声明变量 fin 和 fout（暂且不用考虑 FILE *），把 scanf改成 fscanf，第一个参数为 fin；把 printf 改成 fprintf，第一个参数为 fout，最后执行 fclose，<br />关闭两个文件。<br />提示 ：在算法竞赛中，如果不允许使用重定向方式读写数据，应使用 fopen 和 fscanf/fprintf 进行输入输出。<br />重定向和 fopen 两种方法各有优劣。重定向的方法写起来简单、自然，但是不能同时读写文件和标准输入输出；fopen 的写法稍显繁琐，但是灵活性比较大（例如，可以反复打开并读写文件）。顺便说一句，如果想把 fopen 版的程序改成读写标准输入输出，只需赋值“fin =stdin; fout = stdout;”即可，不要调用 fopen 和 fclose。</p>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验 </tag>
            
            <tag> ACM训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>memcpy函数（详解）</title>
      <link href="/2023/02/24/memcpy/"/>
      <url>/2023/02/24/memcpy/</url>
      
        <content type="html"><![CDATA[<h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3><p>memcpy函数是C/C<ins>语言中的一个用于内存复制的函数，声明在 string.h 中（C</ins>是 cstring）。其原型是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *destin, <span class="type">void</span> *source, <span class="type">unsigned</span> n)</span>;</span><br></pre></td></tr></table></figure><p>作用是：以source指向的地址为起点，将连续的n个字节数据，复制到以destin指向的地址为起点的内存中。<br />函数有三个参数，第一个是目标地址，第二个是源地址，第三个是数据长度。</p><p>使用memcpy函数时，需要注意：</p><ul><li>数据长度（第三个参数）的单位是字节（1byte = 8bit）。</li><li>注意该函数有一个返回值，类型是void*，是一个指向destin的指针。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dst, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *psrc;</span><br><span class="line">    <span class="type">char</span> *pdst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == dst || <span class="literal">NULL</span> == src)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((src &lt; dst) &amp;&amp; (<span class="type">char</span> *)src + size &gt; (<span class="type">char</span> *)dst) <span class="comment">// 出现地址重叠的情况，自后向前拷贝</span></span><br><span class="line">    &#123;</span><br><span class="line">        psrc = (<span class="type">char</span> *)src + size - <span class="number">1</span>;</span><br><span class="line">        pdst = (<span class="type">char</span> *)dst + size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (size--)</span><br><span class="line">        &#123;</span><br><span class="line">            *pdst-- = *psrc--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        psrc = (<span class="type">char</span> *)src;</span><br><span class="line">        pdst = (<span class="type">char</span> *)dst;</span><br><span class="line">        <span class="keyword">while</span> (size--)</span><br><span class="line">        &#123;</span><br><span class="line">            *pdst++ = *psrc++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="memcpy函数复制的数据长度"><a class="markdownIt-Anchor" href="#memcpy函数复制的数据长度"></a> memcpy函数复制的数据长度</h3><p>使用memcpy函数时，特别要注意数据长度。如果复制的数据类型是char，那么数据长度就等于元素的个数。而如果数据类型是其他（如int, double, 自定义结构体等），就要特别注意数据长度的值。<br />好的习惯是，<mark>无论拷贝何种数据类型，都用 n * sizeof(type_name)的写法。</mark></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">10</span>] = <span class="string">&quot;abcdefgh&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> n = <span class="number">2</span>;</span><br><span class="line"><span class="type">void</span> * p = <span class="built_in">memcpy</span>(a+<span class="number">3</span>, a, n);</span><br></pre></td></tr></table></figure><p>以上代码将从a开始的两个字节的数据（即’a’和’b’），复制到从a+3开始的内存（'d’所在的地址）。这样，'d’和’e’被替换。<br />执行结束之后，字符数组（字符串）a的内容变为&quot;abcabfgh&quot;，返回值p即为a的地址（p == a）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="type">void</span> * p = <span class="built_in">memcpy</span>(a+<span class="number">3</span>, a, n);</span><br></pre></td></tr></table></figure><p>int类型的长度是4个字节。以上代码将从a开始的5个字节的数据复制。5个字节的数据是什么呢？前四个字节组成了一个完整的int（即第一个元素0）。第五个字节，只能取到第二个元素的第1个字节。这里又会涉及到big-endian和little-endian的问题。假设是小端方式储存（更常见），那么读到的是元素1的低8位，写成十六进制即0x1。<br />目标地址是a+3。由于指针加减常数，单位是与类型保持一致的，也就是在a的基础上，增加3倍int长度，对应的是元素3的地址。元素3被替换为0。元素4写成十六进制是0x0004，低8位被替换为0x1，变为0x0001。<br />所以执行结束之后，数组a的内容变为 { 0， 1， 2， 0， 1， 5， 6， 7， 8， 9 }，返回值p即为a的地址（p == a）。<br />根据上面的解释，如果把程序里的n改为6、7、8，那么结果都是一样的。因为数字1和4的二进制表示除了低8位不同，高位都是0。</p><p>倘若高位不相同，那么结果就没那么简单了。还是以int数组为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(a+<span class="number">3</span>, a, n);</span><br></pre></td></tr></table></figure><p>复制5个字节的数据，前4个字节组成了一个int，即第一个元素0。那么元素3被替换为0。第5个字节从-1中取。-1的十六进制表示为0xFFFF，第5个字节的数据是0xF。元素4变为0x000F，即15。数组a变为 { 0， -1， 2， 0， 15， 5， 6， 7， 8， 9 }。<br />如果 n = 6，那么4变为0x00FF，即255。数组a变为 { 0， -1， 2， 0， 255， 5， 6， 7， 8， 9 }。</p><p>可以看出，如果你想用memcpy复制元素，那么一定要写对数据长度。如果要完整地复制 n 个 int 类型元素，那么写法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> n = <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(a+<span class="number">3</span>, a, n);</span><br></pre></td></tr></table></figure><p>数组a变为 { 0， -1， 2， 0， -1， 2， 0， -1， 8， 9 }。<br />如果是其他类型，用法也是一样的。</p>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数详解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础知识</title>
      <link href="/2023/02/05/Git%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/02/05/Git%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="git基础知识"><a class="markdownIt-Anchor" href="#git基础知识"></a> Git基础知识</h1><h2 id="一-git的基本操作命令行"><a class="markdownIt-Anchor" href="#一-git的基本操作命令行"></a> 一、git的基本操作（命令行）</h2><h3 id="1建立仓库"><a class="markdownIt-Anchor" href="#1建立仓库"></a> 1.建立仓库</h3><p>在根目录输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">```   </span><br><span class="line">在mac、linux中隐藏了.git的文件夹，即本地git仓库。所有提交的内容都会储存在里面。  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 2.添加文件（告诉git需要添加的文件有哪些）</span></span></span><br><span class="line">``` shell</span><br><span class="line">git add 文件名  //单一文件</span><br><span class="line">git add -A //多文件，即将所有新增修改的文件全部上传</span><br><span class="line">```   </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 3.提交到本地仓库</span></span>  </span><br><span class="line">``` shell</span><br><span class="line">git commit -m &quot;初次提交/更新图片&quot; //&quot;&quot;内内容自定义，用来标识操作</span><br></pre></td></tr></table></figure><h3 id="4建立本地仓库与github的联系"><a class="markdownIt-Anchor" href="#4建立本地仓库与github的联系"></a> 4.建立本地仓库与github的联系</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/用户名/仓库名.git //github生成htttps链接</span><br><span class="line">```   </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 5.上传到仓库</span></span></span><br><span class="line">``` shell</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>git push 到远程仓库的master（主分支）上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">info: please complete authentication in your browser...</span><br><span class="line">Enumerating objects: 3, done.</span><br><span class="line">Counting objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (3/3), 222 bytes | 222.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">To https://github.com/Hao-star123/git_learn.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">branch &#x27;master&#x27; set up to track &#x27;origin/master&#x27;.  </span><br></pre></td></tr></table></figure><p>第一次使用github会弹出登录界面</p><h2 id="二"><a class="markdownIt-Anchor" href="#二"></a> 二、</h2><h3 id="1下载仓库代码pull"><a class="markdownIt-Anchor" href="#1下载仓库代码pull"></a> 1.下载仓库代码（pull)</h3><p>当线上版本更新，下载时可以使用拉取命令,将文件下载到本地进行更新。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h3 id="2下载仓库代码git-clone"><a class="markdownIt-Anchor" href="#2下载仓库代码git-clone"></a> 2.下载仓库代码(git clone)</h3><pre class="highlight"><code class="shell">git clone https://github.com/用户名/仓库名.git</code></pre><h3 id="3ssh秘钥"><a class="markdownIt-Anchor" href="#3ssh秘钥"></a> 3.ssh秘钥</h3><p>秘钥分为私钥（存放在本地，类似于门禁卡）和公钥（github,类似于装门禁的门）</p><h4 id="1生成秘钥"><a class="markdownIt-Anchor" href="#1生成秘钥"></a> 1.生成秘钥</h4><pre class="highlight"><code class="shell">ssh-keygen</code></pre><p>秘钥位置：</p><ol><li>mocOS<ul><li>~/.ssh</li></ul></li><li>Windows<ul><li>C:/用户/（你的）用户名/.ssh</li></ul></li></ol><blockquote><p>生成文件id_rsa是私钥<br />id_rsa.pub是公钥</p></blockquote><p>用记事本打开公钥，复制公钥</p><h4 id="2配置ssh到github"><a class="markdownIt-Anchor" href="#2配置ssh到github"></a> 2.配置ssh到github</h4><p>进入github，点击右上角头像 选择settings，进入设置页后选择 SSH and GPG keys，名字随便起，公钥填到Key那一栏。<br />配置成功后，可使用ssh方式连接github</p><pre class="highlight"><code class="shell">git clone git@github.com:用户名/仓库名.git</code></pre><h4 id="2注"><a class="markdownIt-Anchor" href="#2注"></a> 2.注</h4><p>仓库setting内的Deploy keys，是添加部署秘钥的。填写服务器生成的秘钥，不是本地开发电脑生成的秘钥。在项目上线时，在服务器上执行git clone命令时会使用的秘钥。在服务器用来运行完善代码，而非开发，因此无需要勾选 Allow write access 的写权限，主要知识在linux服务器中。</p><h2 id="htttps和ssh"><a class="markdownIt-Anchor" href="#htttps和ssh"></a> htttps和ssh</h2><p>ssh添加成功后git操作将不需要登录验证，更加方便。</p><h3 id="4添加合作用户"><a class="markdownIt-Anchor" href="#4添加合作用户"></a> 4.添加合作用户</h3><p>在仓库settings左侧的Collaborators，单击Manage access中的add people按钮，输入github的用户名或者邮箱，他会收到github的邀请邮件，确认后拥有该仓库的操作权限<br /> <br /></p><h1 id="二-git的基本操作客户端"><a class="markdownIt-Anchor" href="#二-git的基本操作客户端"></a> 二、git的基本操作（客户端）</h1><p>更新操作会显示</p>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C指针与地址</title>
      <link href="/2023/01/29/C%E6%8C%87%E9%92%88%E4%B8%8E%E5%9C%B0%E5%9D%80/"/>
      <url>/2023/01/29/C%E6%8C%87%E9%92%88%E4%B8%8E%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="c指针与地址"><a class="markdownIt-Anchor" href="#c指针与地址"></a> C指针与地址</h1><blockquote><p>在C语言的学习过程中，常理不清指针（即一个变量的地址）和指针变量（专门用来存放另一变量的地址(指针)的变量）的关系，因此通过程序打印地址运行结果，来分析加强理解。以此记录学习过程中的心得，希望能帮到大家，感谢指正。</p></blockquote><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><h3 id="一-代码示例"><a class="markdownIt-Anchor" href="#一-代码示例"></a> 一、代码示例</h3><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">88</span>,b=<span class="number">60</span> ;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p=&amp;a;<span class="comment">//指向a的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#p&quot;</span>,p);<span class="comment">//以十六进制的形式输出</span></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot; %p &quot;</span>,*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %p\n&quot;</span>,&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot; %d &quot;</span>,*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %d\n&quot;</span>,&amp;p);</span><br><span class="line">    p--;<span class="comment">//指针移动指向b的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#p&quot;</span>,p);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot; %p &quot;</span>,*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %p\n&quot;</span>,&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot; %d &quot;</span>,*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %d\n&quot;</span>,&amp;p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2运行结果"><a class="markdownIt-Anchor" href="#2运行结果"></a> 2.运行结果</h3><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000000000061F</span>E1C</span><br><span class="line"><span class="number">0X000000000061FE1C</span> <span class="number">0000000000000058</span>  <span class="number">000000000061F</span>E10</span><br><span class="line"><span class="number">6422044</span> <span class="number">88</span>  <span class="number">6422032</span></span><br><span class="line"><span class="number">000000000061F</span>E18</span><br><span class="line"><span class="number">0X000000000061FE18</span> <span class="number">000000000000003</span>C  <span class="number">000000000061F</span>E10</span><br><span class="line"><span class="number">6422040</span> <span class="number">60</span>  <span class="number">6422032</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>在指针*p=&amp;a初始化后，p等同于&amp;a即a的地址，在运行过程中可以代换。%#p是输出位0X开开头的16进制数。因此printf(“%p\n”,&amp;a);    printf(“%#p”,p);本质是一样的。*p则是通过指针变量p存储的a的地址，间接获取a的值。*p=a,对数值%p等同于对数值以十六进制位输出。%d对p,*p,&amp;p则是以十进制形式分别输出地址，值，地址。</p><p>p–，由于p是整型指针，p–减去int的4个字节刚好移动到b。</p><blockquote><p>【注】1.这里发现后定义的变量b的地址要小于a的地址，这是因为c语言中，先定义的数据先入栈，在栈的底部（不分配内存），声明结束后，b在栈顶，所以b先出栈，先为b分配内存。因此b的地址小于a的地址。<br />   2.数据的地址位数和数据能存储的位数无关。学习阶段曾存在疑问（输出的地址是16位，int是4字节，即16进制的4位代表一个字节（实际应该是一个字节等于2位16进制），一个字节等于八位二进制，但八位二进制不等于四位16进制？）通过交流请教得知有关计算机组成原理，地址位数只取决于系统，所有类型的指针所占长度相同。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针知识框架（详解）</title>
      <link href="/2023/01/29/%E6%8C%87%E9%92%88%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%EF%BC%88%E8%AF%A6%E8%A7%A3%EF%BC%89/"/>
      <url>/2023/01/29/%E6%8C%87%E9%92%88%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%EF%BC%88%E8%AF%A6%E8%A7%A3%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="指针知识框架详解"><a class="markdownIt-Anchor" href="#指针知识框架详解"></a> 指针知识框架（详解）</h1><blockquote><p>本文为C语言学习过程中关于指针的笔记。根据书籍和程序题并参考网络上的博客回答，撰写的感悟和收获。<br />文章参考：<br />C语言解惑指针、数组、函数和多文件编程（作者刘振安刘燕君，机械工业出版社）</p></blockquote><h2 id="一-对指针使用const限定符"><a class="markdownIt-Anchor" href="#一-对指针使用const限定符"></a> 一、对指针使用const限定符</h2><h3 id="1指向常量的指针"><a class="markdownIt-Anchor" href="#1指向常量的指针"></a> 1.指向常量的指针</h3><blockquote><p>const int  y=66;<br />const int <em>p=&amp;y; //此时y和</em>p都不能做为左值，但可以作为右值。</p></blockquote><p>使指针指向一个不可修改的常量，即<em>p是常量。但是可以通过修改p指向的地址，改变</em>p的值。<br />例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">const</span> <span class="type">int</span> y=<span class="number">66</span>;</span><br><span class="line"> <span class="type">int</span> x=<span class="number">50</span>;</span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> * p =&amp;y;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%p\n&quot;</span>,y,*p,p);</span><br><span class="line"> p=&amp;x;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%p\n&quot;</span>,x,*p,p);</span><br><span class="line"><span class="comment">/*输出结果为：</span></span><br><span class="line"><span class="comment">  66,66,000000000062FE14</span></span><br><span class="line"><span class="comment">  50,50,000000000062FE10*/</span></span><br></pre></td></tr></table></figure><p>由指向y改为指向x,*p被覆盖。</p><h3 id="2指向常量的指针指向非常量"><a class="markdownIt-Anchor" href="#2指向常量的指针指向非常量"></a> 2.指向常量的指针指向非常量</h3><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">55</span> ;<span class="comment">//变量x能作为左值和右值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y=<span class="number">88</span>;<span class="comment">//常量y不能作为左值，但可以作为右值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *p;<span class="comment">//声明指向常量的指针</span></span><br><span class="line">    <span class="type">int</span> *p1 ;<span class="comment">//声明指针</span></span><br><span class="line">    p=&amp;y ;<span class="comment">//用常量初始化指向常量的指针，*p不能作为左值</span></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>,*p) ;</span><br><span class="line">    p=&amp;x;<span class="comment">//p作为左值，使常量指针改为指向变量x,*p不能作为左值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*p) ;</span><br><span class="line">    x=<span class="number">128</span> ;<span class="comment">//用x作为左值间接改变*p的值，使*p=x=128</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *p) ;</span><br><span class="line">    p1=(<span class="type">int</span>*)&amp;y;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p1) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中指向常量的指针p指向变量x,仅限制直接使用<em>p作为左值，但可以通过直接修改x的值改变</em>p的值。同时也与使用非常量指针一样，也可以直接使用“&amp;”改变常量指针的指向，显然也改变了*p的值。</p><blockquote><p>【注】常量只能由指向常量的指针（即const void<em>p）指向，否则必须进行强制转换，将常量强制转换为相应的指针类型。如示例：p1=(int</em>)&amp;y;</p></blockquote><h3 id="3常量指针"><a class="markdownIt-Anchor" href="#3常量指针"></a> 3.常量指针</h3><p>限定符const放在*号右边，是指针本身成为一个const指针。声明常量时必须进行初始化，即指针变量p存储的为常量地址。</p><blockquote><p>例如:int x=45;<br />int * const p=&amp;x//p始终指向x的地址。但可以修改x地址内存的值，x=123和*p=123；但p指向的地址不能改变</p></blockquote><h3 id="4指向常量的常量指针"><a class="markdownIt-Anchor" href="#4指向常量的常量指针"></a> 4.指向常量的常量指针</h3><p>即指针和指向的对象都不能改动的“指向常量的常量指针”。<em>p和p都是常量。限制了“&amp;”和“</em>”运算符，很少使用。</p><h3 id="5void指针"><a class="markdownIt-Anchor" href="#5void指针"></a> 5.void指针</h3><p>void类型不能声明变量，但可以声明void类型的指针，而void型指针可以指向任何类型的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">256</span>, y=<span class="number">386</span>,*p=&amp;x;</span><br><span class="line">    <span class="type">void</span>*vp=&amp;x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,vp,p,x);</span><br><span class="line">    vp=&amp;y;</span><br><span class="line">    p=(<span class="type">int</span>*)vp;<span class="comment">//虽然void指针指向整型变量对象x，但不能使用*vp应用整型对象的值。要引用这个值，必须强制将void指针赋值给与值相对应的指针类型。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,vp,p,*p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【注】但奇怪的是，测试时发现p=(int*)vp不加（int*）也可以正常运行。</p></blockquote><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><p>const放在<em>的右边（void * const p）,修饰的是指针（即指针变量p指向的地址）不可改变。<br />const放在前端（const void * p）,修饰的是指向的对象（指针变量p存储的地址的值）,即</em>p是常量</p><h2 id="二-指针与数组"><a class="markdownIt-Anchor" href="#二-指针与数组"></a> 二、指针与数组</h2><h3 id="1数组与指针的关系"><a class="markdownIt-Anchor" href="#1数组与指针的关系"></a> 1.数组与指针的关系</h3><p>指向数组的指针实际上指的是能够指向数组众人一个元素的指针。</p><blockquote><p>int a[5];<br />int *pa=&amp;a[0];//等同于int *pa;<br />            pa=a;</p></blockquote><p>数组名和指针的区别：指针是变量：pa=a或pa<ins>是有意义的；<br />      数组名是指针常量：a=pa、a</ins>、pa=&amp;a（a本身就是地址，无法对地址取地址）是非法操作。<br />假设指针现在指向a[0],则数组的第i个（下标为i）元素可表示为a[i]或*（pa+i）,还可使用带下标的指针pa,即pa[i]和*（pa+i）的含义一样。若将a[i]的值修改，下列语句等价。</p><blockquote><p>a[i]=123; *(a+4)=123; *(pa+4)=123; pa[4]=123;</p></blockquote><p><em><center>指针与数组元素的关系</center></em></p><table><thead><tr><th>下标</th><th>数组名</th><th>指针</th><th>指针下标</th><th>四者的逻辑关系</th></tr></thead><tbody><tr><td>a[0]</td><td>a</td><td>pa</td><td>pa[0]</td><td>a[0]<mark>*a</mark>*pa==pa[0]</td></tr><tr><td>a[1]</td><td>a+1</td><td>pa+1</td><td>pa[1]</td><td>a[1]<mark>*(a+1)</mark>*(pa+1)==pa[1]</td></tr><tr><td>a[2]</td><td>a+2</td><td>pa+2</td><td>pa[2]</td><td>a[2]<mark>*(a+2)</mark>*(pa+2)==pa[2]</td></tr></tbody></table><h2 id="2指针数组和数组指针"><a class="markdownIt-Anchor" href="#2指针数组和数组指针"></a> 2.指针数组和数组指针</h2><blockquote><p>数组的指针：是一个指针，什么样的指针呢？指向数组的指针。<br />指针的数组：是一个数组，什么样的数组呢？装着指针的数组。<br />本质是的后面是类型。<br />然后，需要明确一个优先级顺序：()&gt;[]&gt;*，所以：<br />(*p)[n]：根据优先级，先看括号内，则p是一个指针，这个指针指向一个一维数组，数组长度为n，这是“数组的指针”，即数组指针；<br /><em>p[n]：根据优先级，先看[]，则p是一个数组，再结合</em>，这个数组的元素是指针类型，共n个元素，这是“指针的数组”，即指针数组。<br />根据上面两个分析，可以看出，p是什么，则词组的中心词就是什么，即数组“指针”和指针“数组”。  <br>————数组指针和指针数组_mick_hu的博客-CSDN博客_数组指针和指针数组<a href="https://blog.csdn.net/mick_hu/article/details/100931034?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166954491916782428658613%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166954491916782428658613&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-100931034-null-null.142%5Ev66%5Econtrol,201%5Ev3%5Econtrol_2,213%5Ev2%5Et3_esquery_v2&amp;utm_term=%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88&amp;spm=1018.2226.3001.4187">原文地址</a></p></blockquote><h2 id="3-c语言优先级"><a class="markdownIt-Anchor" href="#3-c语言优先级"></a> 3. c语言优先级</h2><blockquote><p>C语言运算符优先级（超详细）_embed_huang的博客-CSDN博客_c语言运算符优先级构成一系列表达式（六个左右），然后分析并打印输出他的结果<a href="https://blog.csdn.net/huangblog/article/details/8271791?spm=1001.2014.3001.5506">原文地址</a></p></blockquote><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法入门</title>
      <link href="/2023/01/29/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"/>
      <url>/2023/01/29/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">实验A1：表达式<span class="number">11111</span>*<span class="number">11111</span>的值是多少？把<span class="number">5</span>个<span class="number">1</span>改成<span class="number">6</span>个<span class="number">1</span>呢？<span class="number">9</span>个<span class="number">1</span>呢？</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">11111</span>*<span class="number">11111</span>);  <span class="comment">//正常数字123454321</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">111111</span>*<span class="number">111111</span>); <span class="comment">//数据太大溢出，为负值-539247567</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">111111111</span>*<span class="number">111111111</span>); <span class="comment">//结果是整数，但是数值错误1653732529</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">实验A2：把实验A1中的所有数换成浮点数，结果如何  </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,<span class="number">11111.0</span>*<span class="number">11111.0</span>);<span class="comment">//123454321.000000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,<span class="number">111111.0</span>*<span class="number">111111.0</span>);<span class="comment">//12345654321.000000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,<span class="number">111111111.0</span>*<span class="number">111111111.0</span>);<span class="comment">//12345678987654320.000000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*又改成%d</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    printf(&quot;%d\n&quot;,11111.0*11111.0);//123454321.000000</span></span><br><span class="line"><span class="comment">    printf(&quot;%d\n&quot;,111111.0*111111.0);//12345654321.000000</span></span><br><span class="line"><span class="comment">    printf(&quot;%d\n&quot;,111111111.0*111111111.0);//12345678987654320.000000</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/zhaojunwuiris/article/details/83654072">#INF00：出现此报错说明是数值溢出，或者说是除数为0</a></p></blockquote><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>#IND</td><td>这个的情况更复杂，一般来说，它们来自于任何未定义结果（非法）的浮点数运算。&quot;IND&quot;是 indeterminate（不确定） 的缩写，而&quot;nan&quot;是 not a number 的缩写。IND表示NAN, 比如 0/0  log( -1 ) 等等。IND是Windows上的说法，NaN是Linux上的说法，含义是一样的。产生这个值的常见例子有：对负数开平方，对负数取对数，0.0/0.0，0.0*∞, ∞/∞ 等。也可能由于一些操作使得程序中产生了无效数字或者没有给成员变量赋值，使用类似于pow, exp等等函数时常会产生一个无效数字1.#IND00（-1.#IND00 对应符号位 1 , 阶码全1 , 尾数非0 ）。</td></tr><tr><td>#INF</td><td>这个值表示“无穷大inf (infinity 的缩写)”，即超出了计算机可以表示的浮点数的最大范围（或者说超过了 double 类型的最大值）。一般来说是除数为0得出的结果，例如，当一个整数除以0时便会得到一个1.#INF / inf值；相应的，如果一个负整数除以0会得到 -1.#INF / -inf 值。</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">实验A3：表达式<span class="built_in">sqrt</span>(<span class="number">-10</span>)的值是多少？尝试用各种方式输出。在计算过程中系统会报错吗？  </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,<span class="built_in">sqrt</span>(<span class="number">-10</span>));<span class="comment">//-1.#IND00</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sqrt</span>(<span class="number">-10</span>));<span class="comment">//0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>,<span class="built_in">sqrt</span>(<span class="number">-10</span>));<span class="comment">//-1.#IND000000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">实验A4：表达式<span class="number">1.0</span>/<span class="number">0.0</span>,<span class="number">0.0</span>/<span class="number">0.0</span>的值是多少？尝试用各种方式输出。在计算过程中会报错吗？  </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,<span class="number">1.0</span>/<span class="number">0.0</span>);<span class="comment">//1.#INF00</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>,<span class="number">1.0</span>/<span class="number">0.0</span>);<span class="comment">//1.#J</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>,<span class="number">1.0</span>/<span class="number">0.0</span>);<span class="comment">//1.#INF000000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,<span class="number">0.0</span>/<span class="number">0.0</span>);<span class="comment">//-1.#IND00</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>,<span class="number">0.0</span>/<span class="number">0.0</span>);<span class="comment">//-1.#J</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">用程序实验测试<span class="type">int</span>整数的最小值和最大值（精确值）</span><br><span class="line"><span class="comment">//决定int最大值的主要原因:根据编译器类型不同而变化。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;    </span><br><span class="line"> <span class="comment">/*int n = 0, i = 0;</span></span><br><span class="line"><span class="comment"> while (n &gt;= i)</span></span><br><span class="line"><span class="comment"> &#123;</span></span><br><span class="line"><span class="comment">   n = i;</span></span><br><span class="line"><span class="comment">   i--;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> printf(&quot;%d&quot;, n);*/</span>   <span class="comment">//-2147483648(最小值)</span></span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> n = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (n &lt;= i) &#123;</span><br><span class="line">   n = i;</span><br><span class="line">   i++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n);     <span class="comment">//2147483647（最大值）</span></span><br><span class="line"> system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//7744 问题（1）函数 floor(x)返回不超过 x 的最大整数。floor(小数不能是整数)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">1</span>; a &lt;= <span class="number">9</span>; a++) </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">9</span>; b++) </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="type">int</span> n = a*<span class="number">1100</span> + b*<span class="number">11</span>; <span class="comment">//这里才开始使用 n，因此在这里定义 n</span></span><br><span class="line"> <span class="type">int</span> m = <span class="built_in">floor</span>(<span class="built_in">sqrt</span>(n) + <span class="number">0.5</span>); </span><br><span class="line"> <span class="keyword">if</span>(m*m == n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*读者可能会问：可不可以这样写？if(sqrt(n) == floor(sqrt(n))) printf(&quot;%d\n&quot;, n)，即直接判</span></span><br><span class="line"><span class="comment">断 sqrt(n)是否为整数。理论上当然没问题，但这样写不保险，因为浮点数的运算（和函数）</span></span><br><span class="line"><span class="comment">有可能存在误差。</span></span><br><span class="line"><span class="comment">假设在经过大量计算后，由于误差的影响，整数 1 变成了 0.9999999999，floor 的结果</span></span><br><span class="line"><span class="comment">会是 0 而不是 1。为了减小误差的影响，一般改成四舍五入，即 floor(x+0.5)①。如果难以理</span></span><br><span class="line"><span class="comment">解，可以想象成在数轴上把一个单位区间往左移动 0.5 个单位的距离。floor(x)等于 1 的区间</span></span><br><span class="line"><span class="comment">为[1,2)，而 floor(x+0.5)等于 1 的区间为[0.5, 1.5)。</span></span><br><span class="line"><span class="comment">提示 2-7：浮点运算可能存在误差。在进行浮点数比较时，应考虑到浮点误差。*/</span></span><br></pre></td></tr></table></figure><blockquote><p>数学定理：要计算只包含加法、减法和乘法的整数表达式除以正整数 n 的余数，可以在每步计算之后对 n 取余，结果不变</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*p31 程序 2-11 数据统计（fopen 版），如果想把 fopen 版的程序改成读写标准输入输出，只需赋值“fin =stdin; fout =stdout;”即可，不要调用 fopen 和 fclose①。*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000000 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line"> FILE *fin, *fout; </span><br><span class="line"> fin = fopen(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;rb&quot;</span>); </span><br><span class="line"> fout = fopen(<span class="string">&quot;data.out&quot;</span>, <span class="string">&quot;wb&quot;</span>); </span><br><span class="line"> <span class="type">int</span> x, n = <span class="number">0</span>, min = INF, max = -INF, s = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">while</span>(<span class="built_in">fscanf</span>(fin, <span class="string">&quot;%d&quot;</span>, &amp;x) == <span class="number">1</span>) </span><br><span class="line"> &#123; </span><br><span class="line"> s += x; </span><br><span class="line"> <span class="keyword">if</span>(x &lt; min) min = x; </span><br><span class="line"> <span class="keyword">if</span>(x &gt; max) max = x; </span><br><span class="line"> n++; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">fprintf</span>(fout, <span class="string">&quot;%d %d %.3f\n&quot;</span>, min, max, (<span class="type">double</span>)s/n); </span><br><span class="line"> fclose(fin); </span><br><span class="line"> fclose(fout); </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Time used = %.2f\n&quot;</span>, (<span class="type">double</span>)clock() / CLOCKS_PER_SEC);</span><br></pre></td></tr></table></figure><blockquote><p>由于函数内会被系统动态分配内存比较小，所以只有数组定义放在main函数外面时，数组 a 才可以开得很大；放在 main 函数内时，数组稍大就会异常退出。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结整理 </tag>
            
            <tag> 算法入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/12/13/hello-world/"/>
      <url>/2022/12/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客相关 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
