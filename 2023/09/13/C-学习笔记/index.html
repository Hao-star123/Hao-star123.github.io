<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>C++学习笔记 | 少年没有乌托邦</title><meta name="author" content="HAO_dev"><meta name="copyright" content="HAO_dev"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="theme: vue-pro highlight: mono-blue 本文档依据中国MOOC程序设计与算法（三）C++面向对象程序设计撰写   第一章从C到C++  类和对象的基本概念与用法(1)  对象的内存分配：成员函数不被包括在对象的内存吗？   第二章 类和对象基础  1.类和对象的基本概念(2)  question1  1234567&#x2F;&#x2F;假设A是一个类的名字，下面的程序片段会调用类">
<meta property="og:type" content="article">
<meta property="og:title" content="C++学习笔记">
<meta property="og:url" content="https://www.dreamchasing.top/2023/09/13/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="少年没有乌托邦">
<meta property="og:description" content="theme: vue-pro highlight: mono-blue 本文档依据中国MOOC程序设计与算法（三）C++面向对象程序设计撰写   第一章从C到C++  类和对象的基本概念与用法(1)  对象的内存分配：成员函数不被包括在对象的内存吗？   第二章 类和对象基础  1.类和对象的基本概念(2)  question1  1234567&#x2F;&#x2F;假设A是一个类的名字，下面的程序片段会调用类">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://picbed.dreamchasing.top/img/spring.webp">
<meta property="article:published_time" content="2023-09-13T12:30:00.000Z">
<meta property="article:modified_time" content="2023-09-21T15:05:00.000Z">
<meta property="article:author" content="HAO_dev">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://picbed.dreamchasing.top/img/spring.webp"><link rel="shortcut icon" href="https://picbed.dreamchasing.top/img/code-solid.svg"><link rel="canonical" href="https://www.dreamchasing.top/2023/09/13/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-21 23:05:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/essay_page/essay_page.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/loading.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://picbed.dreamchasing.top/img/Avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 文库</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li><li><a class="site-page child" href="/love/"><i class="fa-fw fa-solid fa-heart"></i><span> LOVE</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/essay/"><i class="fa-fw fas fa-edit"></i><span> 日记</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://picbed.dreamchasing.top/img/spring.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="少年没有乌托邦"><span class="site-name">少年没有乌托邦</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 文库</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li><li><a class="site-page child" href="/love/"><i class="fa-fw fa-solid fa-heart"></i><span> LOVE</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/essay/"><i class="fa-fw fas fa-edit"></i><span> 日记</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-13T12:30:00.000Z" title="发表于 2023-09-13 20:30:00">2023-09-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-21T15:05:00.000Z" title="更新于 2023-09-21 23:05:00">2023-09-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/">学习相关</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">22.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>76分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr />
<h2 id="theme-vue-prohighlight-mono-blue"><a class="markdownIt-Anchor" href="#theme-vue-prohighlight-mono-blue"></a> theme: vue-pro<br />
highlight: mono-blue</h2>
<p>本文档依据中国MOOC<a target="_blank" rel="noopener" href="https://www.icourse163.org/course/PKU-1002029030">程序设计与算法（三）C++面向对象程序设计</a>撰写</p>
<hr />
<h1 id="第一章从c到c"><a class="markdownIt-Anchor" href="#第一章从c到c"></a> 第一章从C到C++</h1>
<h2 id="类和对象的基本概念与用法1"><a class="markdownIt-Anchor" href="#类和对象的基本概念与用法1"></a> 类和对象的基本概念与用法(1)</h2>
<blockquote>
<p>对象的内存分配：成员函数不被包括在对象的内存吗？</p>
</blockquote>
<h1 id="第二章-类和对象基础"><a class="markdownIt-Anchor" href="#第二章-类和对象基础"></a> 第二章 类和对象基础</h1>
<h2 id="1类和对象的基本概念2"><a class="markdownIt-Anchor" href="#1类和对象的基本概念2"></a> 1.类和对象的基本概念(2)</h2>
<blockquote>
<p>question1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设A是一个类的名字，下面的程序片段会调用类A的析构函数几次？ 答案：3次</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A * p = <span class="keyword">new</span> A[<span class="number">2</span>];</span><br><span class="line">A * p2 = <span class="keyword">new</span> A;</span><br><span class="line">A a;</span><br><span class="line"><span class="keyword">delete</span> [] p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不能访问私有成员变量？</p>
</blockquote>
<h2 id="2-构造函数"><a class="markdownIt-Anchor" href="#2-构造函数"></a> 2. 构造函数</h2>
<blockquote>
<p>对象所占用的存储空间是不是也是构造函数分配的？</p>
<p>answer：对象函数是在对象已经占用存储空间以后，在对象存储空间中做初始化的操作</p>
</blockquote>
<blockquote>
<p>对象一定有构造函数，如果定义类的时候没有写构造函数，则编译器生成个默认的无参数的构造函数</p>
<ul>
<li>默认构造函数无参数，不做任何操作</li>
</ul>
</blockquote>
<p>构造函数在数组中的使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Test</span>( <span class="type">int</span> n)&#123;&#125;<span class="comment">//(1)</span></span><br><span class="line">        <span class="built_in">Test</span>( <span class="type">int</span> n, <span class="type">int</span> m) &#123;&#125;<span class="comment">//(2)</span></span><br><span class="line">        <span class="built_in">Test</span>()&#123;&#125;<span class="comment">//(3)</span></span><br><span class="line">&#125;;</span><br><span class="line">Test array1[<span class="number">3</span>]= &#123; <span class="number">1</span>, <span class="built_in">Test</span>(<span class="number">1</span>,<span class="number">2</span>)&#125;;<span class="comment">//三个元素分别用(1),(2),(3)初始化</span></span><br><span class="line">Test array2[<span class="number">3</span>]= &#123; <span class="built_in">Test</span>(<span class="number">2</span>,<span class="number">3</span>), <span class="built_in">Test</span>(<span class="number">1</span>,<span class="number">2</span>),<span class="number">1</span>&#125;;(/三个元素分别用(<span class="number">2</span>),(<span class="number">2</span>), (<span class="number">1</span>)初始化</span><br><span class="line">Test * pArray[<span class="number">3</span>]= &#123; <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">4</span>), <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">1</span>,<span class="number">2</span>)&#125;<span class="comment">//两个元素分别用(1),(2)初始化</span></span><br></pre></td></tr></table></figure>
<p>对于代码中的 <code>Test array1[3] = &#123;1, Test(1,2)&#125;</code>，它创建了一个名为 <code>array1</code> 的 <code>Test</code> 类型的数组，并初始化了其中的元素。</p>
<p><code>Test(1,2)</code> 是以参数值 <code>1</code> 和 <code>2</code> 调用 <code>Test</code> 类的构造函数 <code>(2)</code> 来创建一个临时对象。这个临时对象将被用来初始化 <code>array1</code> 中的第二个元素。</p>
<p>因此，<code>Test(1,2)</code> 将调用 <code>(2)</code> 构造函数，而不是其他的构造函数 <code>(1)</code> 或 <code>(3)</code>。</p>
<h2 id="3复制拷贝构造函数"><a class="markdownIt-Anchor" href="#3复制拷贝构造函数"></a> 3.复制（拷贝）构造函数</h2>
<p><strong>一. 什么是拷贝构造函数</strong><br />
首先对于普通类型的对象来说，它们之间的复制是很简单的，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  <span class="type">int</span> a = <span class="number">100</span>;  </span><br><span class="line"><span class="number">1.</span>  <span class="type">int</span> b = a;   </span><br></pre></td></tr></table></figure>
<p>而类对象与普通对象不同，类对象内部结构一般较为复杂，存在各种成员变量。<br />
下面看一个类对象拷贝的简单例子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CExample</span> &#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    　<span class="type">int</span> a;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">      <span class="comment">//构造函数  </span></span><br><span class="line">    　<span class="built_in">CExample</span>(<span class="type">int</span> b)  </span><br><span class="line">    　&#123; a = b;&#125;  </span><br><span class="line">  </span><br><span class="line">      <span class="comment">//一般函数  </span></span><br><span class="line">    　<span class="function"><span class="type">void</span> <span class="title">Show</span> <span class="params">()</span>  </span></span><br><span class="line"><span class="function">    　</span>&#123;  </span><br><span class="line">        cout&lt;&lt;a&lt;&lt;endl;  </span><br><span class="line">      &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    　<span class="function">CExample <span class="title">A</span><span class="params">(<span class="number">100</span>)</span></span>;  </span><br><span class="line">    　CExample B = A; <span class="comment">//注意这里的对象初始化要调用拷贝构造函数，而非赋值  </span></span><br><span class="line">    　 B.<span class="built_in">Show</span> ();  </span><br><span class="line">    　<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>运行程序，屏幕输出100。从以上代码的运行结果可以看出，系统为对象 B 分配了内存并完成了与对象 A 的复制过程。就类对象而言，相同类型的类对象是通过拷贝构造函数来完成整个复制过程的。</p>
<p>下面举例说明拷贝构造函数的工作过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CExample</span> &#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> a;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="comment">//构造函数  </span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="type">int</span> b)  </span><br><span class="line">    &#123; a = b;&#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//拷贝构造函数  </span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="type">const</span> CExample&amp; C)  </span><br><span class="line">    &#123;  </span><br><span class="line">        a = C.a;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//一般函数  </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span> <span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout&lt;&lt;a&lt;&lt;endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">CExample <span class="title">A</span><span class="params">(<span class="number">100</span>)</span></span>;  </span><br><span class="line">    CExample B = A; <span class="comment">// CExample B(A); 也是一样的  </span></span><br><span class="line">     B.<span class="built_in">Show</span> ();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>CExample(const CExample&amp; C)　就是我们自定义的拷贝构造函数。可见，拷贝构造函数是一种<strong>特殊的</strong> <strong>构造函数</strong>，函数的名称必须和类名称一致，它必须的一个参数是本类型的一个<strong>引用变量</strong> 。</p>
<blockquote>
<p>在代码中，<code>a = C.a;</code> 是拷贝构造函数 <code>CExample(const CExample&amp; C)</code> 中的一行代码。它用于将另一个 <code>CExample</code> 类型对象 <code>C</code> 的私有成员变量 <code>a</code> 的值复制给当前对象的私有成员变量 <code>a</code>。</p>
<p>这行代码的作用是将 <code>C</code> 对象的 <code>a</code> 的值赋给当前对象的 <code>a</code>。通过这样的赋值操作，当前对象的 <code>a</code> 成员变量将具有与 <code>C</code> 对象相同的值。</p>
<p>需要注意的是，由于拷贝构造函数是通过传递参数（引用）来初始化对象的，因此可以访问 <code>C</code> 对象的私有成员变量。并且拷贝构造函数通常用于创建新对象并复制另一个对象的状态。</p>
</blockquote>
<h3 id="构造函数和拷贝构造函数的区别"><a class="markdownIt-Anchor" href="#构造函数和拷贝构造函数的区别"></a> 构造函数和拷贝构造函数的区别</h3>
<p>构造函数和拷贝构造函数是 C++ 中的两种特殊成员函数，它们在对象创建和复制时起着不同的作用。</p>
<ol>
<li>
<p>构造函数（Constructor）：</p>
<ul>
<li>构造函数是类中的一种特殊函数，在创建对象时被调用。</li>
<li>构造函数用于初始化对象的状态和数据成员。</li>
<li>构造函数的名称与类名相同，没有返回类型（包括 void）。</li>
<li>可以重载构造函数，根据参数的类型和数量，可以有多个构造函数。</li>
<li>在对象创建时，会自动调用适当的构造函数。</li>
</ul>
</li>
<li>
<p>拷贝构造函数（Copy Constructor）：</p>
<ul>
<li>
<p>拷贝构造函数是一种特殊的构造函数，用于创建一个新对象并将现有对象的值复制到新对象中。</p>
</li>
<li>
<p>拷贝构造函数在以下情况下被调用：</p>
<ul>
<li>通过用已存在的对象初始化新对象时。</li>
<li>将对象作为函数参数按值传递时。</li>
<li>在函数中返回对象时以值的形式返回。</li>
</ul>
</li>
<li>
<p>拷贝构造函数的参数是另一个相同类型的对象的引用。</p>
</li>
<li>
<p>如果没有提供自定义的拷贝构造函数，编译器会生成一个默认的拷贝构造函数。</p>
</li>
</ul>
</li>
</ol>
<p>区别：</p>
<ul>
<li>构造函数用于创建对象并初始化其状态，而拷贝构造函数则用于创建新对象并复制现有对象的值。</li>
<li>构造函数没有特定的参数类型，而拷贝构造函数的参数类型是同一类的引用。</li>
<li>构造函数在对象创建时自动调用，而拷贝构造函数在特定情况下（如对象初始化、按值传递参数和以值返回对象）才会被调用。</li>
<li>如果没有提供自定义的拷贝构造函数，编译器会生成一个默认的拷贝构造函数，但对于构造函数没有默认的实现。</li>
<li>通过适当地组合构造函数和拷贝构造函数，可以实现对象的初始化和复制操作。</li>
</ul>
<h2 id="41类型转换构造函数"><a class="markdownIt-Anchor" href="#41类型转换构造函数"></a> 4.1类型转换构造函数</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    <span class="built_in">Complex</span>( <span class="type">int</span> i) &#123;<span class="comment">//类型转换构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;IntConstructor calledn &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    real = i; imag = 0;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">Complex(double r,double i) &#123;real = r; imag = i;&#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">int main ()</span></span><br><span class="line"><span class="string">&#123;Complexc1(7,8);</span></span><br><span class="line"><span class="string">Complexc2 = 12;</span></span><br><span class="line"><span class="string">c1 = 9; // 9被自动转换成一个临时complex对象</span></span><br><span class="line"><span class="string">c1.imag &lt;&lt; endlcout &lt;&lt; c1.real &lt;&lt;endl;</span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>编译器会把9转换为一个临时对象，再把这个对象的值赋给c1。而不是把9转换为c1</p>
<h2 id="42-析构函数"><a class="markdownIt-Anchor" href="#42-析构函数"></a> 4.2 析构函数</h2>
<p>析构函数（Destructor）是一种特殊的类成员函数，它在对象生命周期结束时自动被调用，用于进行对象的清理工作和资源释放。</p>
<p>析构函数执行的时机是在以下情况下：</p>
<ol>
<li>当对象的作用域结束时，比如一个局部对象在离开其定义的作用域时，该对象的析构函数会被调用。</li>
<li>当对象以动态方式分配内存，通过 <code>new</code> 运算符创建时，需要手动使用 <code>delete</code> 运算符释放内存时，会显式调用对象的析构函数。</li>
<li>对象被销毁时，比如当一个对象是另一个对象的成员变量，而该容器对象被销毁时，包含的成员对象的析构函数会被调用。</li>
<li>对象从容器中移除或销毁时，比如当一个对象从容器（如数组、链表等）中删除或销毁时，被删除或销毁的对象的析构函数将被调用。</li>
</ol>
<p>需要注意的是：</p>
<ul>
<li>如果没有显式定义析构函数，编译器会生成默认的析构函数，它执行对象的默认清理操作。</li>
<li>析构函数不接受任何参数，且没有返回值。</li>
<li>在对象的析构函数中，可以释放在对象生命周期中分配的资源，例如释放动态分配的内存、关闭文件或释放其他外部资源。</li>
</ul>
<p>总之，对象的析构函数在对象生命周期结束时自动被调用，用于清理对象的资源和执行必要的清理操作。</p>
<blockquote>
<p>使用new创建的话需要手动delete吗？不会自动执行析构函数吗?</p>
</blockquote>
<p>是的，当你使用 <code>new</code> 运算符动态创建对象时，需要手动使用 <code>delete</code> 运算符来释放对象及其占用的内存。因为动态创建的对象不会自动执行析构函数和释放内存。</p>
<p>当使用 <code>new</code> 创建对象时，它会调用对象的构造函数进行初始化，但不会自动调用析构函数来销毁对象。同样，使用 <code>delete</code> 销毁对象时，它会调用对象的析构函数来清理资源并释放内存。</p>
<p>以下是一个示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class Ctest&#123;</span><br><span class="line">    pubilc:</span><br><span class="line">    ~<span class="built_in">Ctest</span>() &#123;cout&lt;&lt;<span class="string">&quot;destructor called&quot;</span> &lt;&lt;endl ; &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">ctest * pTest;</span><br><span class="line">pTest = <span class="keyword">new</span> Ctest;<span class="comment">//构造函数调用</span></span><br><span class="line"><span class="keyword">delete</span> pTest;/析构函数调用</span><br><span class="line">----------------------------------------</span><br><span class="line">pTest = <span class="keyword">new</span> Ctest[<span class="number">3</span>];<span class="comment">//构造函数调用3次</span></span><br><span class="line"><span class="keyword">delete</span> [] pTest;/析构函数调用<span class="number">3</span>次</span><br></pre></td></tr></table></figure>
<blockquote>
<p>✨若new-—个对象数组,那么用delete释放时应该写[ ].否则只delete一个对象(调用一次析构函数)</p>
</blockquote>
<blockquote>
<p>需要手动delete操作的原理是什么？</p>
</blockquote>
<p>使用 <code>new</code> 创建对象时，内存会在堆（Heap）上进行分配，而不是栈（Stack）。在堆上分配的内存不会自动被释放，需要手动释放。</p>
<p>原因如下：</p>
<ol>
<li>
<p>自由存储区域（Heap）和栈（Stack）的管理机制不同：</p>
<ul>
<li>栈是由编译器自动管理的一块内存区域，用于存储局部变量和函数调用的上下文。栈的分配和释放是由编译器自动完成的，且遵循先进后出的原则。</li>
<li>堆是由开发者手动管理的一块内存区域，用于存储动态分配的对象。堆上的内存分配和释放需要显式地由开发者指定，以确保更灵活和精确的控制。</li>
</ul>
</li>
<li>
<p><code>new</code> 运算符返回的是指向对象的指针：</p>
<ul>
<li>使用 <code>new</code> 创建对象时，它会在堆上分配一块内存，并调用对象的构造函数进行初始化。然后，<code>new</code> 运算符会返回指向分配对象的指针。</li>
<li>由于返回的是指针，编译器无法推断何时应该释放对应的内存区域，因此需要开发者手动调用 <code>delete</code> 运算符来显式释放内存。</li>
</ul>
</li>
<li>
<p>C++ 的设计哲学：</p>
<ul>
<li>C++ 的设计理念之一是“你所使用的资源就是你所负责的资源”。这意味着程序员有更多的控制权和灵活性，可以精确地控制对象的生命周期和内存的分配和释放。</li>
</ul>
</li>
</ol>
<p>总结起来，<code>new</code> 创建对象需要手动调用 <code>delete</code> 运算符释放内存，是因为堆上分配的内存不会自动释放，而 C++ 的设计使得开发者能够更灵活地管理对象的生命周期和内存的分配。这样可以避免不必要的内存消耗，并提供更高的灵活性和控制性。</p>
<h3 id="析构函数在对象作为函数返回值返回后被调用"><a class="markdownIt-Anchor" href="#析构函数在对象作为函数返回值返回后被调用"></a> 析构函数在对象作为函数返回值返回后被调用</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMyclass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">CMyclass</span>() &#123; cout &lt;&lt;<span class="string">&quot;destructor&quot;</span> &lt;endl ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">CMyclass obj;</span><br><span class="line"><span class="function">CMyclass <span class="title">fun</span> <span class="params">(CMyclass sobj )</span> </span>&#123;<span class="comment">//参数对象消亡也会导致析</span></span><br><span class="line">                                <span class="comment">//构函数被调用</span></span><br><span class="line">    <span class="keyword">return</span> sobj;<span class="comment">//函数调用返回时生成临时对象返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    obj = <span class="built_in">fun</span> (obj);<span class="comment">//函数调用的返回值（临时对象）被</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;<span class="comment">//用过后,该临时对象析构函数被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出:</p>
<p>destructor<br />
destructor<br />
destructor</p>
</blockquote>
<h2 id="5-构造函数析构函数调用时机"><a class="markdownIt-Anchor" href="#5-构造函数析构函数调用时机"></a> 5. 构造函数析构函数调用时机</h2>
<p>复制构造函数在不同编译器下的表现</p>
<h1 id="第三章-类和对象提高"><a class="markdownIt-Anchor" href="#第三章-类和对象提高"></a> 第三章 类和对象提高</h1>
<h2 id="1-this指针"><a class="markdownIt-Anchor" href="#1-this指针"></a> 1. this指针</h2>
<p>this指针作用</p>
<blockquote>
<p><code>非静态</code>成员函数中可以直接使用this来代表指向该函数作用的对象的指针。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">double</span> real, imag;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;cout &lt;&lt; real &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; imag ; &#125;</span><br><span class="line">        <span class="built_in">Complex</span>(<span class="type">double</span> r,<span class="type">double</span> i):<span class="built_in">real</span>(r),<span class="built_in">imag</span>(i)</span><br><span class="line">        &#123;   &#125;</span><br><span class="line">        <span class="function">Complex <span class="title">AddOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;real ++;<span class="comment">//等价于real ++;</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">Print</span>();/等价于 Print</span><br><span class="line">            <span class="keyword">return</span>*<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span>,<span class="title">c2</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    c2 =c1.<span class="built_in">AddOne</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>this指针和静态成员函数<br />
静态成员函数中不能使用 this 指针!<br />
因为静态成员函数并不具体作用于某个对象!<br />
因此，静态成员函数的真实的参数的个数，就是程序中写出的参数个数!</p>
</blockquote>
<p><strong>1. this</strong> <strong>指针的用处</strong> <strong>:</strong></p>
<p>一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。 　　例如，调用date.SetMonth(9) &lt;===&gt; SetMonth(&amp;date, 9)，this帮助完成了这一转换 .</p>
<p><strong>2. this</strong> <strong>指针的使用</strong> <strong>:</strong></p>
<p>一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；另外一种情况是当参数与成员变量名相同时，如this-&gt;n = n （不能写成n = n）。</p>
<p><strong>3. this</strong> <strong>指针程序示例</strong> <strong>:</strong></p>
<p>this指针存在于类的成员函数中,指向被调用函数所在的类实例的地址。 　　根据以下程序来说明this指针</p>
<p>#include</p>
<p>class Point 　　{ 　　int x, y;</p>
<p>public:</p>
<p>Point(int a, int b) { x=a; y=b;}</p>
<p>void MovePoint( int a, int b){ x+=a; y+=b;}</p>
<p>void print(){ cout&lt;&lt;“x=”&lt;</p>
<p>};</p>
<p>void main( ) 　　{</p>
<p>Point point1( 10,10);</p>
<p>point1.MovePoint(2,2);</p>
<p>point1.print( );</p>
<p>}</p>
<p>当对象point1调用MovePoint(2,2)函数时，即将point1对象的地址传递给了this指针。</p>
<p>MovePoint函数的原型应该是 void MovePoint( Point *this, int a, int b);第一个参数是指向该类对象的一个指针，我们在定义成员函数时没看见是因为这个参数在类中是隐含的。这样point1的地址传递给了this，所以在MovePoint函数中便显式的写成：</p>
<p>void MovePoint(int a, int b) { this-&gt;x +=a; this-&gt; y+= b;} 　　即可以知道，point1调用该函数后，也就是point1的数据成员被调用并更新了值。 　　即该函数过程可写成 point1.x+= a; point1. y + = b;</p>
<p><strong>4.</strong> <strong>关于</strong> <strong>this</strong> <strong>指针的一个经典回答</strong> <strong>:</strong></p>
<p>当你进入一个房子后，</p>
<p>你可以看见桌子、椅子、地板等，</p>
<p>但是房子你是看不到全貌了。</p>
<p>对于一个类的实例来说，</p>
<p>你可以看到它的成员函数、成员变量，</p>
<p>但是实例本身呢？</p>
<p>this是一个指针，它时时刻刻指向你这个实例本身</p>
<p></p>
<p><strong>5.</strong> <strong>类的</strong> <strong>this</strong> <strong>指针有以下特点：</strong>****</p>
<p><strong>（</strong> <strong>1</strong> <strong>）</strong> <strong>this</strong> <strong>只能在成员函数中使用。</strong>****</p>
<p>全局函数、静态函数都不能使用this.</p>
<p>实际上，成员函数默认第一个参数为T * const this。</p>
<p>如：</p>
<p>class A</p>
<p>{</p>
<p>public:</p>
<p>int func(int p)</p>
<p>{</p>
<p>}</p>
<p>};</p>
<p><strong>其中，</strong> <strong>func</strong> <strong>的原型在编译器看来应该是：</strong>****</p>
<p>** int func(A * const this,int p);**</p>
<p><strong>（</strong> <strong>2</strong> <strong>）由此可见，</strong> <strong>this</strong> <strong>在成员函数的开始前构造，在成员函数的结束后清除。</strong>****</p>
<p>这个生命周期同任何一个函数的参数是一样的，没有任何区别。</p>
<p>当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：</p>
<p>A a;</p>
<p>a.func(10);</p>
<p>此处，编译器将会编译成：</p>
<p>A::func(&amp;a,10);</p>
<p>看起来和静态函数没差别，对吗？<strong>不过，区别还是有的。编译器通常会对****this</strong> <strong>指针做一些优化，</strong> 因此，this指针的传递效率比较高–如VC通常是通过ecx寄存器传递this参数的。</p>
<p><strong>（</strong> <strong>3</strong> <strong>）几个</strong> <strong>this</strong> <strong>指针的易混问题。</strong>****</p>
<p><strong>A. this</strong> <strong>指针是什么时候创建的？</strong>****</p>
<p>this在成员函数的开始执行前构造，在成员的执行结束后清除。</p>
<p>但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用 TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式 创建对象的话，在堆里分配内存，new操作符通过eax返回分配 的地址，然后设置给指针变量。之后去调 用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面怎么处理请 看上面的回答。</p>
<p><strong>B. this</strong> <strong>指针存放在何处？堆、栈、全局变量，还是其他？</strong>****</p>
<p>this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级 别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内 存中，它们并不是和高级语言变量对应的。</p>
<p><strong>C. this</strong> <strong>指针是如何传递类中的函数的？</strong> 绑定？还是在函数参数的首参数就是this指针？那么，this指针 又是如何找到“类实例后函数的”？</p>
<p>大多数编译器通过ecx寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。</p>
<p>在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的。</p>
<p><strong>D. this</strong> <strong>指针是如何访问类中的变量的？</strong>****</p>
<p>如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，就很容易理解这个问题了。</p>
<p></p>
<p><strong>在</strong> <strong>C++</strong> <strong>中</strong> <strong>,</strong> <strong>类和结构是只有一个区别的：类的成员默认是</strong> <strong>private</strong> <strong>，而结构是</strong> <strong>public</strong> <strong>。</strong>****</p>
<p><strong>this</strong> <strong>是类的指针，如果换成结构，那</strong> <strong>this</strong> <strong>就是结构的指针了。</strong>****</p>
<p></p>
<p><strong>E.</strong> <strong>我们只有获得一个对象后，才能通过对象使用</strong> <strong>this</strong> <strong>指针。</strong> 如果我们知道一个对象this指针的位置，可以直接使用吗？</p>
<p>this指针只有在成员函数中才有定义。因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&amp;this获得），也可以直接使用它。</p>
<p><strong>F.</strong> <strong>每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</strong></p>
<p>普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译器能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。</p>
<h2 id="2静态成员变量"><a class="markdownIt-Anchor" href="#2静态成员变量"></a> 2.静态成员变量</h2>
<blockquote>
<p>普通成员变量每个对象有各自的一份，而静态成员变量一共就一份．<code>为所有对象共享</code>。</p>
<p>普通成员函数必须具体作用于某个对象，而静态成员函数并<code>不具体作用于某个对象</code>。</p>
<p>因此静态成员<code>不需要通过对象</code>就能访问。</p>
</blockquote>
<p>如何访问静态成员</p>
<ol>
<li>类名::成员名<br />
CRectangle::PrintTotal();</li>
<li>对象名.成员名<br />
CRectangle r; r.PrintTotal();</li>
<li>指针-&gt;成员名<br />
CRectangle * p = &amp;r; p-&gt;PrintTotal();</li>
<li>引用.成员名<br />
CRectangle &amp;ref = r int n = ref nTotalNuimber:</li>
</ol>
<blockquote>
<p><strong>静态成员变量本质上是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在。</strong></p>
<p><strong>静态成员函数本质上是全局函数。</strong></p>
<p><strong>设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解。</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CRectanglel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:<span class="type">int</span> w, h,</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> nTotalArea;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> nTotalNumber,</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">CRectangle</span>( <span class="type">int</span> w_,<span class="type">int</span> h_);</span><br><span class="line">        ~<span class="built_in">CRectangle</span>();</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">PrintTotal</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">CRectangle::<span class="built_in">CRectangle</span>(<span class="type">int</span> w_.<span class="type">int</span> h_)</span><br><span class="line">&#123;</span><br><span class="line">    W=W_;h =h_;</span><br><span class="line">    nTotalNumber ++;</span><br><span class="line">    nTotalArea +=w * h;</span><br><span class="line">&#125;</span><br><span class="line">CRectangle:~<span class="built_in">CRectangle</span>()</span><br><span class="line">&#123;</span><br><span class="line">    nTotalNumber --;</span><br><span class="line">    nTotalArea -= w * h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CRectangle::PrintTotal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; nTotalNumber &lt;&lt; <span class="string">&quot;,&quot;</span>&lt;&lt;nTotalArea&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态成员变量的声明和初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> CRectangle::nTotalNumber = <span class="number">0</span>;  </span><br><span class="line"><span class="type">int</span> CRectangle:nTotalArea = <span class="number">0</span>;<span class="comment">//见下</span></span><br></pre></td></tr></table></figure>
<p><strong>//必须在定义类的文件中对静态成员变量进行一次说明/或初始化。否则编译能通过，链接不能通过。</strong></p>
<blockquote>
<p>?静态成员函数能访问全局变量吗？静态全局函数能访问全局变量吗？</p>
</blockquote>
<blockquote>
<p>在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数(会访问非静态成员变量)。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CRectangle::PrintTotal</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt;w &lt;&lt;<span class="string">&quot;,&quot;</span> &lt;&lt;nTotalNumber &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt;nTotalArea &lt;&lt;endl;<span class="comment">//wrong</span></span><br><span class="line">&#125;</span><br><span class="line">CRetangle:<span class="built_in">PrintTotal</span>();/解释不通，w到底是属于那个对象的?</span><br></pre></td></tr></table></figure>
<p>✨<strong>由于复制构造函数会造成临时对象的生成，同时不经过复制构造函数，只在变量作用域结束时经过析构函数，会造成错误的输出。</strong></p>
<p><em><strong>eg.</strong></em> 在使用CRectangle类时，有时会调用复制构造函数生成临时的隐藏的CRectangle对象</p>
<blockquote>
<p>解决办法:为CRectangle类写一个复制构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;CRectangle :: <span class="built_in">CRectangle</span>(CRectangle &amp; r )</span><br><span class="line">&gt;&#123;</span><br><span class="line">  w=r.W:; h =r.h;</span><br><span class="line">  nTotfalNumber ++;</span><br><span class="line">  nTotalArea tw * h;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="3-成员对象和封闭类"><a class="markdownIt-Anchor" href="#3-成员对象和封闭类"></a> 3. 成员对象和封闭类</h2>
<blockquote>
<p>⛔ 封闭类构造函数和成员的构造函数？</p>
</blockquote>
<p>任何生成封闭类对象的语句，都要让编译器明白，对象中的成员对象,是如何初始化的。<br />
具体的做法就是:通过封闭类的构造函数的初始化列表。<br />
成员对象初始化列表中的参数可以是任意复杂的表达式，可以包括函数，变量，只要表达式中的函数或变量有定义就行。</p>
<h3 id="封闭类构造函数和析构函数的执行顺序"><a class="markdownIt-Anchor" href="#封闭类构造函数和析构函数的执行顺序"></a> 封闭类构造函数和析构函数的执行顺序</h3>
<ul>
<li>封闭类对象生成时，先执行所有对象成员的构造函数，然后才执行封闭类的构造函数。</li>
<li>对象成员的构造函数调用次序和对象成员在类中的说明次序一致与它们在成员初始化列表中出现的次序无关。</li>
<li>当封闭类的对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数。<strong>次序和构造函数的调用次序相反。</strong></li>
</ul>
<h2 id="4-常量对象-常量成员函数"><a class="markdownIt-Anchor" href="#4-常量对象-常量成员函数"></a> 4. 常量对象、常量成员函数</h2>
<h3 id="常量对象"><a class="markdownIt-Anchor" href="#常量对象"></a> 常量对象</h3>
<blockquote>
<p>如果不希望某个对象的值被改变，则定义该对象的时候可以在前面加const关键字。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> :</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetValue</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> Demo Obi: <span class="comment">// 常量对象</span></span><br></pre></td></tr></table></figure>
<h3 id="常量成员函数"><a class="markdownIt-Anchor" href="#常量成员函数"></a> 常量成员函数</h3>
<blockquote>
<p>在类的成员函数说明后面可以加<code>const</code>关键字，则该成员函数成为<code>常量成员函数</code>。<br />
常量成员函数执行期间<code>不应修改其所作用的对象因此，在常量成员函数中不能修改成员变量的值(</code>静态成员变量除外<code>)，也不能调用同类的非常量成员函数(</code>静态成员函数除外`)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> GetValue0) <span class="type">const</span>:</span><br></pre></td></tr></table></figure>
<blockquote>
<p>✨常量对象上面不会执行非常量成员函数，编译器不会分析常量对象调用的函数是否会修改对象的值，而是直接编译失败</p>
</blockquote>
<h3 id="常量成员函数的重载"><a class="markdownIt-Anchor" href="#常量成员函数的重载"></a> 常量成员函数的重载</h3>
<blockquote>
<p>两个成员函数，名字和参数表都一样，但是一个是const,一个不是，算重载。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> :</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">CTest</span>() &#123; n= <span class="number">1</span> ; &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> n ; &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">( <span class="keyword">return</span> <span class="number">2</span>*n ; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> main( &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> CTest objTestl;</span></span></span><br><span class="line"><span class="params"><span class="function">    CTest objTest2;</span></span></span><br><span class="line"><span class="params"><span class="function">    cout &lt;&lt; objTest <span class="number">1.</span>GetValue() &lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;objTest2.GetValue() ;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">return</span> O;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="常引用"><a class="markdownIt-Anchor" href="#常引用"></a> 常引用</h3>
<blockquote>
<p>✨对象作为函数的参数时，生成该参数需要调用复制构造函数，效率比较低。用指针作参数，代码又不好看，如何解决?</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以用对象的引用作为参数，如:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintfObj</span><span class="params">(Sample &amp; o)</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对象引用作为函数的参数有一定风险性，若函数中不小心修改了形参o，则实参也跟着变，这可能不是我们想要的。如何避免?</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以用对象的常引用作为参数，如:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintfObj</span><span class="params">( <span class="type">const</span> Sample &amp; Lo)</span></span>&#123;</span><br><span class="line">    ......<span class="comment">//这样函数中就能确保不会出现无意中更改o值的语句了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5友元"><a class="markdownIt-Anchor" href="#5友元"></a> 5.友元</h2>
<blockquote>
<p>⛔友元类之间的关系不能传递，不能继承。</p>
</blockquote>
<p>友元分为友元函数和友元类两种</p>
<ol>
<li>友元函数:一个类的友元函数可以访问该类的私有成员</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">    <span class="comment">// 类的定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ReturnType <span class="title">FunctionName</span><span class="params">(ParameterList)</span></span>; <span class="comment">// 友元函数的声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ReturnType <span class="title">FunctionName</span><span class="params">(ClassName::ParameterList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 友元函数的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在所在类中以 <code>friend ReturnType FunctionName(ParameterList); </code> 友元函数的声明的形式，声明的函数可以访问该类私有的成员变量；</p>
<ul>
<li><code>ClassName</code> 是要声明友元函数的类名。</li>
<li><code>ReturnType</code> 是友元函数的返回类型。</li>
<li><code>FunctionName</code> 是友元函数的名称。</li>
<li><code>ParameterList</code> 是友元函数的参数列表，可以包含类的对象或其他参数。</li>
</ul>
<p><em><strong>eg.</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CCar</span> ; <span class="comment">//提前声明 ccar类，以便后面的cDriver类使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDriver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">ModifyCar</span> <span class="params">( cCar * pCar)</span> </span>; <span class="comment">//改装汽车</span></span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCar</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">                <span class="type">int</span> price ;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">MostExpensiveCar</span><span class="params">( Ccar cars[l, <span class="type">int</span> total)</span></span>;<span class="comment">//声明友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> CDriver: :<span class="built_in">ModifyCar</span> (ccar * pCar) ;<span class="comment">//声明友元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> CDriver:: <span class="built_in">ModifyCar</span> ( CCar * pCar)</span><br><span class="line">&#123;</span><br><span class="line">    pCar-&gt;price += <span class="number">1000</span>; <span class="comment">//汽车改装后价值增加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MostExpensiveCar</span> <span class="params">( ccar cars[ ] ,<span class="type">int</span> total)</span><span class="comment">//求最贵汽车的价格</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmpMax = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = o; i &lt; total; ++i )</span><br><span class="line">        <span class="keyword">if</span>( cars[i].price &gt; tmpMax)</span><br><span class="line">            tmpMax = cars[i].price;</span><br><span class="line">    <span class="keyword">return</span> tmpMax ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>友元类:如果A是B的友元类，那么A的成员函数可以访问B的私有成员</li>
</ol>
<p>友元类是指一个类可以访问另一个类的私有成员和保护成员。当一个类被声明为另一个类的友元类时，它可以在其成员函数中直接访问该类的私有成员和保护成员。</p>
<p>友元类的声明方式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">    <span class="comment">// 类的定义</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">FriendClassName</span>; <span class="comment">// 友元类的声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>ClassName</code> 是要声明友元类的类名。</li>
<li><code>FriendClassName</code> 是友元类的名称。</li>
</ul>
<p>通过将一个类声明为另一个类的友元类，被声明的类就能够访问友元类中的所有成员，包括私有成员和保护成员。</p>
<p><em><strong>eg.</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CCar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> price ;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">CDriver</span>; l/声明cDriver为友元类</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDriver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CCar myCar;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">ModifyCar</span> <span class="params">()</span></span>&#123;<span class="comment">//改装汽车</span></span><br><span class="line">            myCar.price += <span class="number">1000</span>; <span class="comment">//因cDriver是ccar的友元类，</span></span><br><span class="line">                                <span class="comment">//故此处可以访问其私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">int</span> main&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中定义了两个类 <code>CCar</code> 和 <code>CDriver</code>，并且在 <code>CCar</code> 类中声明了 <code>CDriver</code> 为友元类。这意味着 <code>CDriver</code> 类可以访问 <code>CCar</code> 类的私有成员和保护成员。</p>
<p>在 <code>CDriver</code> 类中，有一个 <code>CCar</code> 类型的对象 <code>myCar</code>。在 <code>ModifyCar</code> 成员函数中，它可以直接访问 <code>myCar</code> 的私有成员 <code>price</code>。因为 <code>CDriver</code> 是 <code>CCar</code> 的友元类，所以可以在 <code>ModifyCar</code> 函数中修改 <code>myCar</code> 的私有成员。</p>
<h1 id="第四章-运算符重载"><a class="markdownIt-Anchor" href="#第四章-运算符重载"></a> 第四章 运算符重载</h1>
<h2 id="1-运算符重载的基本概念"><a class="markdownIt-Anchor" href="#1-运算符重载的基本概念"></a> 1. 运算符重载的基本概念</h2>
<p>运算符重载的目的是:扩展C++中提供的运算符的适用范围，使之能作用于对象。</p>
<ul>
<li>重载为成员函数时，参数个数为运算符目数减一。</li>
<li>重载为普通函数时，参数个数为运算符目数。</li>
</ul>
<p><em><strong>eg</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real ,imag ;</span><br><span class="line">    <span class="built_in">Cormplex</span>( <span class="type">double</span> r = <span class="number">0.0</span>,<span class="type">double</span> i= <span class="number">0.0</span> ) : <span class="built_in">real</span>(r),<span class="built_in">imag</span>(i)&#123; &#125;</span><br><span class="line">    complex <span class="keyword">operator</span>-(<span class="type">const</span> complex &amp;c) ;</span><br><span class="line">&#125;;</span><br><span class="line">Complex <span class="keyword">operator</span>+( <span class="type">const</span> Complex &amp; a, <span class="type">const</span> Complex &amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>( a.real+b.real,a.imag+b.imag);<span class="comment">//返回一个临时对象</span></span><br><span class="line">&#125;</span><br><span class="line">Complex Complex :: <span class="keyword">operator</span>- (<span class="type">const</span> Complex &amp; c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span> (real - c .real, imag-c.imag); <span class="comment">//返回一个临时对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">a</span> <span class="params">(<span class="number">4</span>,<span class="number">4</span>)</span>,<span class="title">b</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span> ,c</span>;</span><br><span class="line">    c= a + b; <span class="comment">//等价于c=operator+(a,b) ;</span></span><br><span class="line">    cout&lt;&lt;c.real &lt;&lt;<span class="string">&quot;, &quot;</span> &lt;&lt;c.imag &lt;&lt;end</span><br><span class="line">    cout &lt;&lt;, (a-b).real &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt;(a-b) .imag &lt;&lt; endl;<span class="comment">//a-b等价于a. operator-(b)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">c= a + b ;等价于c=<span class="keyword">operator</span>+(a, b) ;</span><br><span class="line">a-b   等价于a.<span class="keyword">operator</span>-(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-赋值运算符的重载"><a class="markdownIt-Anchor" href="#2-赋值运算符的重载"></a> 2. 赋值运算符的重载</h2>
<p>在C++中，赋值运算符“=”只能重载为成员函数。</p>
<h3 id="浅拷贝和深拷贝"><a class="markdownIt-Anchor" href="#浅拷贝和深拷贝"></a> 浅拷贝和深拷贝</h3>
<h3 id="对-operator-返回值类型的讨论"><a class="markdownIt-Anchor" href="#对-operator-返回值类型的讨论"></a> 对 operator = 返回值类型的讨论</h3>
<p>void 好不好?<br />
String 好不好?<br />
为什么是 String&amp;<br />
<strong>对运算符进行重载的时候，好的风格是应该尽量保留运算符原本的特性</strong><br />
考虑:a=b=c;<br />
和<br />
(a=b)=c;//会修改a的值</p>
<blockquote>
<p>qustion:赋值运算符的返回值是等号左边的引用，a=b的返回值是a的引用？</p>
</blockquote>
<h1 id="第五章-继承"><a class="markdownIt-Anchor" href="#第五章-继承"></a> 第五章 继承</h1>
<h2 id="1-继承和派生的基本概念"><a class="markdownIt-Anchor" href="#1-继承和派生的基本概念"></a> 1. 继承和派生的基本概念</h2>
<ul>
<li>在派生类的各个成员函数中，不能访问基类中的private成员。</li>
</ul>
<h3 id="派生类的写法"><a class="markdownIt-Anchor" href="#派生类的写法"></a> 派生类的写法</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名: <span class="keyword">public</span> 基类名</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="派生类对象的内存空间"><a class="markdownIt-Anchor" href="#派生类对象的内存空间"></a> 派生类对象的内存空间</h3>
<p>派生类对象的体积，等于基类对象的体积，再加上派生类对象自己的成员变量的体积。<strong>在派生类对象中，包含着基类对象</strong>，而且基类对象的存储位置位于派生类对象新增的成员变量<strong>之前</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">classCBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v1, v2;</span><br><span class="line">&#125;</span><br><span class="line">classCDerived:<span class="keyword">public</span> CBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v3 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/146a128599714cf3a3ee8da881eb1f77~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=735&amp;h=308&amp;s=68248&amp;e=png&amp;b=fbf9fb" alt="1695133002079.png" /></p>
<h2 id="2-继承关系和复合关系"><a class="markdownIt-Anchor" href="#2-继承关系和复合关系"></a> 2. 继承关系和复合关系</h2>
<p>继承：<strong>“是”</strong> 关系。</p>
<ul>
<li>基类 A，B是基类A的派生类</li>
<li>逻辑上要求:“一个B对象也是一个A对象”</li>
</ul>
<p>复合:“<strong>有</strong>”关系</p>
<ul>
<li>类C中“有”成员变量k，k是类D的对象，则C和D是复合关系</li>
<li>一般逻辑上要求:“D对象是C对象的固有属性或组成部</li>
</ul>
<h3 id="复合关系的使用"><a class="markdownIt-Anchor" href="#复合关系的使用"></a> 复合关系的使用</h3>
<p>正确的写法:<br />
为“狗”类设一个“业主”类的对象指针;<br />
为“业主”类设一个“狗”类的对象指针数组。</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e97ea2e9c79442ebc2af3000da9f1e0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=912&h=399&s=250734&e=png&b=f9f7f9" alt="1695184236782.png" width="70%" />
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMaster</span>: <span class="comment">//CMaster必须提前声明，不能先写CMaster类后写Cdog类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDog</span> </span><br><span class="line">&#123;</span><br><span class="line">    CMaster* pm;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMaster</span> </span><br><span class="line">&#123;</span><br><span class="line">    CDog*dogs[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3覆盖和保护成员"><a class="markdownIt-Anchor" href="#3覆盖和保护成员"></a> 3.覆盖和保护成员</h2>
<h3 id="覆盖"><a class="markdownIt-Anchor" href="#覆盖"></a> 覆盖</h3>
<p>派生类可以定义一个和基类成员同名的成员，这叫覆盖。在派生类中访问这类成员时，<strong>缺省</strong>的情况是访问派生类中定义的成员。要在派生类中访问由基类定义的同名成员时，要使用作用域符号<code>::</code>。</p>
<h3 id="基类和派生类有同名成员的情况"><a class="markdownIt-Anchor" href="#基类和派生类有同名成员的情况"></a> 基类和派生类有同名成员的情况:</h3>
<p><em><strong>eg</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span> :<span class="keyword">public</span> base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">access</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">derived::access</span><span class="params">()</span></span>&#123;</span><br><span class="line">    j = <span class="number">5</span>; <span class="comment">//error</span></span><br><span class="line">    i= <span class="number">5</span>; <span class="comment">//引用的是派生类的i </span></span><br><span class="line">    base::i = <span class="number">5</span>;<span class="comment">//引用的是基类的 i</span></span><br><span class="line">    <span class="built_in">func</span>(); <span class="comment">//派生类的</span></span><br><span class="line">    base::func0;<span class="comment">//基类的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般来说，基类和派生类不定义同名成员变量。</p>
</blockquote>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b90c71bb63c44bfbb2d77c4ea8ccfcc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=555&h=380&s=78400&e=png&b=ffffff" alt="1695202815288.png" width="50%" />
<p><em><strong>eg:存储空间</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        value = newValue;  <span class="comment">// 可以直接访问和赋值基类的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;  <span class="comment">// 可以直接访问基类的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，<code>Derived</code> 派生类继承了 <code>Base</code> 基类的成员变量 <code>value</code>。派生类中的函数 <code>setValue()</code> 和 <code>getValue()</code> 直接对 <code>value</code> 进行赋值和返回操作，而不需要重新声明 <code>value</code>。</p>
<p>因此，基类的成员变量同样属于派生类，并且可以在派生类中进行直接访问和操作。<br />
派生类的内存空间包含了基类的成员和派生类自己的成员。</p>
<p>当创建一个派生类的对象时，内存空间会按照以下方式进行分配：</p>
<ol>
<li>首先，分配基类的内存空间。这包括基类中的所有非静态成员变量和成员函数。</li>
<li>接下来，分配派生类的附加内存空间。这包括派生类中新增加的非静态成员变量和成员函数。</li>
</ol>
<p>派生类的内存布局可以看作是基类和派生类内存布局的组合。</p>
<p>在派生类中，可以通过派生类对象或指针访问基类的成员，因为基类的成员被继承到派生类中。同时，派生类还可以添加自己的成员，以实现其特定的功能。</p>
<p>需要注意的是，派生类对象的大小取决于基类和派生类成员的总和，以及可能的内存对齐要求。</p>
<p>总结：派生类的内存空间包括了基类的成员和派生类自己的成员。派生类的内存布局可以看作是基类和派生类内存布局的组合。通过派生类对象或指针，可以访问基类的成员和派生类自己的成员。</p>
<h3 id="private-protected和public的范围"><a class="markdownIt-Anchor" href="#private-protected和public的范围"></a> private、protected和public的范围</h3>
<p>基类的private成员: 可以被下列函数访问</p>
<ul>
<li>基类的成员函数</li>
<li>基类的友员函数</li>
</ul>
<p>基类的public成员: 可以被下列函数访问</p>
<ul>
<li>基类的成员函数</li>
<li>基类的友员函数</li>
<li>派生类的成员函数</li>
<li>派生类的友员函数</li>
<li>其他的函数</li>
</ul>
<p>基类的protected成员:可以被下列函数访问</p>
<ul>
<li>基类的成员函数</li>
<li>基类的友员函数</li>
<li>派生类的成员函数可以访问<strong>当前</strong>对象的基类的保护成员</li>
</ul>
<h2 id="4-派生类的构造函数"><a class="markdownIt-Anchor" href="#4-派生类的构造函数"></a> 4. 派生类的构造函数</h2>
<ul>
<li><strong>在创建派生类的对象时，需要调用基类的构造函数:初始化派生类对象中从基类继承的成员。在执行一个派生类的构造函数之前，总是先执行基类的构造函数。</strong></li>
<li>调用基类构造函数的两种方式
<ul>
<li>显式方式:在派生类的构造函数中，为基类的构造函数提供参数.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">derived::<span class="built_in">derived</span>(arg_derived-list<span class="comment">/* 参数列表*/</span>):<span class="built_in">base</span>(arg_base-list<span class="comment">/* 参数列表*/</span>)<span class="comment">/* 派生类成员初始化列表 */</span>&#123; </span><br><span class="line">    <span class="comment">// 派生类构造函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>隐式方式:在派生类的构造函数中，省略基类构造函数时，派生类的构造函数则自动调用基类的默认构造函数<code>(无参构造函数)</code>.</li>
<li></li>
</ul>
</li>
<li><strong>派生类的析构函数被执行时，执行完派生类的析构函数后，自动调用基类的析构函数。</strong></li>
</ul>
<blockquote>
<p>先构造后析构</p>
</blockquote>
<h3 id="封闭派生类对象的构造函数的执行顺序"><a class="markdownIt-Anchor" href="#封闭派生类对象的构造函数的执行顺序"></a> 封闭派生类对象的构造函数的执行顺序</h3>
<p><strong>在创建派生类的对象时:</strong></p>
<ol>
<li>
<p>先执行基类的构造函数，用以初始化派<br />
生类对象中从基类继承的成员;</p>
</li>
<li>
<p>再执行成员对象类的构造函数，用以初<br />
始化派生类对象中成员对象。</p>
</li>
<li>
<p>最后执行派生类自己的构造函数</p>
</li>
</ol>
<p><strong>在派生类对象消亡时:</strong></p>
<ol>
<li>
<p>先执行派生类自己的析构函数</p>
</li>
<li>
<p>再依次执行各成员对象类的析构函数</p>
</li>
<li>
<p>最后执行基类的析构函数析构函数的调用顺序与构造函数的调用顺序相反。</p>
</li>
</ol>
<h2 id="public继承的赋值兼容规则"><a class="markdownIt-Anchor" href="#public继承的赋值兼容规则"></a> public继承的赋值兼容规则</h2>
<h3 id="public继承的赋值兼容规则-2"><a class="markdownIt-Anchor" href="#public继承的赋值兼容规则-2"></a> public继承的赋值兼容规则</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span> : <span class="keyword">public</span> base: &#123;&#125;;</span><br><span class="line">base b;</span><br><span class="line">derived d:</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>派生类的对象可以赋值给基类对象(不能把基类对象赋值给派生类对象，派生类可以对基类兼容）<br />
b = d;</p>
</li>
<li>
<p>派生类对象可以初始化基类引用（可以认为基类的引用实际上引用了派生类对象多包含的基类的对象）<br />
base &amp; br = d;</p>
</li>
<li>
<p>派生类对象的地址可以赋值给基类指针（基类的指针指向一个派生类的对象所包含的基类对象，所包含的基类对象位于派生类对象的存储空间最前面，即基类对象的起始地址就是派生类对象的起始地址）<br />
base* pb=&amp; d;</p>
</li>
</ol>
<blockquote>
<p>如果派生方式是private或protected，则上述三条不可行。</p>
</blockquote>
<h3 id="直接基类和间接基类"><a class="markdownIt-Anchor" href="#直接基类和间接基类"></a> 直接基类和间接基类</h3>
<ul>
<li>
<p>在声明派生类时，只需要列出它的直接基类</p>
</li>
<li>
<p>派生类沿着类的层次自动向上继承它的间接基类</p>
</li>
<li>
<p>派生类的成员包括</p>
<ul>
<li>派生类自己定义的成员</li>
<li>直接基类中的所有成员</li>
<li>所有间接基类的全部成员</li>
</ul>
</li>
</ul>
<blockquote>
<p>派生类初始化时只需要指明直接基类，间接基类由直接基类初始化（递归初始化）</p>
</blockquote>
<h3 id="多层类嵌套的构造与析构"><a class="markdownIt-Anchor" href="#多层类嵌套的构造与析构"></a> 多层类嵌套的构造与析构</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Base  constructed</span><br><span class="line">Derived constructed</span><br><span class="line">More Derived constructed</span><br><span class="line">More Derived destructed</span><br><span class="line">Derived destructed</span><br><span class="line">Base <span class="number">4</span> destructed</span><br></pre></td></tr></table></figure>
<h1 id="第六章-多态"><a class="markdownIt-Anchor" href="#第六章-多态"></a> 第六章 多态</h1>
<h2 id="1-虚函数和多态的基本概念"><a class="markdownIt-Anchor" href="#1-虚函数和多态的基本概念"></a> 1. 虚函数和多态的基本概念</h2>
<h3 id="虚函数"><a class="markdownIt-Anchor" href="#虚函数"></a> 虚函数</h3>
<p>虚函数是C++中实现多态的一种机制。当在基类中声明一个函数为虚函数时，派生类可以重写该虚函数，并根据自己的需要提供专门的实现。在运行时，根据对象的实际类型来调用相应的函数。</p>
<p>在C++中，使用关键字<code>virtual</code>来声明虚函数。基类中的虚函数可以通过在函数声明前加上<code>virtual</code>关键字来定义，</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">base::get</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>virtual 关键字只用在类定义里的函数声明中写函数体时不用。</li>
<li>构造函数和静态成员函数不能是虚函数</li>
</ul>
<p>派生类可以重写基类的虚函数，通过相同的函数名和参数列表来覆盖基类的虚函数。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 派生类对虚函数的重写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意到，在派生类中重写虚函数时，可以使用<code>override</code>关键字来显式标记，以提高代码的可读性。</p>
<blockquote>
<p><code>override</code>关键字是C++11标准引入的一个特性，用于显式地表示派生类成员函数是覆盖（override）了基类中的虚函数。当我们使用该关键字时，编译器会检查派生类的这个函数是否确实重写了基类的虚函数（即函数名、参数列表和返回值类型都相同），否则会报错。</p>
</blockquote>
<p>使用<code>override</code>关键字的语法格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void function() override;</span><br></pre></td></tr></table></figure>
<h3 id="多态的表现形式一指针"><a class="markdownIt-Anchor" href="#多态的表现形式一指针"></a> 多态的表现形式一(指针)</h3>
<ul>
<li>
<p>派生类的指针可以赋给基类指针。</p>
</li>
<li>
<p>通过基类指针调用基类和派生类中的同名<strong>虚函数</strong>时:</p>
<p>(1) 若该指针指向一个基类的对象，那么被调用是基类的虚函数;</p>
<p>(2) 若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。</p>
</li>
</ul>
<p>这种机制就叫 <strong>“多态”</strong>。</p>
<p><em><strong>eg.指针</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived::func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">func</span>(); <span class="comment">// 输出 &quot;Derived::func()&quot;</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多态的表现形式二引用"><a class="markdownIt-Anchor" href="#多态的表现形式二引用"></a> 多态的表现形式二(引用)</h3>
<ul>
<li>
<p>派生类的对象可以赋给基类引用。</p>
</li>
<li>
<p>通过基类引用调用基类和派生类中的同名<strong>虚函数</strong>时:</p>
<p>(1) 若该引用引用的是一个基类的对象，那么被调用是基类的虚函数;</p>
<p>(2) 若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数。</p>
</li>
</ul>
<p>这种机制也叫做 <strong>“多态”</strong>。</p>
<p><em><strong>eg.引用</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived::func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base&amp; ref = derived;</span><br><span class="line">    ref.<span class="built_in">func</span>();  <span class="comment">// 输出 &quot;Derived::func()&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在面向对象的程序设计中使用多态，能够增强程序的可扩充性，即程序需要修改或增加功能的时候，需要改动和增加的代码较少</p>
</blockquote>
<h2 id="2多态示例2纯虚函数"><a class="markdownIt-Anchor" href="#2多态示例2纯虚函数"></a> 2.多态示例2：纯虚函数</h2>
<p>在C++中，声明函数体为空（也称为空函数或虚函数的默认实现）和声明纯虚函数之间有明显的区别：</p>
<ol>
<li>
<p>纯虚函数（Pure Virtual Function）：</p>
<ul>
<li>纯虚函数是一个虚函数，它在基类中声明但没有提供具体的实现。</li>
<li>声明纯虚函数时，在函数声明的末尾使用 “= 0” 来标记它，例如：<code>virtual void foo() = 0;</code>。</li>
<li>类中包含至少一个纯虚函数的类被称为抽象基类，无法实例化对象。</li>
<li>派生类必须提供纯虚函数的具体实现，否则它们也会成为抽象类。</li>
</ul>
</li>
</ol>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pureVirtualFunction</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>声明函数体为空（Empty Function）：</p>
<ul>
<li>声明函数体为空的函数是一个虚函数，但它提供了一个默认的空实现，派生类可以选择是否覆盖这个实现。</li>
<li>在函数定义中使用关键字 <code>virtual</code>，然后在函数体中仅提供一个空实现即可。</li>
<li>派生类可以选择性地覆盖这个虚函数，如果不覆盖，将继续使用默认的空实现。</li>
</ul>
</li>
</ol>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">emptyVirtualFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 默认的空实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>主要区别在于，纯虚函数要求派生类必须提供自己的实现，而声明函数体为空的虚函数提供了一个默认实现，但派生类可以选择是否覆盖它。</li>
<li>纯虚函数用于定义接口，强制派生类提供特定的功能，而函数体为空的虚函数提供了一种可选的默认实现，派生类可以继承或覆盖它，具有更大的灵活性。在C++中，声明函数体为空（也称为空函数或虚函数的默认实现）和声明纯虚函数之间有明显的区别：</li>
</ul>
<h2 id="3-多态实例几何形体程序纯虚函数"><a class="markdownIt-Anchor" href="#3-多态实例几何形体程序纯虚函数"></a> 3. 多态实例：几何形体程序(纯虚函数)</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">已知：</span><br><span class="line">几何形体处理程序: 输入若干个几何形体的参数，输出时要指明形状。要求按面积排序输出。</span><br><span class="line">Input:</span><br><span class="line">第一行是几何形体数目<span class="built_in">n</span> (不超过<span class="number">100</span>).下面有n行，每行以一个字母c开头.</span><br><span class="line">若c是则代表一个矩形，本行后面跟着两个整数，分别是矩形的宽和高;</span><br><span class="line">若 c 是 C’，则代表一个圆，本行后面跟着一个整数代表其半径;</span><br><span class="line">若c是“T’，则代表一个三角形，本行后面跟着三个整数，代表三条边的长度.</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CShape</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> <span class="type">double</span> Area = <span class="number">0</span>; <span class="comment">//纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Printlnfo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CRectangle</span>:<span class="keyword">public</span> CShape&#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="type">int</span> w,h;<span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">Area</span><span class="params">()</span></span>;<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PrintInfo</span><span class="params">()</span>&#125;</span>;</span><br><span class="line">CShape * pShapes[<span class="number">100</span>];<span class="function"><span class="type">int</span> <span class="title">MyCompare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * s1, <span class="type">const</span> <span class="type">void</span> *s2)</span>:</span></span><br><span class="line"><span class="function">int MyCompare(const void * s1, const void *s2)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line"><span class="type">double</span> a1,a2;</span><br><span class="line">CShape**pl; <span class="comment">// s1,s2 是 void * ，不可写“* s1”来取得s1指向的内容</span></span><br><span class="line">CShape**p2;</span><br><span class="line">p1=(CShape ** )s1;<span class="comment">//sl,s2指向pShapes数组中的元素，数组元素的类型是CShape*</span></span><br><span class="line">p2 =( CShape**)s2; <span class="comment">//  pl,p2都是指向指针的指针，类型为 CShape **</span></span><br><span class="line">a1 =(*p1)&gt;Area0);<span class="comment">// * p1 的类型是 Cshape *,是基类指针，故此句为多态</span></span><br><span class="line">a2 =(*p2)-&gt;<span class="built_in">Area</span>();</span><br><span class="line"><span class="keyword">if</span>( al &lt;a2)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>:</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( a2 &lt;a1)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对 MyCompare的解释：</p>
</blockquote>
<blockquote>
<p>const void * s1, const void *s2指向pShape数组中待比较的元素</p>
</blockquote>
<blockquote>
<p>不可写“* s1”来取得s1指向的内容:</p>
<p>编译时会出错，因为s1是void*类型的指针，s1的所占用的字节数无法判断。</p>
</blockquote>
<p>在C++中，<code>void*</code> 是一种特殊的指针类型，称为“无类型指针”（void pointer），它可以指向任何类型的数据，因为它没有指定具体的数据类型。当你使用 <code>void*</code> 类型的指针时，编译器不知道它指向的数据类型是什么，因此不允许直接对其进行解引用操作，即不允许使用 <code>*s1</code> 来取得指向的内容。</p>
<p>如果你想在 <code>MyCompare</code> 函数中访问 <code>s1</code> 和 <code>s2</code> 指向的内容，你需要进行类型转换，将它们转换为正确的类型，然后再进行解引用操作。这是因为编译器需要明确知道要访问的数据的类型，以便正确地解释和处理数据。</p>
<p>在你的代码中，你进行了如下的类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1 = (CShape**)s1; <span class="comment">// 将 void* 转换为 CShape** 类型的指针</span></span><br><span class="line">p2 = (CShape**)s2; <span class="comment">// 将 void* 转换为 CShape** 类型的指针</span></span><br></pre></td></tr></table></figure>
<p>这些类型转换允许你将 <code>s1</code> 和 <code>s2</code> 视为 <code>CShape**</code> 类型的指针，然后使用 <code>*p1</code> 和 <code>*p2</code> 来解引用它们，访问指向的 <code>CShape</code> 对象。</p>
<p>总之，<code>void*</code> 类型的指针是一种通用指针，不具有具体的类型信息，因此不能直接解引用。必须通过类型转换将其转换为正确的指针类型后，才能安全地使用 <code>*</code> 运算符来获取指向的内容。</p>
<blockquote>
<p>我们知道sl,s2指向pShapes数组中的元素，数组元素的类型是CShape*，因此需要强制类型转换。</p>
</blockquote>
<p>因此需要让p1指针指向CShape*类型的指针，p1是指向指针的指针（p1 = (CShape**)s1）</p>
<blockquote>
<p>对<code>Cshape**</code>的理解</p>
<blockquote>
<p>s1是void*类型，请解释为什么不转换为Cshape <em>类型而是Cshape</em>*</p>
<p><strong><i>Answer:</i></strong> 对于 <code>qsort</code> 函数的比较函数，<code>void*</code> 参数通常用于指向要排序的元素的指针。在这个特定的情境下，<code>s1</code> 和 <code>s2</code> 实际上是指向 <code>CShape*</code> 类型的指针数组中的元素的指针。</p>
<p>因此，在这里使用 <code>CShape**</code> 是为了将 <code>s1</code> 和 <code>s2</code> 转换为指向 <code>CShape*</code> 类型的指针，以便在比较函数中能够访问 <code>CShape</code> 对象。这是因为 <code>qsort</code> 函数需要比较函数的参数是 <code>const void*</code> 类型，但你实际上要比较的是 <code>CShape*</code> 类型的指针。</p>
<p>具体来说，<code>s1</code> 和 <code>s2</code> 是指向 <code>CShape*</code> 数组元素的指针，因此使用 <code>CShape**</code> 类型来进行类型转换，以便在比较函数中访问元素的实际内容。你可以把它看作是一种解开多层指针以获取元素的方法，因为元素本身就是 <code>CShape*</code> 类型的指针。</p>
<p>这种转换方式允许你在比较函数中访问 <code>CShape</code> 对象，以便进行排序操作，而不是仅仅比较指针地址。这是为了确保排序是基于元素的属性而不是元素的地址。</p>
</blockquote>
<blockquote>
<p>拆分<code>Cshape**</code>的层次理解<br />
当你将 <code>s1</code> 和 <code>s2</code> 进行类型转换为 <code>CShape**</code> 时，实际上是在拆分多层指针，以便在比较函数中访问 <code>CShape</code> 对象。下面是拆分过程的详细解释：</p>
<ol>
<li>假设你有一个数组 <code>CShape* shapes[]</code>，其中包含了多个 <code>CShape*</code> 类型的指针。</li>
<li><code>qsort</code> 的比较函数期望接收 <code>void*</code> 类型的参数，这意味着它将接收指向数组元素的指针，而不是数组元素本身。</li>
<li>当你将 <code>s1</code> 和 <code>s2</code> 强制转换为 <code>CShape**</code> 类型时，实际上是将它们转换为指向 <code>CShape*</code> 类型指针的指针。</li>
<li>这样，你就可以在比较函数中使用 <code>*p1</code> 和 <code>*p2</code> 来访问指向 <code>CShape*</code> 对象的指针，而不仅仅是数组元素的地址。</li>
</ol>
<p>在代码中，这个过程如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;CShape** p1 = (CShape**)s1; <span class="comment">// 将 void* 转换为 CShape** 类型的指针</span></span><br><span class="line">&gt;&gt;CShape** p2 = (CShape**)s2; <span class="comment">// 将 void* 转换为 CShape** 类型的指针</span></span><br></pre></td></tr></table></figure>
<p>现在，<code>p1</code> 和 <code>p2</code> 分别是指向 <code>CShape*</code> 对象的指针的指针。这使得你可以使用 <code>*p1</code> 和 <code>*p2</code> 来获取 <code>CShape*</code> 对象的实际内容，然后在比较函数中进行排序操作，而不仅仅是比较指针地址。这允许你基于 <code>CShape</code> 对象的属性来进行排序。</p>
</blockquote>
</blockquote>
<blockquote>
<p>既然需要强制类型转换为什么 MyCompare(const void * s1, const void <em>s2)写成void</em>类型</p>
</blockquote>
<p>在这段代码中，<code>MyCompare</code> 函数是用作 <code>qsort</code> 函数的比较函数。<code>qsort</code> 函数是一个通用的排序函数，它接受一个比较函数作为参数，并且该比较函数必须满足特定的签名要求。该比较函数需要以 <code>const void*</code> 类型的参数作为输入，因为 <code>qsort</code> 不知道要排序的元素的具体类型。因此，这里使用 <code>const void*</code> 类型作为参数类型。</p>
<p>下面是关于为什么使用 <code>const void*</code> 的解释：</p>
<ol>
<li><strong>通用性：</strong> <code>qsort</code> 函数被设计成可以对任何类型的数组进行排序，因此它不能假设要排序的元素的具体类型。使用 <code>const void*</code> 允许你传递任意类型的指针作为参数。</li>
<li><strong>类型安全性：</strong> 如果 <code>MyCompare</code> 函数的参数类型是 <code>const CShape*</code>，那么它只能用于 <code>CShape</code> 类型的指针，而不能用于其他类型的指针。使用 <code>const void*</code> 允许你在比较函数中进行类型转换，以适应不同类型的元素。</li>
</ol>
<p>在 <code>MyCompare</code> 函数中，参数 <code>s1</code> 和 <code>s2</code> 是 <code>const void*</code> 类型，因此你需要将它们转换为 <code>CShape*</code> 类型的指针，以便访问它们指向的对象。这就是为什么在函数中使用 <code>p1</code> 和 <code>p2</code> 进行类型转换，然后使用 <code>*p1</code> 和 <code>*p2</code> 来访问它们所指向的 <code>CShape</code> 对象的原因。</p>
<p>总之，使用 <code>const void*</code> 类型的参数是为了增加通用性，使 <code>MyCompare</code> 函数能够用于不同类型的元素，并且允许在函数内部进行必要的类型转换。这是一种常见的技巧，用于处理泛型代码或需要对不同类型的数据进行排序的情况。</p>
<h3 id="非构造函数非析构函数的成员函数中调用虚函数是多态"><a class="markdownIt-Anchor" href="#非构造函数非析构函数的成员函数中调用虚函数是多态"></a> 非构造函数,非析构函数的成员函数中调用虚函数，是多态</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;<span class="built_in">fun2</span>();&#125;<span class="comment">//&#123;this-&gt;fun2();&#125; this是基类指针，fun2是虚函数，所以是多态</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;Base::fun2(&quot;</span>&lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived:fun2(0&quot;</span>&lt;&lt; endl;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    Base * pBase= &amp; d;</span><br><span class="line">    pBase-&gt;<span class="built_in">fun1</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>◎实际输出</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived:<span class="built_in">fun2</span>()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在非构造函数,非析构函数的成员函数中调用虚函数，是多态! ! !</p>
</blockquote>
<h3 id="构造函数和析构函数中调用虚函数"><a class="markdownIt-Anchor" href="#构造函数和析构函数中调用虚函数"></a> 构造函数和析构函数中调用虚函数</h3>
<blockquote>
<p>在构造函数和析构函数中调用虚函数，不是多态。编译时即可确定，调用的函数是<code>自己的类或基类</code>中定义的函数，不会等到运行时才决定调用自己的还是派生类的函数。</p>
<p>在构造和析构期间，对象的类型是已知的，不会发生多态性。只有在对象完全构造之后，并且通过派生类指针或引用访问对象时，多态性才会生效。</p>
</blockquote>
<p>原理：由于编译时，派生类对象在初始化时先初始化基类，先执行基类的构造函数，此时派生类对象的构造函数还没有被初始化，如果在基类的初始化过程中调用了派生类还未被初始化的虚函数，这样的结果有可能是不正确的。</p>
<h3 id="隐藏"><a class="markdownIt-Anchor" href="#隐藏"></a> 隐藏</h3>
<blockquote>
<p>派生类中和基类中虚函数同名同参数表的函数，不加virtual也自动成为虚函数</p>
</blockquote>
<p>对于派生类中和基类中虚函数同名同参数表的函数，如果不加 <code>virtual</code> 关键字，它不会自动成为虚函数，而是被视为普通的函数。这意味着在派生类中的该函数将会隐藏基类中的同名函数，而不是覆盖它。这种情况通常被称为函数的隐藏（function hiding）。</p>
<p>要使派生类中的同名函数成为虚函数，你需要在派生类中显式使用 <code>virtual</code> 关键字进行声明，并确保函数签名（参数列表和返回类型）与基类中的虚函数完全匹配。</p>
<p>以下是一个示例，说明了这一点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void virtualFunction() &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Base virtual function&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    void virtualFunction() override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Derived virtual function&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Base* basePtr = new Derived();</span><br><span class="line">    basePtr-&gt;virtualFunction();  // 输出 &quot;Derived virtual function&quot;</span><br><span class="line">    delete basePtr;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>Base</code> 类有一个虚函数 <code>virtualFunction()</code>。在 <code>Derived</code> 类中，我们重写了同名的函数，但没有显式添加 <code>virtual</code> 关键字。然而，由于函数签名匹配，<code>Derived</code> 类中的函数仍然被视为虚函数，并且在运行时多态性会生效，因此在 <code>main</code> 函数中通过基类指针调用时，将调用 <code>Derived</code> 类的版本。这是因为编译器会自动将覆盖的虚函数标记为 <code>override</code>，除非函数签名不匹配，否则可以省略 <code>virtual</code> 关键字。</p>
<h2 id="4多态的实现原理"><a class="markdownIt-Anchor" href="#4多态的实现原理"></a> 4.多态的实现原理</h2>
<p>“多态”的关键在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定——这叫 <strong>“动态联编”</strong>。 “动态联编”底是怎么实现的呢?</p>
<p><em><strong>eg</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base:Print&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Drived:Print&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(Base) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Derived);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理论上输出的内存大小Base=4（int i），Derived=8（继承的int i；int n）.程序输出为8,12.</p>
<blockquote>
<p>注：这里是理想化的算法，实际上会由于内存对齐等原因输出16,16.</p>
</blockquote>
<h3 id="多态实现的关键-虚函数表"><a class="markdownIt-Anchor" href="#多态实现的关键-虚函数表"></a> 多态实现的关键—-—虚函数表</h3>
<p>每一个有虚函数的类(或有虚函数的类的派生类）都有一个<strong>虚函数表</strong>，该类的任何对象（该类的实例）中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址。<strong>多出来的4个字节就是用来放虚函数表的地址的。</strong></p>
<blockquote>
<p>解释：</p>
<ol>
<li><strong>基类</strong>：当一个基类中包含虚函数时，编译器会在基类中生成一个虚函数表，其中包含了基类的虚函数的地址。这个虚函数表与基类的类型关联，并且基类的所有子类都会共享这个虚函数表。</li>
<li><strong>派生类</strong>：当你创建一个派生类时，它会继承基类的虚函数表，但也可以覆盖其中的虚函数，并在派生类的虚函数表中包含派生类的虚函数的地址。这样，派生类既包含了基类的虚函数表信息，又包含了自己的虚函数表信息。</li>
<li><strong>对象</strong>：每个类的对象中都包含一个指向该类的虚函数表的指针，这个指针通常被称为虚指针（vptr）。无论对象是基类的实例还是派生类的实例，都有一个虚指针，它指向该对象的实际类型的虚函数表。这是多态性的关键：通过虚指针，程序能够在运行时根据对象的实际类型来调用正确的虚函数。</li>
</ol>
</blockquote>
<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f47682cecb1436ab374f41ce3d19f48~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1091&h=690&s=196140&e=png&b=fcfafc" alt="LUP4W@M[RI@9$3MWW6D~2(D.png" width="70%" /></p>
<p>多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的)对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址,并调用虚函数的指令。</p>
<h3 id="虚函数表的证明"><a class="markdownIt-Anchor" href="#虚函数表的证明"></a> 虚函数表的证明</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::Func&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::Func&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    A *pa = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    pa-&gt;<span class="built_in">Func</span>();</span><br><span class="line">    <span class="comment">//64位程序指针为8字节</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> *p1 = (<span class="type">long</span> <span class="type">long</span> *) &amp;a;;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> *p2 = (<span class="type">long</span> <span class="type">long</span> *) pa;</span><br><span class="line">    *p2 = *p1;</span><br><span class="line">    pa-&gt;<span class="built_in">Func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码演示了C++中的虚函数和多态性，以及通过直接修改虚函数表指针来改变对象行为的技术。</p>
</blockquote>
<p>让我们逐步解释这段代码：</p>
<ol>
<li>
<p>首先，定义了两个类 <code>A</code> 和 <code>B</code>。<code>A</code> 类包含一个虚函数 <code>Func()</code>，而 <code>B</code> 类继承自 <code>A</code> 并重写了 <code>Func()</code> 函数，给出了不同的实现。</p>
</li>
<li>
<p>在 <code>main</code> 函数中：</p>
<ul>
<li>创建了一个 <code>A</code> 类对象 <code>a</code>。</li>
<li>创建了一个指向 <code>B</code> 类对象的基类指针 <code>pa</code>。这里使用了多态性，因为 <code>pa</code> 指向了 <code>B</code> 类对象，但是声明为 <code>A</code> 类指针。这意味着通过 <code>pa</code> 调用虚函数 <code>Func()</code> 时，将根据对象的实际类型调用相应的函数版本。</li>
</ul>
</li>
<li>
<p>接下来，通过将 <code>a</code> 对象的内存内容拷贝到 <code>pa</code> 对象的内存中，直接修改了虚函数表指针的值。这部分代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> *p1 = (<span class="type">long</span> <span class="type">long</span> *) &amp;a;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> *p2 = (<span class="type">long</span> <span class="type">long</span> *) pa;</span><br><span class="line">*p2 = *p1;</span><br></pre></td></tr></table></figure>
<p>这些操作实际上是将 <code>a</code> 对象的内存布局复制到 <code>pa</code> 指向的对象中，包括虚函数表指针。这样，<code>pa</code> 现在指向的虚函数表与 <code>a</code> 相同。</p>
</li>
<li>
<p>最后，再次通过 <code>pa</code> 调用虚函数 <code>Func()</code>。由于虚函数表指针已经被修改为与 <code>a</code> 相同，因此将调用 <code>A</code> 类中的 <code>Func()</code> 函数。</p>
</li>
</ol>
<blockquote>
<p>c++等语言的指针设计可以直接访问内存而不是需要借助整个对象，使程序更加丰富和灵活</p>
</blockquote>
<h2 id="5-虚析构函数-纯虚函数和抽象类"><a class="markdownIt-Anchor" href="#5-虚析构函数-纯虚函数和抽象类"></a> 5. 虚析构函数、纯虚函数和抽象类</h2>
<h3 id="虚析构函数"><a class="markdownIt-Anchor" href="#虚析构函数"></a> 虚析构函数</h3>
<ul>
<li>通过基类的指针删除派生类对象时，通常情况下只调用基类的析构函数
<ul>
<li>但是，删除一个派生类的对象时，应该先调用派生类的析构函数，然后调用基类的析构函数。</li>
</ul>
</li>
<li>解决办法:把基类的<code>析构函数声明为virtual</code>
<ul>
<li>派生类的析构函数可以virtual不进行声明</li>
<li>通过基类的指针删除派生类对象时，首先调用派生类的析构函数，然后调用基类的析构函数</li>
</ul>
</li>
<li>一般来说，一个类如果定义了虚函数，则应该将析构函数也定义成虚函数。3或者，一个类打算作为基类使用，也应该将析构函数定义成虚函数。</li>
<li><strong>注意:</strong> 不允许以虚函数作为构造函数</li>
</ul>
<h3 id="纯虚函数和抽象类"><a class="markdownIt-Anchor" href="#纯虚函数和抽象类"></a> 纯虚函数和抽象类</h3>
<ul>
<li>
<p>包含纯虚函数的类叫抽象类</p>
<ul>
<li>
<p>抽象类只能作为基类来派生新类使用，不能创建抽象类的对象</p>
</li>
<li>
<p>抽象类的指针和引用可以指向由抽象类派生出来的类的对象</p>
<p>A a ;// 错，A 是抽象类，不能创建对象</p>
<p>A*pa ; // ok,可以定义抽象类的指针和引用</p>
<p>pa = new A ;//错误，A 是抽象类，不能创建对象</p>
</li>
</ul>
</li>
<li>
<p>在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能调用纯虚函数。</p>
</li>
<li>
<p>如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数，它才能成为非抽象类。</p>
</li>
</ul>
<h1 id="第七章-输入输出和模板"><a class="markdownIt-Anchor" href="#第七章-输入输出和模板"></a> 第七章 输入输出和模板</h1>
<h2 id="1-输入输出流相关的类"><a class="markdownIt-Anchor" href="#1-输入输出流相关的类"></a> 1. 输入输出流相关的类</h2>
<h3 id="输出重定向"><a class="markdownIt-Anchor" href="#输出重定向"></a> 输出重定向</h3>
<p><code>freopen</code> 函数是C/C++标准库中的一个函数，用于重新定向标准I/O流。你提到的代码片段 <code>freopen(&quot;test.txt&quot;, &quot;w&quot;, stdout);</code> 的作用是将标准输出流 <code>stdout</code> 重定向到一个文件 <code>&quot;test.txt&quot;</code> 中，以便将输出写入到这个文件中，而不是默认的控制台输出。</p>
<p>具体解释如下：</p>
<ul>
<li><code>&quot;test.txt&quot;</code> 是要打开的文件的名称，这里是一个文本文件。</li>
<li><code>&quot;w&quot;</code> 表示以写入（write）模式打开文件。这将创建一个新文件（如果文件不存在），或者覆盖已存在的文件。</li>
<li><code>stdout</code> 是标准输出流的文件指针，它通常用于将输出写入控制台。</li>
</ul>
<p>所以，<code>freopen(&quot;test.txt&quot;, &quot;w&quot;, stdout);</code> 的效果是将标准输出流重定向到 <code>&quot;test.txt&quot;</code> 文件，之后所有的 <code>cout</code> 输出操作将被写入到 <code>&quot;test.txt&quot;</code> 文件中而不是显示在控制台上。</p>
<p>这种技术通常用于将程序的输出保存到文件中，以便稍后进行查看、分析或记录程序的输出。一旦调用了 <code>freopen</code>，程序的输出将不再显示在终端上，而是写入到指定的文件中。如果需要再次将输出恢复到终端，可以使用类似的方法将 <code>stdout</code> 重定向到终端。</p>
<h3 id="输入重定向"><a class="markdownIt-Anchor" href="#输入重定向"></a> 输入重定向</h3>
<h3 id="判断输入流结束"><a class="markdownIt-Anchor" href="#判断输入流结束"></a> 判断输入流结束</h3>
<p>可以用如下方法判输入流结束:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;x)&#123;</span><br><span class="line">... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>已知</strong></em></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;istream &amp;operator &gt;&gt;(int a)//右移运算符在istream类的重载</span><br><span class="line">&gt;&#123;</span><br><span class="line">   ...</span><br><span class="line">&gt;return *this ;//返回值是istream的引用，实际是cin的引用（即cin）</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>cin是如何作为逻辑值的判断？</p>
<p>强制类型转换运算符的重载，返回值虽然是cin，但在istream类中有强制类型转换的重载，转换为布尔类型的值</p>
</blockquote>
<ul>
<li>如果是从文件输入，比如前面有freopen(“some.txt”,”r”,stdin);那么，读到文件尾部，输入流就算结束</li>
<li>如果从键盘输入，则在单独一行输入Ctrl+Z代表输入流结束</li>
</ul>
<h3 id="istream类的成员函数"><a class="markdownIt-Anchor" href="#istream类的成员函数"></a> istream类的成员函数</h3>
<p><code>istream</code> 类是 C++ 标准库中用于输入流操作的基类，它提供了一系列成员函数来从输入源（通常是键盘、文件或其他输入设备）中读取数据。以下是一些常用的 <code>istream</code> 类成员函数：</p>
<ol>
<li><strong><code>operator&gt;&gt;</code>：</strong> 这是输入运算符重载函数，用于从输入流中读取数据并存储到变量中。它的参数取决于要读取的数据类型，例如 <code>int</code>、<code>double</code>、<code>char</code>、<code>string</code> 等。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code</span><br><span class="line">istream&amp; operator&gt;&gt;(Type&amp; variable);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong><code>get</code>：</strong> 用于从输入流中逐字符读取数据，可以指定读取的字符数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; get(char&amp; ch);</span><br><span class="line">istream&amp; get(char* s, streamsize count, char delim = &#x27;\n&#x27;);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p><strong>getline</strong></p>
<ul>
<li>
<p><code>istream &amp; getline (char * buf，int bufSize);</code></p>
<p>从输入流中读取<code>bufSize-1</code>个字符到缓冲区<code>buf</code>，或读到碰到<code>‘\n'</code>为止(哪个先到算哪个）。</p>
</li>
<li>
<p><code>istream &amp; getline (char * buf，int bufSize, char delim) ;</code></p>
<p>从输入流中读取<code>bufSize-1</code>个字符到缓冲区<code>buf</code>，或读到碰到delim字符为止(哪个先到算哪个）。</p>
</li>
</ul>
<p><em><strong>两个函数都会自动在buf中读入数据的结尾添加<code>\0</code>。 <code>,</code> <code>‘n’</code>或delim都不会被读入buf，但会被从输入流中取走。</strong></em> 如果输入流中<code>‘\n’</code>或delim之前的字符个数<strong>达到或超过了</strong>bufSize个，就导致读入出错，其结果就是:虽然本次读入已经完成，但是之后的读入就都会失败了。</p>
</li>
</ol>
<ul>
<li>可以用<code>if(!cin.getline(…))</code>判断输入是否结束</li>
</ul>
<ol start="4">
<li>
<p><strong><code>good</code>、<code>eof</code>、<code>fail</code> 和 <code>bad</code>：</strong></p>
<p>这些成员函数用于检查输入流的状态。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">good</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//bool eof();判断输入流是否结束</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">eof</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fail</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bad</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><strong><code>peek</code>：</strong> 返回下一个字符,用于查看输入流中的下一个字符而不从流中移除它。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li><strong><code>putback</code>：</strong> 用于将字符ch放回输入流中，以便后续读取。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">putback</span><span class="params">(<span class="type">char</span> ch)</span></span>;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li><strong><code>ignore</code>：</strong> 用于跳过指定数量的字符或特定字符，通常用于清除输入流中的缓冲区或跳过不需要的字符。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; ignore(streamsize count = 1, int delim = EOF);//从流中删掉最多count个字符，遇到EOF时结束</span><br></pre></td></tr></table></figure>
<ol start="8">
<li><strong><code>unget</code>：</strong> 用于将一个字符放回输入流中，与 <code>putback</code> 类似，但可以放回多个字符。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">unget</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<ol start="9">
<li><strong><code>clear</code>：</strong> 用于清除流的错误状态标志，通常与 <code>ignore</code> 和其他操作结合使用。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(iostate state = goodbit)</span></span>;</span><br></pre></td></tr></table></figure>
<ol start="10">
<li><strong><code>tie</code>：</strong> 用于设置或获取与输入流相关联的输出流。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream* <span class="title">tie</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">ostream* <span class="title">tie</span><span class="params">(ostream* new_tie)</span></span>;</span><br></pre></td></tr></table></figure>
<p>以上是一些常用的 <code>istream</code> 类成员函数及其参数。这些函数允许你从输入流中读取和处理数据，并提供了一些控制输入流状态的方法，以满足不同的输入处理需求。具体的使用方式取决于要处理的数据类型和输入源。</p>
<h2 id="2-用流操纵算子控制输出格式"><a class="markdownIt-Anchor" href="#2-用流操纵算子控制输出格式"></a> 2. 用流操纵算子控制输出格式</h2>
<blockquote>
<p>使用流操纵算子需要 <code>#include &lt;iomanip&gt;</code></p>
</blockquote>
<h3 id="整数流的基数流操纵算子decocthex"><a class="markdownIt-Anchor" href="#整数流的基数流操纵算子decocthex"></a> 整数流的基数:流操纵算子dec,oct,hex</h3>
<p><strong><code>dec</code>：</strong> 这个流操纵算子用于将整数以十进制形式输出。</p>
<p><strong><code>oct</code>：</strong> 这个流操纵算子用于将整数以八进制形式输出。</p>
<p><strong><code>hex</code>：</strong> 这个流操纵算子用于将整数以十六进制形式输出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">12</span>;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; hex &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; dec &lt;&lt; n &lt;&lt; endl &lt;&lt; oct &lt;&lt; n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="5泛型程序设计函数模板"><a class="markdownIt-Anchor" href="#5泛型程序设计函数模板"></a> 5.泛型程序设计·函数模板</h2>
<p>C++ 函数模板（Function Templates）是一种通用编程特性，允许你编写可以用于多种不同数据类型的函数。函数模板使得代码更加通用和可重用，它们在处理不同数据类型时可以减少代码的冗余。</p>
<p>注意事项：</p>
<ul>
<li>函数模板的模板参数可以有多个，并且可以是不同的类型。</li>
<li>使用模板时，编译器会根据传递的参数类型自动匹配模板参数的具体类型。</li>
<li>如果你需要特殊化某个数据类型的函数行为，可以提供特殊化版本的模板函数。</li>
</ul>
<p>函数模板是C++中强大的通用编程工具，它允许你编写通用、可重用的代码，以处理各种不同数据类型的情况。它在STL（标准模板库）中广泛使用，用于实现容器和算法。</p>
<p>函数模板︰</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>类型参数<span class="number">1</span> ，<span class="keyword">class</span>类型参数<span class="number">2</span>,......&gt;</span><br><span class="line">返回值类型 模板名(形参表)</span><br><span class="line">&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在C++中，函数模板的实例化通常是通过函数的参数类型来自动确定的。这是函数模板的主要用途之一，因为它允许根据不同的参数类型生成不同的函数实例。</p>
<p>但是，如果你想不通过参数实例化函数模板，可以考虑使用以下两种方法：</p>
<ol>
<li>显式指定模板参数类型：</li>
</ol>
<p>你可以使用尖括号 <code>&lt; &gt;</code> 显式指定函数模板的模板参数类型，而不依赖于函数的参数类型。这样可以创建特定模板参数类型的函数实例。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数模板的实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 显式实例化函数模板为 int 类型</span></span><br><span class="line">    <span class="built_in">MyFunction</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显式实例化函数模板为 double 类型</span></span><br><span class="line">    <span class="built_in">MyFunction</span>&lt;<span class="type">double</span>&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过在函数名后的尖括号中显式指定模板参数类型，可以实例化特定类型的函数。</p>
<ol start="2">
<li>使用模板特化：</li>
</ol>
<p>另一种方法是使用模板特化（template specialization）来创建特定类型的函数实例。模板特化允许你为特定的数据类型提供定制的实现，而不仅仅是依赖于模板参数类型的自动推导。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通用实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板特化为 int 类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">MyFunction</span>&lt;<span class="type">int</span>&gt;() &#123;</span><br><span class="line">    <span class="comment">// int 类型的定制实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">MyFunction</span>&lt;<span class="type">int</span>&gt;();      <span class="comment">// 调用特化版本</span></span><br><span class="line">    <span class="built_in">MyFunction</span>&lt;<span class="type">double</span>&gt;();   <span class="comment">// 调用通用版本</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们创建了一个通用的函数模板 <code>MyFunction()</code>，然后使用模板特化为 <code>int</code> 类型提供了一个定制的实现。当函数调用时，如果传递的参数类型是 <code>int</code>，将调用特化版本；否则，将调用通用版本。</p>
<p>这两种方法都允许你在不依赖于函数的参数类型的情况下实例化函数模板。</p>
<h3 id="函数模版的重载"><a class="markdownIt-Anchor" href="#函数模版的重载"></a> 函数模版的重载</h3>
<p>函数模板可以重载，只要它们的形参表或类型参数表不同即可</p>
<p>在有多个函数和函数模板名字相同的情况下，编译器如下处理条函数调用语句</p>
<ol>
<li>先找参数完全匹配的普通函数(非由模板实例化而得的函数</li>
<li>再找参数完全匹配的模板函数</li>
<li>再找实参数经过自动类型转换后能够匹配的普通函数</li>
<li>上面的都找不到，则报错</li>
</ol>
<blockquote>
<p>匹配模板函数时，不进行类型自动转换</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">myFunction</span><span class="params">(T arg1, T arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; arg1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arg2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> arg1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">myFunction</span>(<span class="number">5.8</span>, <span class="number">8.4</span>); <span class="comment">// ok: replace T with double</span></span><br><span class="line"><span class="built_in">myFunction</span>(<span class="number">5</span>, <span class="number">8.4</span>);   <span class="comment">// error, no matching function for call &#x27;myFunction(int, double)&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译器不会将实参类型进行隐式转换，例如不会将5转换为5.0。</p>
</blockquote>
<h3 id="函数指针"><a class="markdownIt-Anchor" href="#函数指针"></a> 函数指针</h3>
<ol>
<li>
<p><strong>函数指针</strong>：</p>
<ul>
<li>函数指针是指向函数的指针变量。它允许你在运行时动态地选择要调用的函数，以便灵活地执行不同的操作。</li>
<li>在C/C++中，函数名本身就是指向函数的指针。</li>
</ul>
</li>
<li>
<p><strong>函数指针类型</strong>：</p>
<ul>
<li>
<p>函数指针类型定义了函数指针所指向的函数的签名（参数类型和返回类型）。函数指针类型告诉编译器函数指针可以指向哪种类型的函数。</p>
</li>
<li>
<p>函数指针类型的声明方式为：<code>returnType (*pointerName)(parameterType1, parameterType2, ...)</code>，其中：</p>
<ul>
<li><code>returnType</code> 是函数的返回类型。</li>
<li><code>pointerName</code> 是函数指针的名称。</li>
<li><code>parameterType1</code>, <code>parameterType2</code>, … 是函数的参数类型。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>函数模板</strong>：</p>
<ul>
<li>函数模板允许你编写通用的函数，可以用于多种不同的数据类型。</li>
<li>在你的例子中，<code>Map</code> 函数是一个函数模板，它接受迭代器范围和函数指针作为参数。</li>
</ul>
</li>
<li>
<p><strong>使用函数指针</strong>：</p>
<ul>
<li>函数指针可以像普通函数一样调用，使用 <code>()</code> 运算符，并传递相应的参数。例如，<code>int result = addPtr(5, 3);</code>。</li>
<li>在你的例子中，<code>Map</code> 函数接受一个函数指针作为参数 <code>Pred op</code>，并在迭代器范围上应用该函数。</li>
</ul>
</li>
<li>
<p><strong>模板函数的参数推断</strong>：</p>
<ul>
<li>在函数模板调用时，编译器会自动推断模板参数的类型。在你的例子中，<code>Pred op</code> 的类型与传递给它的函数的类型一致，因此函数指针类型 <code>double (*op)(double)</code> 可以自动推导。</li>
</ul>
</li>
<li>
<p><strong>函数指针的用途</strong>：</p>
<ul>
<li>函数指针可以用于实现回调函数，允许你传递函数作为参数，以在特定事件发生时调用这些函数。</li>
<li>函数指针还常用于设计模式中，如策略模式，以根据需要在运行时选择不同的算法。</li>
</ul>
</li>
</ol>
<p>总结起来，函数指针是一项强大的C/C++特性，它允许你以灵活的方式处理和操作函数，使代码更具通用性和可扩展性。函数指针类型用于定义函数指针的签名，使编译器能够正确推断函数指针的类型。函数模板和函数指针的结合使得你可以编写通用的代码，能够处理多种不同的数据类型和操作。</p>
<p><em><strong>eg</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> Pred&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Map</span><span class="params">(T s, T e,T x, Pred op)</span> </span>&#123; <span class="keyword">for</span>( ; s != e; ++s ,++x)&#123; *x=<span class="built_in">op</span> (*s); &#125; &#125; </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">square</span> <span class="params">(<span class="type">double</span> )</span></span>&#123;<span class="keyword">return</span> x * x; &#125; </span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;, b[<span class="number">5</span>]; </span><br><span class="line"><span class="type">double</span> d[<span class="number">5</span>] = &#123; <span class="number">1.1</span>,<span class="number">2.1</span>,<span class="number">3.1</span>,<span class="number">4.1</span>,<span class="number">5.1</span>&#125; , c[<span class="number">5</span>]; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Map</span> (a ,a+<span class="number">5</span>,b, Square) ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) </span><br><span class="line">    cout &lt;&lt;b[i] &lt;&lt;<span class="string">&quot; , &quot;</span>;</span><br><span class="line">    cout &lt;&lt;endl ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码运行会实例化出<code>void Map(int * s, int * e, int * x,double ( *op)(double))</code>，请逐步详细解释<code>double ( *op)(double))</code>怎么得到的</p>
</blockquote>
<p>在你提供的代码中，<code>Map</code> 函数是一个通用的模板函数，它接受两个迭代器 <code>s</code> 和 <code>e</code>，还有一个指针 <code>x</code>，以及一个函数指针 <code>op</code> 作为参数。<code>Map</code> 函数的目的是将一个操作 <code>op</code> 应用于输入范围 <code>[s, e)</code> 中的每个元素，并将结果存储在输出数组 <code>x</code> 中。</p>
<p>在你的代码中，<code>Map</code> 函数的调用如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>(a, a+<span class="number">5</span>, b, Square);</span><br></pre></td></tr></table></figure>
<p>这里传递了以下参数：</p>
<ul>
<li><code>a</code> 是一个整数数组的指针，表示输入范围的起始位置。</li>
<li><code>a+5</code> 是整数数组的指针，表示输入范围的结束位置（不包括）。</li>
<li><code>b</code> 是一个整数数组的指针，表示输出数组的起始位置。</li>
<li><code>Square</code> 是一个函数指针，它指向 <code>double Square(double)</code> 函数。</li>
</ul>
<p>现在，让我们逐步解释如何得到 <code>double (*op)(double)</code> 类型的函数指针：</p>
<ol>
<li><code>Square</code> 是一个函数，它接受一个 <code>double</code> 参数并返回一个 <code>double</code> 值。因此，<code>Square</code> 具有类型 <code>double (double)</code>。</li>
<li>当你将 <code>Square</code> 作为参数传递给 <code>Map</code> 函数时，编译器会自动进行函数指针的类型推断，将 <code>Square</code> 的类型转化为函数指针类型。</li>
<li>因为 <code>op</code> 参数在 <code>Map</code> 函数中的类型是 <code>Pred op</code>，而 <code>Pred</code> 是模板参数，所以 <code>op</code> 的类型将与传递给它的参数类型一致。在这种情况下，<code>Square</code> 的类型 <code>double (double)</code> 被转化为 <code>double (*)(double)</code>，这表示一个指向接受 <code>double</code> 参数并返回 <code>double</code> 值的函数指针。</li>
</ol>
<p>所以，<code>double (*op)(double)</code> 表示一个函数指针类型，该指针指向一个函数，该函数接受一个 <code>double</code> 参数并返回一个 <code>double</code> 值。在 <code>Map</code> 函数中，它被用于对输入范围中的元素进行操作。</p>
<h2 id="6泛型程序设计类模板"><a class="markdownIt-Anchor" href="#6泛型程序设计类模板"></a> 6.泛型程序设计·类模板</h2>
<h3 id="类模板的定义"><a class="markdownIt-Anchor" href="#类模板的定义"></a> 类模板的定义</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>类型参数<span class="number">1</span> ，<span class="keyword">class</span>类型参数<span class="number">2</span>, .....&gt;<span class="comment">//类型参数表  注： &lt;typename T&gt;=&lt;class T&gt;</span></span><br><span class="line"><span class="keyword">class</span> 类模板名</span><br><span class="line">&#123;</span><br><span class="line">    成员函数和成员变量</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类模板里成员函数的写法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>类型参数<span class="number">1</span>，<span class="keyword">class</span>类型参数<span class="number">2</span>,......&gt;<span class="comment">//类型参数表</span></span><br><span class="line">返回值类型 类模板名 &lt;类型参数名列表&gt;::成员函数名（参数表)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用类模板定义对象的写法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模板名&lt;真实类型参数表&gt;对象名(构造函数实参表);</span><br></pre></td></tr></table></figure>
<p><em><strong>eg.类模板</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 key;<span class="comment">//关键字</span></span><br><span class="line">    T2 value;<span class="comment">//值</span></span><br><span class="line">    <span class="built_in">Pair</span>(T1 k, T2 v) : <span class="built_in">key</span>(k), <span class="built_in">value</span>(v) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Pair&lt;T1, T2&gt; &amp;p) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">bool</span> Pair&lt;T1, T2&gt;::<span class="keyword">operator</span>&lt;(<span class="type">const</span> Pair&lt;T1, T2&gt; &amp;p) <span class="type">const</span></span><br><span class="line"><span class="comment">//Pair的成员函数operator &lt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> key &lt; p.key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Pair&lt;string, <span class="type">int</span>&gt; <span class="title">student</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">19</span>)</span></span>;<span class="comment">//实例化出一个类Pair&lt;string ,int&gt;</span></span><br><span class="line">    cout &lt;&lt; student.key &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; student.value;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同一个类模板的两个模板类是不兼容的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Pair&lt;string ,<span class="type">int</span>&gt; *p;</span><br><span class="line">&gt;Pair&lt;string , <span class="type">double</span>&gt; a ;</span><br><span class="line">&gt;p=&amp;a; <span class="comment">//wrong</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="函数模板作为类模板成员"><a class="markdownIt-Anchor" href="#函数模板作为类模板成员"></a> 函数模板作为类模板成员</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">Func</span><span class="params">(T2 t)</span> </span>&#123; cout &lt;&lt; t; &#125;<span class="comment">//成员函数模板</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    a.<span class="built_in">Func</span>(<span class="string">&#x27;K&#x27;</span>); <span class="comment">//成员函数模板Func被实例化&lt;char&gt;</span></span><br><span class="line">    a.<span class="built_in">Func</span>(<span class="string">&quot;he1lo&quot;</span>); <span class="comment">//成员函数模板Func再次被实例化&lt;char*&gt;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类模板与非类型参数"><a class="markdownIt-Anchor" href="#类模板与非类型参数"></a> 类模板与非类型参数</h3>
<p>类模板的&quot;&lt;类型参数表&gt;”中可以出现非类型参数:<code>template &lt;class T, int size&gt;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CArray</span> &#123;</span><br><span class="line">    T array[size];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            cout &lt;&lt; array[i] &lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">CArray&lt;<span class="type">double</span>, <span class="number">40</span>&gt; a2;</span><br><span class="line">CArray&lt;<span class="type">int</span>, <span class="number">50</span>&gt; a3;<span class="comment">// a2和a3属于不同的类</span></span><br></pre></td></tr></table></figure>
<h2 id="7-类模板与派生-友元和静态成员变量"><a class="markdownIt-Anchor" href="#7-类模板与派生-友元和静态成员变量"></a> 7. 类模板与派生、友元和静态成员变量</h2>
<h3 id="类模板与继承"><a class="markdownIt-Anchor" href="#类模板与继承"></a> 类模板与继承</h3>
<ul>
<li>类模板从类模板派生</li>
<li>类模板从模板类派生</li>
<li>类模板从普通类派生</li>
<li>普通类从模板类派生</li>
</ul>
<h3 id="类模板与友元"><a class="markdownIt-Anchor" href="#类模板与友元"></a> 类模板与友元</h3>
<ul>
<li>函数、类、类的成员函数作为类模板的友元</li>
<li>函数模板作为类模板的友元</li>
<li>函数模板作为类的友元</li>
<li>类模板作为类模板的友元</li>
</ul>
<h3 id="类模板与static成员"><a class="markdownIt-Anchor" href="#类模板与static成员"></a> 类模板与static成员</h3>
<ul>
<li>类模板中可以定义静态成员，那么从该类模板实例化得到的所有类，都包含同样的静态成员。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>() &#123; count ++;&#125;</span><br><span class="line">        ~<span class="built_in">A</span>() &#123; count -- ; &#125;;</span><br><span class="line">        <span class="built_in">A</span>( A &amp;) &#123; count ++ ; &#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">PrintCount</span><span class="params">()</span> </span>&#123; cout &lt;&lt;count &lt;&lt;endl; &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">template</span>&lt;&gt; <span class="type">int</span> A&lt;<span class="type">int</span>&gt; :: count = <span class="number">0</span> ;</span><br><span class="line"> <span class="keyword">template</span>&lt;&gt; <span class="type">int</span> A&lt;<span class="type">double</span>&gt; ::count = <span class="number">0</span> ;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A&lt;<span class="type">int</span>&gt; ia;</span><br><span class="line">    A&lt;<span class="type">double</span>&gt; da;</span><br><span class="line">    <span class="function">ia <span class="title">PrintCount</span><span class="params">()</span> </span>;</span><br><span class="line">    da.<span class="built_in">PrintCount</span>() ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：1</span></span><br><span class="line"><span class="comment">//      1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>“<code>template&lt;&gt; int A&lt;int&gt;::count = 0;</code>” 行和 “<code>template&lt;&gt; int A&lt;double&gt;::count = 0;</code>” 行，对静态成员变量在类外部加以声明是必需的。在 Visual Studio 2008 中，这两行也可以简单地写成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int A&lt;int&gt;::count = 0;  </span><br><span class="line">int A&lt;double&gt;::count = 0;  </span><br></pre></td></tr></table></figure>
<p><code>A&lt;int&gt;</code> 和 <code>A&lt;double&gt; </code>是两个不同的类。虽然它们都有静态成员变量 <code>count</code>，但是显然，<code>A&lt;int&gt; </code>的对象 <code>ia </code>和 <code>A&lt;double&gt;</code> 的对象 <code>da</code> 不会共享一份<code> count</code>。</p>
<blockquote>
<p>同一个类模板实例出来类的静态成员变量名字一样，但是存储在不同的位置，不能共享。</p>
<p><strong>静态成员变量必须拿到类的外面单独声明一下，从包含静态变量的类模板实例化出来的类，同样要把这个类的静态成员拿出来声明一下。生命的同时你可以对他进行初始化也可以不进行初始化</strong></p>
</blockquote>
<h4 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h4>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ydxlt/article/details/51111654"># c++类模板遇上static关键字</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhizhengguan/article/details/116108271">C/C++编程：类模板中的静态成员</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tangzhenqiang/p/4332801.html">C++ 模板 静态成员 定义（实例化）</a></p>
<p>当<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%B1%BB%E6%A8%A1%E6%9D%BF&amp;spm=1001.2101.3001.7020">类模板</a>中有静态成员变量时，情况与普通类的静态成员变量不同。<strong>普通类中的静态成员函数需要在某个代码文件中显式声明，以便在该代码文件编译后可以为静态成员变量留出存储空间以供之后链接使用</strong>。而类模板中的静态变量却无法如此处理。</p>
<p><strong>C++标准提倡将模板的所有实现都放在头文件中以便编译器可以当场实现模板实例，这样能够避免产生跨目标链接</strong>。但是类模板静态成员变量却与这一提倡冲突。<strong>类模板的静态成员变量是所有同类型的类模板实例共享的一块数据。</strong> <strong>当多个目标文件中声明了同一类模板的同类型实例后，必然会产生跨目标文件链接</strong>。为了与标准所倡导的风格一致，C.++编译器都会对类模板静态成员变量做特殊处理。</p>
<p>只要静态成员变量的模板与其类模板同时可见，编译器就可针对类模板的静态成员变量做特殊处理：</p>
<ul>
<li>在目标文件中写入类模板实例中静态成员变量的初始值。</li>
<li>将此模板实例静态成员变量做类似外部变量处理，即在汇编代码中为该变量临时分配一个内存地址，但在目标文件中标记该地址所关联的变量名以及链接属性等，以便在随后又链接器修改地址，以正确实现多个类模板实例共享同一内存地址</li>
</ul>
<p>在链接时同样需要对类模板静态成员变量做特殊处理。因为类模板静态成员变量的实现以及初始值是写在头文件中，故而在每个包含了该头文件的代码文件中，都会存在若干个该类实例的静态成员变量“副本”。如果在不同文件中都生成了同一模板参数值的实例，则会有多个该实例的“副本”，从而产生冲突。此时，链接器需要解决此冲突。</p>
<p><em><strong>前言：</strong></em></p>
<p>在c++中我们可以使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。</p>
<p>在c++中，我们不能把静态成员放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化，如下面的实例所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明类静态成员，这里不能对它进行初始化赋值</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化类静态成员（通过范围解析符::)</span></span><br><span class="line"><span class="type">int</span> Obj::m_a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 通过对象访问静态属性</span></span><br><span class="line">    Obj o;</span><br><span class="line">    o.m_a = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; o.m_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过类访问静态属性</span></span><br><span class="line">    cout &lt;&lt; Obj::m_a &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c++类模板遇到static</p>
<p>当类模板中出现static修饰的静态类成员的时候，我们只要按照正常理解就可以了。static的作用是将类的成员修饰成静态的，所谓的静态类成员就是指类的成员为类级别的，不需要实例化对象就可以使用，而且类的所有对象都共享同一个静态类成员，因为类静态成员是属于类而不是对象。那么，类模板的实现机制是通过二次编译原理实现的。c++编译器并不是在第一个编译类模板的时候就把所有可能出现的类型都分别编译出对应的类（太多组合了），而是在第一个编译的时候编译一部分，遇到泛型不会替换成具体的类型（这个时候编译器还不知道具体的类型），而是在第二次编译的时候再将泛型替换成具体的类型（这个时候编译器知道了具体的类型了）。由于类模板的二次编译原理再加上static关键字修饰的成员，当它们在一起的时候实际上一个类模板会被编译成多个具体类型的类，所以，不同类型的类模板对应的static成员也是不同的（不同的类），但相同类型的类模板的static成员是共享的（同一个类）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> T <span class="type">m_t</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T Obj&lt;T&gt;::<span class="type">m_t</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Obj&lt;<span class="type">int</span>&gt; i1,i2,i3;</span><br><span class="line">    i1.<span class="type">m_t</span> = <span class="number">10</span>;</span><br><span class="line">    i2.<span class="type">m_t</span>++;</span><br><span class="line">    i3.<span class="type">m_t</span>++;</span><br><span class="line">    cout &lt;&lt; Obj&lt;<span class="type">int</span>&gt;::<span class="type">m_t</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    Obj&lt;<span class="type">float</span>&gt; f1,f2,f3;</span><br><span class="line">    f1.<span class="type">m_t</span> = <span class="number">10</span>;</span><br><span class="line">    f2.<span class="type">m_t</span>++;</span><br><span class="line">    f3.<span class="type">m_t</span>++;</span><br><span class="line">    cout &lt;&lt; Obj&lt;<span class="type">float</span>&gt;::<span class="type">m_t</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    Obj&lt;<span class="type">char</span>&gt; c1,c2,c3;</span><br><span class="line">    c1.<span class="type">m_t</span> = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    c2.<span class="type">m_t</span>++;</span><br><span class="line">    c3.<span class="type">m_t</span>++;</span><br><span class="line">    cout &lt;&lt; Obj&lt;<span class="type">char</span>&gt;::<span class="type">m_t</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">12</span> </span><br><span class="line">&gt;<span class="number">12</span> </span><br><span class="line">&gt;c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以看到相同类型如<span class="type">int</span>对应的类模板的对象之间的<span class="type">static</span>成员是共享的，不同类型之间如<span class="type">int</span>,<span class="type">float</span>,<span class="type">char</span>对应的类模板的对象之间的<span class="type">static</span>是不共享的。</span><br><span class="line"></span><br><span class="line">## 第八章 标准模板库<span class="built_in">STL</span>(一)</span><br><span class="line">### <span class="number">1.</span>string类</span><br><span class="line">- string类是模板类:</span><br><span class="line">`<span class="keyword">typedef</span> basic_string&lt;<span class="type">char</span>&gt; string`</span><br><span class="line">- 使用string类要包含头文件`&lt;string&gt;`</span><br><span class="line"></span><br><span class="line">- string 对象的长度用成员函数<span class="built_in">length</span>()读取</span><br><span class="line">   - <span class="function">string <span class="title">s</span><span class="params">( <span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">   - cout &lt;&lt; s.<span class="built_in">length</span>() &lt;&lt; endl;</span><br><span class="line">- string支持流读取运算符(直接读入到stringObject）</span><br><span class="line">   - string stringObject;</span><br><span class="line">   - cin &gt;&gt; stringObject; </span><br><span class="line"></span><br><span class="line">- string支持getline函数（读入一行）</span><br><span class="line">   - string s;</span><br><span class="line">   - <span class="built_in">getline</span>(cin,s);</span><br><span class="line"></span><br><span class="line">###<span class="meta"># string的赋值和连接</span></span><br><span class="line">- 用=赋值</span><br><span class="line">   - string <span class="built_in">s1</span>(<span class="string">&quot;cat&quot;</span>), s2</span><br><span class="line">   - ;- s2 = s1;</span><br><span class="line">- 用assign成员函数复制</span><br><span class="line">   - string <span class="built_in">s1</span>(<span class="string">&quot;cat&quot;</span>), s3;</span><br><span class="line">   - s3.<span class="built_in">assign</span>(s1);</span><br><span class="line">- assian 成员函数部分复制</span><br><span class="line">   - string <span class="built_in">s1</span>(<span class="string">&quot;catpig&quot;</span>), s3;</span><br><span class="line">   - s3.<span class="built_in">assign</span>(s1,<span class="number">1</span>，<span class="number">3</span>);</span><br><span class="line">   - <span class="comment">//从s1中下标为1的字符开始复制3个字</span></span><br><span class="line">- 单个字符复制</span><br><span class="line">   - s2[<span class="number">5</span>] = s1[<span class="number">3</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">- 逐个访问string对象中的字符</span><br><span class="line">  - string <span class="built_in">s1</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  - <span class="keyword">for</span>(<span class="type">int</span> i=O;i&lt;s1.<span class="built_in">length</span>();i++)cout &lt;&lt; s1.<span class="built_in">at</span>(i) &lt;&lt; endl;</span><br><span class="line">- 成员函数at会做`范围检查`，如果超出范围，会抛出out_of_range异常，而`下标运算符[]`不做范围检查。</span><br><span class="line">- 用+运算符连接字符串</span><br><span class="line">- 用成员函数append连接字符串</span><br><span class="line">- </span><br><span class="line">#### 比较string</span><br><span class="line">- 用关系运算符比较string的大小</span><br><span class="line">   - =，&gt;，&gt;=,&lt;,&lt;=，!=</span><br><span class="line">   - 用成员函数compare比较string的大小</span><br><span class="line"></span><br><span class="line">#### 子串</span><br><span class="line">- 成员函数 substr</span><br><span class="line"></span><br><span class="line">#### 交换函数</span><br><span class="line">- 成员函数 swap</span><br><span class="line"></span><br><span class="line">#### 查找string中的字符</span><br><span class="line">- 成员函数<span class="built_in">find</span>()</span><br><span class="line">   - 在s1中从前向后查找</span><br><span class="line">- 成员函数<span class="built_in">rfind</span>()</span><br><span class="line">    - 在s1中从后向前查找</span><br><span class="line">- 成员函数<span class="built_in">find_first_of</span>()</span><br><span class="line">   - 在字符串中从前向后查找一个指定字符集中第一个出现的字符位置，并返回该位置的下标。否则返回 `std::string::npos`。</span><br><span class="line">- 成员函数<span class="built_in">find_last_of</span>()</span><br><span class="line">   - 在字符串中从后向前查找一个指定字符集中第一个出现的字符位置，并返回该位置的下标。否则返回 `std::string::npos`。</span><br><span class="line">- 成员函数 <span class="built_in">find_first_not_of</span>()</span><br><span class="line">   - 在字符串中从前向后查找第一个不属于指定字符集的字符，并返回该字符在字符串中的位置下标。否则返回 `std::string::npos`。 </span><br><span class="line">- 成员函数 <span class="built_in">find_last_not_of</span>()</span><br><span class="line">   - 在字符串中从后向前查找第一个不属于指定字符集的字符，并返回该字符在字符串中的位置下标。否则返回 `std::string::npos`。 </span><br><span class="line"></span><br><span class="line">#### 删除string中的字符</span><br><span class="line">- 成员函数<span class="built_in">erase</span>()</span><br><span class="line"></span><br><span class="line">#### 替换string中的字符</span><br><span class="line">- 成员函数<span class="built_in">replace</span>()</span><br><span class="line"></span><br><span class="line">#### 在string中插入字符</span><br><span class="line">- 成员函数<span class="built_in">insert</span>()</span><br><span class="line"></span><br><span class="line">#### 转换成C语言式<span class="type">char</span>*字符串</span><br><span class="line">- 成员函数<span class="built_in">c_str</span>()</span><br><span class="line">   - .<span class="built_in">c_str</span>()返回传统的`<span class="type">const</span> <span class="type">char</span> *`类型字符串，且该字符串以\<span class="number">0</span>’结尾。</span><br><span class="line">- 成员函数<span class="built_in">data</span>()</span><br><span class="line">   - .<span class="built_in">data</span>()返回的是` <span class="type">char</span> *`类型字符串。</span><br><span class="line"></span><br><span class="line">&gt;需要注意的是，<span class="built_in">data</span>()函数返回的指针是指向内部数据的指针，并且在字符串对象被修改或销毁之前都是有效的。但是，应该避免在返回的指针上进行写操作，除非你非常清楚其影响和风险。通常情况下，更推荐使用成员函数<span class="built_in">c_str</span>()来获取字符串的<span class="type">const</span> <span class="type">char</span>*指针，因为它会保证以空字符结尾（null-terminated），并且不允许对返回的指针进行写操作。</span><br><span class="line"></span><br><span class="line">#### 字符串流处理</span><br><span class="line">- 除了标准流和文件流输入输出外，还可以从string进行输入输出;</span><br><span class="line">- 类似istream和osteram进行标准流输入输出，我们用istringstream和ostringstream进行字符串上的输入输出，也称为内存输入输出。</span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="字符串流处理-字符串输入流-istringstream"><a class="markdownIt-Anchor" href="#字符串流处理-字符串输入流-istringstream"></a> 字符串流处理-字符串输入流 <code>istringstream</code></h4>
<p><code>istringstream</code> 类是用于从字符串中提取数据的类。同样，我们首先需要包含头文件 <code>&lt;sstream&gt;</code>：</p>
<p>然后，我们可以使用 <code>istringstream</code> 来构建一个字符串流对象，并使用 <code>&gt;&gt;</code> 运算符从该流中提取数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">input</span> <span class="params">( <span class="string">&quot; Input test 123 4.7 A&quot;</span>)</span></span>;<span class="function">istringstream <span class="title">inputstring</span> <span class="params">(input)</span> </span>;</span><br><span class="line">string string1 , string2 ;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">double</span> d;<span class="type">char</span> c;</span><br><span class="line">inputstring &gt;&gt;string1 &gt;&gt;string2 &gt;&gt;i &gt;</span><br><span class="line">d &gt;&gt;c;</span><br><span class="line">cout &lt;&lt;string1 &lt;&lt;endl &lt;&lt;string2 &lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; i &lt;endl &lt;&lt; d &lt;&lt; endl &lt;&lt;c &lt;&lt;endl;<span class="type">long</span> L;</span><br><span class="line"><span class="keyword">if</span> (inputstring &gt;&gt;L) cout &lt;&lt;<span class="string">&quot;long\n&quot;</span> ;<span class="keyword">else</span> cout &lt;&lt;<span class="string">&quot;ermpty \n&quot;</span> ;</span><br></pre></td></tr></table></figure>
<p><em><strong>输出：</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lnput</span><br><span class="line">test</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">4.7</span></span><br><span class="line">A</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<h4 id="字符串流处理-字符串输出流-ostringstream"><a class="markdownIt-Anchor" href="#字符串流处理-字符串输出流-ostringstream"></a> 字符串流处理-字符串输出流 <code>ostringstream</code></h4>
<p><code>ostringstream</code> 类是用于将其他数据类型（如整数、浮点数、字符串等）转换为字符串的类。</p>
<p>然后，我们可以使用 <code>ostringstream</code> 来构建一个字符串流对象，并使用 <code>&lt;&lt;</code> 运算符将数据写入该流：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostringstream oss;</span><br><span class="line"><span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">string text = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;The number is: &quot;</span> &lt;&lt; number &lt;&lt; <span class="string">&quot;. The text is: &quot;</span> &lt;&lt; text;</span><br><span class="line">cout &lt;&lt; oss.<span class="built_in">str</span>() &lt;&lt; endl; </span><br></pre></td></tr></table></figure>
<p><em><strong>输出：</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The number is: <span class="number">42.</span> The text is: Hello, World!</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.dreamchasing.top">HAO_dev</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.dreamchasing.top/2023/09/13/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://www.dreamchasing.top/2023/09/13/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.dreamchasing.top" target="_blank">少年没有乌托邦</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="http://picbed.dreamchasing.top/img/spring.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://picbed.dreamchasing.top/img/Alipay.jpg" target="_blank"><img class="post-qr-code-img" src="https://picbed.dreamchasing.top/img/Alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li><li class="reward-item"><a href="https://picbed.dreamchasing.top/img/WeChatpay.jpg" target="_blank"><img class="post-qr-code-img" src="https://picbed.dreamchasing.top/img/WeChatpay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/23/%E8%A7%A3%E5%86%B3Clion%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/" title="C++学习笔记"><img class="cover" src="http://picbed.dreamchasing.top/img/spring.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="计算机网络学习笔记"><img class="cover" src="http://picbed.dreamchasing.top/img/spring.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络学习笔记</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://picbed.dreamchasing.top/img/Avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">HAO_dev</div><div class="author-info__description">一个普通计算机专业学生的个人博客<br/>记录着学习笔记和生活<br/>愿柳暗终将花明</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Hao-star123"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Hao-star123" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1194924237@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/1194924237" target="_blank" title="QQ"><i class="fa-brands fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to my Blog !</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#theme-vue-prohighlight-mono-blue"><span class="toc-text"> theme: vue-pro
highlight: mono-blue</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%BB%8Ec%E5%88%B0c"><span class="toc-text"> 第一章从C到C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%94%A8%E6%B3%951"><span class="toc-text"> 类和对象的基本概念与用法(1)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80"><span class="toc-text"> 第二章 类和对象基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B52"><span class="toc-text"> 1.类和对象的基本概念(2)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text"> 2. 构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E5%A4%8D%E5%88%B6%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text"> 3.复制（拷贝）构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text"> 构造函数和拷贝构造函数的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text"> 4.1类型转换构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text"> 4.2 析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BF%94%E5%9B%9E%E5%90%8E%E8%A2%AB%E8%B0%83%E7%94%A8"><span class="toc-text"> 析构函数在对象作为函数返回值返回后被调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="toc-text"> 5. 构造函数析构函数调用时机</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%8F%90%E9%AB%98"><span class="toc-text"> 第三章 类和对象提高</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-this%E6%8C%87%E9%92%88"><span class="toc-text"> 1. this指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text"> 2.静态成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%88%90%E5%91%98%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E9%97%AD%E7%B1%BB"><span class="toc-text"> 3. 成员对象和封闭类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E9%97%AD%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text"> 封闭类构造函数和析构函数的执行顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1-%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text"> 4. 常量对象、常量成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1"><span class="toc-text"> 常量对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text"> 常量成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-text"> 常量成员函数的重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E5%BC%95%E7%94%A8"><span class="toc-text"> 常引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E5%8F%8B%E5%85%83"><span class="toc-text"> 5.友元</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text"> 第四章 运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text"> 1. 运算符重载的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-text"> 2. 赋值运算符的重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text"> 浅拷贝和深拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9-operator-%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AE%A8%E8%AE%BA"><span class="toc-text"> 对 operator &#x3D; 返回值类型的讨论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BB%A7%E6%89%BF"><span class="toc-text"> 第五章 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text"> 1. 继承和派生的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E5%86%99%E6%B3%95"><span class="toc-text"> 派生类的写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-text"> 派生类对象的内存空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%92%8C%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-text"> 2. 继承关系和复合关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text"> 复合关系的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E8%A6%86%E7%9B%96%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%88%90%E5%91%98"><span class="toc-text"> 3.覆盖和保护成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96"><span class="toc-text"> 覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9C%89%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text"> 基类和派生类有同名成员的情况:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#private-protected%E5%92%8Cpublic%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-text"> private、protected和public的范围</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text"> 4. 派生类的构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E9%97%AD%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text"> 封闭派生类对象的构造函数的执行顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#public%E7%BB%A7%E6%89%BF%E7%9A%84%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99"><span class="toc-text"> public继承的赋值兼容规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#public%E7%BB%A7%E6%89%BF%E7%9A%84%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99-2"><span class="toc-text"> public继承的赋值兼容规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%9F%BA%E7%B1%BB%E5%92%8C%E9%97%B4%E6%8E%A5%E5%9F%BA%E7%B1%BB"><span class="toc-text"> 直接基类和间接基类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%B1%82%E7%B1%BB%E5%B5%8C%E5%A5%97%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="toc-text"> 多层类嵌套的构造与析构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%A4%9A%E6%80%81"><span class="toc-text"> 第六章 多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text"> 1. 虚函数和多态的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text"> 虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F%E4%B8%80%E6%8C%87%E9%92%88"><span class="toc-text"> 多态的表现形式一(指针)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F%E4%BA%8C%E5%BC%95%E7%94%A8"><span class="toc-text"> 多态的表现形式二(引用)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E5%A4%9A%E6%80%81%E7%A4%BA%E4%BE%8B2%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text"> 2.多态示例2：纯虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%9A%E6%80%81%E5%AE%9E%E4%BE%8B%E5%87%A0%E4%BD%95%E5%BD%A2%E4%BD%93%E7%A8%8B%E5%BA%8F%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text"> 3. 多态实例：几何形体程序(纯虚函数)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%9D%9E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E6%98%AF%E5%A4%9A%E6%80%81"><span class="toc-text"> 非构造函数,非析构函数的成员函数中调用虚函数，是多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text"> 构造函数和析构函数中调用虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E8%97%8F"><span class="toc-text"> 隐藏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text"> 4.多态的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%85%B3%E9%94%AE-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-text"> 多态实现的关键—-—虚函数表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E7%9A%84%E8%AF%81%E6%98%8E"><span class="toc-text"> 虚函数表的证明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text"> 5. 虚析构函数、纯虚函数和抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text"> 虚析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text"> 纯虚函数和抽象类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E6%A8%A1%E6%9D%BF"><span class="toc-text"> 第七章 输入输出和模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB"><span class="toc-text"> 1. 输入输出流相关的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text"> 输出重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text"> 输入重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E8%BE%93%E5%85%A5%E6%B5%81%E7%BB%93%E6%9D%9F"><span class="toc-text"> 判断输入流结束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#istream%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text"> istream类的成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%94%A8%E6%B5%81%E6%93%8D%E7%BA%B5%E7%AE%97%E5%AD%90%E6%8E%A7%E5%88%B6%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-text"> 2. 用流操纵算子控制输出格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%B5%81%E7%9A%84%E5%9F%BA%E6%95%B0%E6%B5%81%E6%93%8D%E7%BA%B5%E7%AE%97%E5%AD%90decocthex"><span class="toc-text"> 整数流的基数:流操纵算子dec,oct,hex</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-text"> 5.泛型程序设计·函数模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-text"> 函数模版的重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-text"> 函数指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-text"> 6.泛型程序设计·类模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text"> 类模板的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98"><span class="toc-text"> 函数模板作为类模板成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-text"> 类模板与非类型参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B4%BE%E7%94%9F-%E5%8F%8B%E5%85%83%E5%92%8C%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text"> 7. 类模板与派生、友元和静态成员变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-text"> 类模板与继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%8F%8B%E5%85%83"><span class="toc-text"> 类模板与友元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8Estatic%E6%88%90%E5%91%98"><span class="toc-text"> 类模板与static成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-text"> 参考文章</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B5%81%E5%A4%84%E7%90%86-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%E6%B5%81-istringstream"><span class="toc-text"> 字符串流处理-字符串输入流 istringstream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B5%81%E5%A4%84%E7%90%86-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%87%BA%E6%B5%81-ostringstream"><span class="toc-text"> 字符串流处理-字符串输出流 ostringstream</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By HAO_dev</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.dreamchasing.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.dreamchasing.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="/js/cursor.js"></script><script async data-pjax src="/js/custom.js"></script><script async data-pjax src="/js/waterfall/waterfall.js"></script><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script src="https://sdk.51.la/perf/js-sdk-perf.min.js" crossorigin="anonymous"></script><script>LA.init({id:"JxNS4Qe50aT9GIvq",ck:"JxNS4Qe50aT9GIvq"})</script><script> new LingQue.Monitor().init({id:"JxWCfqHQUjFQPhW7"});</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://picbed.dreamchasing.top/img/cicon.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/学习相关/&quot;);" href="javascript:void(0);">学习相关</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr">ACM</span></li><li class="categoryBar-list-item" style="background:url(https://picbed.dreamchasing.top/img/cbookicon.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/刷题/&quot;);" href="javascript:void(0);">刷题</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">C语言学习笔记</span></li><li class="categoryBar-list-item" style="background:url(https://picbed.dreamchasing.top/img/htmlicon.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/博客相关/&quot;);" href="javascript:void(0);">博客相关</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">HTML笔记</span></li><li class="categoryBar-list-item" style="background:url(https://picbed.dreamchasing.top/img/cssicon.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/环境配置/&quot;);" href="javascript:void(0);">环境配置</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">CSS笔记</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.2.2" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn/#/Integrated/index" style="margin-inline:5px" data-title="本站已在湘进行备案" title=""><img src="https://img.shields.io/badge/浙ICP备-2022004213号-e1d492?style=flat&amp;logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAdCAYAAAC9pNwMAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+nhxg7wAACNlJREFUSInF1mmMVeUdx/Hv2e+5+519mJWBYQZkGxZZxLKJqBXGoLS1iXWrmihotFXaJiTWWlsbl6q1aetWd5u0VkKjNG4YEJSlOCibDLMwM8x679z9nnPP1jcVJUxf+7z6J8+LT37/Z4VvaQhfFS8+sBXbctCDGrVTKlBUH4mxAbI9Hfj0IJLsp6paJ5/tmn20N/D0wKDRMq9F/c3M2U1/V0vDfWMFh+tv/Ig1zYPMabDImPJ52OaXO87W580KggCiiOsJOJ6I3wcNFaaeNKxrt72f2fLGu4FpJ/sDQABRzD22fH7/Yze069vGc6mrDLNIJCDik10sxz2by3VdPM87xzkP9jwPTZFRVI1YUJKH+oy7n3tbvv/P2wW/UQxRWe6w4ZJRptYLHDoCuz8v5cP92XbI762O+h6UVWHnUFbPpU0fEb2A60mMJ7MUi9b/b7UgKhiZMaIxm8YLplLMDPz8hl/EH+rs8TNlUpFf32uyZJGLPDwCiTGUyTWodTN49eUCdz2YwXb9NNcObp1X98WDoufynzMVCEKGn27ayPTWBi5ad8P5iQUkJEnFLjqM9Z+hrVX0vfDe6K2dPRWsW2bwyp9EUifSJB84gdxrkR0eRgv1o/3I4fbbprJ6scqamzVO9pffec1S5ZWY2Nfz5qEy/FqOC2Y3s3j53HMSi18VRjFPwSwg+1RfVbl115vvJrsfej7UGIsYPPGgQ7JXoO+Xx5B3dHEomyJ9x1qiQozkr95h5937aFnVyouPlgJK+Ss7Fxz64OTSxSX+LHYxT2IsRW5kbGI4oHcR0jqoqTjV9se3I7/f8rS/ClS23GxSXhph6L5d9Akm7qqZhHWBQGUJ+CWGFzcg7e7m6D3/ZuW1Ea5YKdA3EojuONi813TqNi+YPYOKUhXDtCeGL26/hakLLiEcdsaHRkRAoLRc4fJrmhnekyF0apgZowWSwwkaa+rw3f8WA1GZZsPP5JEChX8dhZTN6iU6kAcs5s+dHd183SJ0VVKL57pfw6YdRQw23aeWTns47DPTALWlRTR7kMLew6hGgYqUhWXYFFUdPZ6lUBahLA8hVcOftckfi7No7VRAAQqsX1dybfvG1qwriM9mM5mJ4e4jO5Cc01dPqixbr8tWGBQUL4vjGigEEShi+xUmZ2RiR/sJ1pbS8NkgZrKAGw0TsgQsQyFaF/nfYTGprAlMFysbA1pI3mhkR6snhGsaymYGvPyFEb9IdbUE2AzFFTwpRqCtBY0wmdER+hZW4j63gcJj38V+/ErSUZXsYBfjIZHIRW0c2Z8BskCAqN+CbBJBFnyyKjR+Ez57nBxLqpfMUeSISElMBFz6x2Q6OxzWrYjyxWVzEewioU3LCS5vQY6nMUrLwNaxXvoQ59IloFSx54PPAZtQLExVZZDxsVE8J4dn6v4JYatgbSjk0owPw7RGH2ADMo88Z7L20ip8f7gC7fAo0q4+0rt7kEQDvaghVZbiPHUHcyeXcfLjT3jmpR7AYsnSScya3UR8bARVMck7Y/cB75/X6rDf3Fg2dw2jKZm5dXGm1LuAzO5DCo9v6aT0ibco5kzOvLOP+NGTFJtDpPYeZKijk/Rn3QxsfZV7txwhX7ABiZUXBsGvIvguQApNQQva9RMmTvZ2dpVUls+tX/UD7GN/Y8Ws05w6rQF+9vyzg1vZjbvMRJhXiRSU8DpTFFe0QE8S6SfPkOkZoktrB2oAhZWrwljxOPmchiSMYOWNoxNuruFU5vWeXdsojiUon345113dBBQBmTYlTimgdB8nfPo4WjaNFgN9OMEkJ02dnadVt5ki54Esqy+bzKJltVhSPbI3iN2zCyMTeXNCuG7Omm2Zok7PR2+R7jvD8ouruHhmCrB5jVZeYxLdrTP4sr4Vtd9g4MA4qc4c+6cu5NPamfw4P59t2WrA4YdXKkASf7SFivo6PDdEPmf1fRM++zp1bH/0r4I1dD1ODtOWaW4IsvPjL7nqXhloQiSPwjjgMYkMASyGEBkjhISCQwkwzve/18AbT+pk8pVY4UacQi9y+gyZ0eRAw4qHa89LXEx1LXMSPfhDJYRb59BtlLKg2WPT2l6qYl1svtGkrLYckyA1S+t5+2ATm37WCui0LSynsckDNH5zTxAchbQtkx08hDHYiW6NgC0enHBzEZ102UDH8QORdEckjEzZrNWkRydzyx17uGnDXqbUnGZ6dRPjSY91q2TqwjFuvTxLo5Zn5Qo/pumRSFcTLQtybEhGE0fQrDhhJ0VvH2lTnnHPhGtsmWan469apERjI2MH3qN7+7MEfH6ql29CbV7PvsMG32k6yU2XDhEKyZw66eJaRdrXR7CzCcqUNC3zwgymPJRCH4KRRLINimpL14A5Y4GDeOqbsPRVcfuN7Xj44pav/hFfrNT2kr2rsqf2Ibp5pEA14ZIImUyW3t5REkkTXRGQ/DGGhtLginhqCWknQDE5hKf5UFSF9Lj020Q2ul5V1AR2hr+8vuP8Vlc2zMPRxoSjnx7XBC14sDoydahSGq7KdO/HFyrBchxCVfX4fDKp4T7SCQejYODZLrYgIqgKFsNIgQqEYob8mW6yiUyb7Z64LVK/+B85xznnJ3AWzqTzuIX46mr5wLs+UUTyIriBCjRNxguHMJIFDLEEvXEOVRWnSJ0+jCd4CJoGjoedM1CLcXQziW3nMV2TSMBeOx7vWZvPt1r+cMPzE8KunaUkFn0vNrvtqXj34c1W6gzxlEQ6naIoBahtnkMwoFMwIVzSRNguMt53Aj2s4nkSlgPoGqLkICsRNF0gl8rYWuP8+11/w/OOJDEhHPKLCIpOXmi+M9AgP+maiesLifF2T1Rn5ZNj5Lo/Qc/GcPMmhdoqlEgIGzCK4PiCmJKK68p4KfF3qYGuF0qCRUkJTzleUbvQyWRTuE5xYthxQbBs7EISAbkzUFG3VfXXbK2YFi3X/eryfKKnqVBItNjJxDzH8erddC4SqWwcN5WyTtlyO1RP/Lh3eHD76MB40swmiDVJyDLYRhpc5+ub6tse/wWKbvSQEAw1awAAAABJRU5ErkJggg==" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>